// This file is generated by rust-protobuf 2.18.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `identity/admin/admin.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_2;

#[derive(PartialEq,Clone,Default)]
pub struct CreateIdentityRequest {
    // message fields
    pub data: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub connection_id: ::std::string::String,
    pub schema_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateIdentityRequest {
    fn default() -> &'a CreateIdentityRequest {
        <CreateIdentityRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateIdentityRequest {
    pub fn new() -> CreateIdentityRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.Struct data = 1;


    pub fn get_data(&self) -> &::protobuf::well_known_types::Struct {
        self.data.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::well_known_types::Struct {
        self.data.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string connection_id = 2;


    pub fn get_connection_id(&self) -> &str {
        &self.connection_id
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: ::std::string::String) {
        self.connection_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_id(&mut self) -> &mut ::std::string::String {
        &mut self.connection_id
    }

    // Take field
    pub fn take_connection_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.connection_id, ::std::string::String::new())
    }

    // string schema_id = 3;


    pub fn get_schema_id(&self) -> &str {
        &self.schema_id
    }
    pub fn clear_schema_id(&mut self) {
        self.schema_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_schema_id(&mut self, v: ::std::string::String) {
        self.schema_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_id(&mut self) -> &mut ::std::string::String {
        &mut self.schema_id
    }

    // Take field
    pub fn take_schema_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.schema_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateIdentityRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.connection_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.schema_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.connection_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.connection_id);
        }
        if !self.schema_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.schema_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.connection_id.is_empty() {
            os.write_string(2, &self.connection_id)?;
        }
        if !self.schema_id.is_empty() {
            os.write_string(3, &self.schema_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateIdentityRequest {
        CreateIdentityRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "data",
                |m: &CreateIdentityRequest| { &m.data },
                |m: &mut CreateIdentityRequest| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "connection_id",
                |m: &CreateIdentityRequest| { &m.connection_id },
                |m: &mut CreateIdentityRequest| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "schema_id",
                |m: &CreateIdentityRequest| { &m.schema_id },
                |m: &mut CreateIdentityRequest| { &mut m.schema_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateIdentityRequest>(
                "CreateIdentityRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateIdentityRequest {
        static instance: ::protobuf::rt::LazyV2<CreateIdentityRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateIdentityRequest::new)
    }
}

impl ::protobuf::Clear for CreateIdentityRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.connection_id.clear();
        self.schema_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateIdentityRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateIdentityRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateIdentityResponse {
    // message fields
    pub identity_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateIdentityResponse {
    fn default() -> &'a CreateIdentityResponse {
        <CreateIdentityResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateIdentityResponse {
    pub fn new() -> CreateIdentityResponse {
        ::std::default::Default::default()
    }

    // string identity_id = 1;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateIdentityResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(1, &self.identity_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateIdentityResponse {
        CreateIdentityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &CreateIdentityResponse| { &m.identity_id },
                |m: &mut CreateIdentityResponse| { &mut m.identity_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateIdentityResponse>(
                "CreateIdentityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateIdentityResponse {
        static instance: ::protobuf::rt::LazyV2<CreateIdentityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateIdentityResponse::new)
    }
}

impl ::protobuf::Clear for CreateIdentityResponse {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateIdentityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateIdentityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentitiesRequest {
    // message fields
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentitiesRequest {
    fn default() -> &'a GetIdentitiesRequest {
        <GetIdentitiesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentitiesRequest {
    pub fn new() -> GetIdentitiesRequest {
        ::std::default::Default::default()
    }

    // int32 page_size = 1;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 2;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetIdentitiesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(1, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.page_size != 0 {
            os.write_int32(1, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(2, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentitiesRequest {
        GetIdentitiesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &GetIdentitiesRequest| { &m.page_size },
                |m: &mut GetIdentitiesRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &GetIdentitiesRequest| { &m.page_token },
                |m: &mut GetIdentitiesRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentitiesRequest>(
                "GetIdentitiesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentitiesRequest {
        static instance: ::protobuf::rt::LazyV2<GetIdentitiesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentitiesRequest::new)
    }
}

impl ::protobuf::Clear for GetIdentitiesRequest {
    fn clear(&mut self) {
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentitiesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentitiesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentitiesResponse {
    // message fields
    pub identities: ::protobuf::RepeatedField<GetIdentitiesResponse_Identity>,
    pub next_page_token: ::std::string::String,
    pub total_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentitiesResponse {
    fn default() -> &'a GetIdentitiesResponse {
        <GetIdentitiesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentitiesResponse {
    pub fn new() -> GetIdentitiesResponse {
        ::std::default::Default::default()
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetIdentitiesResponse.Identity identities = 1;


    pub fn get_identities(&self) -> &[GetIdentitiesResponse_Identity] {
        &self.identities
    }
    pub fn clear_identities(&mut self) {
        self.identities.clear();
    }

    // Param is passed by value, moved
    pub fn set_identities(&mut self, v: ::protobuf::RepeatedField<GetIdentitiesResponse_Identity>) {
        self.identities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_identities(&mut self) -> &mut ::protobuf::RepeatedField<GetIdentitiesResponse_Identity> {
        &mut self.identities
    }

    // Take field
    pub fn take_identities(&mut self) -> ::protobuf::RepeatedField<GetIdentitiesResponse_Identity> {
        ::std::mem::replace(&mut self.identities, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }

    // int32 total_size = 3;


    pub fn get_total_size(&self) -> i32 {
        self.total_size
    }
    pub fn clear_total_size(&mut self) {
        self.total_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_size(&mut self, v: i32) {
        self.total_size = v;
    }
}

impl ::protobuf::Message for GetIdentitiesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.identities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.identities)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.identities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        if self.total_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.total_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.identities {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        if self.total_size != 0 {
            os.write_int32(3, self.total_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentitiesResponse {
        GetIdentitiesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetIdentitiesResponse_Identity>>(
                "identities",
                |m: &GetIdentitiesResponse| { &m.identities },
                |m: &mut GetIdentitiesResponse| { &mut m.identities },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &GetIdentitiesResponse| { &m.next_page_token },
                |m: &mut GetIdentitiesResponse| { &mut m.next_page_token },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total_size",
                |m: &GetIdentitiesResponse| { &m.total_size },
                |m: &mut GetIdentitiesResponse| { &mut m.total_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentitiesResponse>(
                "GetIdentitiesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentitiesResponse {
        static instance: ::protobuf::rt::LazyV2<GetIdentitiesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentitiesResponse::new)
    }
}

impl ::protobuf::Clear for GetIdentitiesResponse {
    fn clear(&mut self) {
        self.identities.clear();
        self.next_page_token.clear();
        self.total_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentitiesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentitiesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentitiesResponse_Identity {
    // message fields
    pub identity_id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub main_identifier: ::std::string::String,
    pub schema_id: ::std::string::String,
    pub lock: GetIdentitiesResponse_Lock,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentitiesResponse_Identity {
    fn default() -> &'a GetIdentitiesResponse_Identity {
        <GetIdentitiesResponse_Identity as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentitiesResponse_Identity {
    pub fn new() -> GetIdentitiesResponse_Identity {
        ::std::default::Default::default()
    }

    // string identity_id = 1;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 2;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated_at = 3;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string main_identifier = 4;


    pub fn get_main_identifier(&self) -> &str {
        &self.main_identifier
    }
    pub fn clear_main_identifier(&mut self) {
        self.main_identifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_main_identifier(&mut self, v: ::std::string::String) {
        self.main_identifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_identifier(&mut self) -> &mut ::std::string::String {
        &mut self.main_identifier
    }

    // Take field
    pub fn take_main_identifier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.main_identifier, ::std::string::String::new())
    }

    // string schema_id = 5;


    pub fn get_schema_id(&self) -> &str {
        &self.schema_id
    }
    pub fn clear_schema_id(&mut self) {
        self.schema_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_schema_id(&mut self, v: ::std::string::String) {
        self.schema_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_id(&mut self) -> &mut ::std::string::String {
        &mut self.schema_id
    }

    // Take field
    pub fn take_schema_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.schema_id, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.GetIdentitiesResponse.Lock lock = 6;


    pub fn get_lock(&self) -> GetIdentitiesResponse_Lock {
        self.lock
    }
    pub fn clear_lock(&mut self) {
        self.lock = GetIdentitiesResponse_Lock::UNLOCKED;
    }

    // Param is passed by value, moved
    pub fn set_lock(&mut self, v: GetIdentitiesResponse_Lock) {
        self.lock = v;
    }
}

impl ::protobuf::Message for GetIdentitiesResponse_Identity {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.main_identifier)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.schema_id)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.lock, 6, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.main_identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.main_identifier);
        }
        if !self.schema_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.schema_id);
        }
        if self.lock != GetIdentitiesResponse_Lock::UNLOCKED {
            my_size += ::protobuf::rt::enum_size(6, self.lock);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(1, &self.identity_id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.main_identifier.is_empty() {
            os.write_string(4, &self.main_identifier)?;
        }
        if !self.schema_id.is_empty() {
            os.write_string(5, &self.schema_id)?;
        }
        if self.lock != GetIdentitiesResponse_Lock::UNLOCKED {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.lock))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentitiesResponse_Identity {
        GetIdentitiesResponse_Identity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetIdentitiesResponse_Identity| { &m.identity_id },
                |m: &mut GetIdentitiesResponse_Identity| { &mut m.identity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &GetIdentitiesResponse_Identity| { &m.created_at },
                |m: &mut GetIdentitiesResponse_Identity| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "updated_at",
                |m: &GetIdentitiesResponse_Identity| { &m.updated_at },
                |m: &mut GetIdentitiesResponse_Identity| { &mut m.updated_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "main_identifier",
                |m: &GetIdentitiesResponse_Identity| { &m.main_identifier },
                |m: &mut GetIdentitiesResponse_Identity| { &mut m.main_identifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "schema_id",
                |m: &GetIdentitiesResponse_Identity| { &m.schema_id },
                |m: &mut GetIdentitiesResponse_Identity| { &mut m.schema_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GetIdentitiesResponse_Lock>>(
                "lock",
                |m: &GetIdentitiesResponse_Identity| { &m.lock },
                |m: &mut GetIdentitiesResponse_Identity| { &mut m.lock },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentitiesResponse_Identity>(
                "GetIdentitiesResponse.Identity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentitiesResponse_Identity {
        static instance: ::protobuf::rt::LazyV2<GetIdentitiesResponse_Identity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentitiesResponse_Identity::new)
    }
}

impl ::protobuf::Clear for GetIdentitiesResponse_Identity {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.main_identifier.clear();
        self.schema_id.clear();
        self.lock = GetIdentitiesResponse_Lock::UNLOCKED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentitiesResponse_Identity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentitiesResponse_Identity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetIdentitiesResponse_Lock {
    UNLOCKED = 0,
    ADMIN_LOCKED = 1,
}

impl ::protobuf::ProtobufEnum for GetIdentitiesResponse_Lock {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetIdentitiesResponse_Lock> {
        match value {
            0 => ::std::option::Option::Some(GetIdentitiesResponse_Lock::UNLOCKED),
            1 => ::std::option::Option::Some(GetIdentitiesResponse_Lock::ADMIN_LOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetIdentitiesResponse_Lock] = &[
            GetIdentitiesResponse_Lock::UNLOCKED,
            GetIdentitiesResponse_Lock::ADMIN_LOCKED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GetIdentitiesResponse_Lock>("GetIdentitiesResponse.Lock", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GetIdentitiesResponse_Lock {
}

impl ::std::default::Default for GetIdentitiesResponse_Lock {
    fn default() -> Self {
        GetIdentitiesResponse_Lock::UNLOCKED
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentitiesResponse_Lock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentityRequest {
    // message fields
    pub identity_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentityRequest {
    fn default() -> &'a GetIdentityRequest {
        <GetIdentityRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentityRequest {
    pub fn new() -> GetIdentityRequest {
        ::std::default::Default::default()
    }

    // string identity_id = 2;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetIdentityRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identity_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(2, &self.identity_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentityRequest {
        GetIdentityRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetIdentityRequest| { &m.identity_id },
                |m: &mut GetIdentityRequest| { &mut m.identity_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentityRequest>(
                "GetIdentityRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentityRequest {
        static instance: ::protobuf::rt::LazyV2<GetIdentityRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentityRequest::new)
    }
}

impl ::protobuf::Clear for GetIdentityRequest {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentityRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentityRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentityResponse {
    // message fields
    pub identity_id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub main_identifier: ::std::string::String,
    pub traits_id: ::std::string::String,
    pub addresses_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub credentials_ids: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub schema_id: ::std::string::String,
    pub lock: GetIdentityResponse_Lock,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentityResponse {
    fn default() -> &'a GetIdentityResponse {
        <GetIdentityResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentityResponse {
    pub fn new() -> GetIdentityResponse {
        ::std::default::Default::default()
    }

    // string identity_id = 1;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 2;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated_at = 3;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string main_identifier = 4;


    pub fn get_main_identifier(&self) -> &str {
        &self.main_identifier
    }
    pub fn clear_main_identifier(&mut self) {
        self.main_identifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_main_identifier(&mut self, v: ::std::string::String) {
        self.main_identifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_identifier(&mut self) -> &mut ::std::string::String {
        &mut self.main_identifier
    }

    // Take field
    pub fn take_main_identifier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.main_identifier, ::std::string::String::new())
    }

    // string traits_id = 5;


    pub fn get_traits_id(&self) -> &str {
        &self.traits_id
    }
    pub fn clear_traits_id(&mut self) {
        self.traits_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_traits_id(&mut self, v: ::std::string::String) {
        self.traits_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traits_id(&mut self) -> &mut ::std::string::String {
        &mut self.traits_id
    }

    // Take field
    pub fn take_traits_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.traits_id, ::std::string::String::new())
    }

    // repeated string addresses_ids = 6;


    pub fn get_addresses_ids(&self) -> &[::std::string::String] {
        &self.addresses_ids
    }
    pub fn clear_addresses_ids(&mut self) {
        self.addresses_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.addresses_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.addresses_ids
    }

    // Take field
    pub fn take_addresses_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.addresses_ids, ::protobuf::RepeatedField::new())
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetIdentityResponse.CredentialsIdsEntry credentials_ids = 7;


    pub fn get_credentials_ids(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.credentials_ids
    }
    pub fn clear_credentials_ids(&mut self) {
        self.credentials_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_credentials_ids(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.credentials_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_credentials_ids(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.credentials_ids
    }

    // Take field
    pub fn take_credentials_ids(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.credentials_ids, ::std::collections::HashMap::new())
    }

    // string schema_id = 8;


    pub fn get_schema_id(&self) -> &str {
        &self.schema_id
    }
    pub fn clear_schema_id(&mut self) {
        self.schema_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_schema_id(&mut self, v: ::std::string::String) {
        self.schema_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_id(&mut self) -> &mut ::std::string::String {
        &mut self.schema_id
    }

    // Take field
    pub fn take_schema_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.schema_id, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.GetIdentityResponse.Lock lock = 9;


    pub fn get_lock(&self) -> GetIdentityResponse_Lock {
        self.lock
    }
    pub fn clear_lock(&mut self) {
        self.lock = GetIdentityResponse_Lock::UNLOCKED;
    }

    // Param is passed by value, moved
    pub fn set_lock(&mut self, v: GetIdentityResponse_Lock) {
        self.lock = v;
    }
}

impl ::protobuf::Message for GetIdentityResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.main_identifier)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.traits_id)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.addresses_ids)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.credentials_ids)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.schema_id)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.lock, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.main_identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.main_identifier);
        }
        if !self.traits_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.traits_id);
        }
        for value in &self.addresses_ids {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.credentials_ids);
        if !self.schema_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.schema_id);
        }
        if self.lock != GetIdentityResponse_Lock::UNLOCKED {
            my_size += ::protobuf::rt::enum_size(9, self.lock);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(1, &self.identity_id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.main_identifier.is_empty() {
            os.write_string(4, &self.main_identifier)?;
        }
        if !self.traits_id.is_empty() {
            os.write_string(5, &self.traits_id)?;
        }
        for v in &self.addresses_ids {
            os.write_string(6, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.credentials_ids, os)?;
        if !self.schema_id.is_empty() {
            os.write_string(8, &self.schema_id)?;
        }
        if self.lock != GetIdentityResponse_Lock::UNLOCKED {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.lock))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentityResponse {
        GetIdentityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetIdentityResponse| { &m.identity_id },
                |m: &mut GetIdentityResponse| { &mut m.identity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &GetIdentityResponse| { &m.created_at },
                |m: &mut GetIdentityResponse| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "updated_at",
                |m: &GetIdentityResponse| { &m.updated_at },
                |m: &mut GetIdentityResponse| { &mut m.updated_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "main_identifier",
                |m: &GetIdentityResponse| { &m.main_identifier },
                |m: &mut GetIdentityResponse| { &mut m.main_identifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "traits_id",
                |m: &GetIdentityResponse| { &m.traits_id },
                |m: &mut GetIdentityResponse| { &mut m.traits_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addresses_ids",
                |m: &GetIdentityResponse| { &m.addresses_ids },
                |m: &mut GetIdentityResponse| { &mut m.addresses_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "credentials_ids",
                |m: &GetIdentityResponse| { &m.credentials_ids },
                |m: &mut GetIdentityResponse| { &mut m.credentials_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "schema_id",
                |m: &GetIdentityResponse| { &m.schema_id },
                |m: &mut GetIdentityResponse| { &mut m.schema_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GetIdentityResponse_Lock>>(
                "lock",
                |m: &GetIdentityResponse| { &m.lock },
                |m: &mut GetIdentityResponse| { &mut m.lock },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentityResponse>(
                "GetIdentityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentityResponse {
        static instance: ::protobuf::rt::LazyV2<GetIdentityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentityResponse::new)
    }
}

impl ::protobuf::Clear for GetIdentityResponse {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.main_identifier.clear();
        self.traits_id.clear();
        self.addresses_ids.clear();
        self.credentials_ids.clear();
        self.schema_id.clear();
        self.lock = GetIdentityResponse_Lock::UNLOCKED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetIdentityResponse_Lock {
    UNLOCKED = 0,
    ADMIN_LOCKED = 1,
}

impl ::protobuf::ProtobufEnum for GetIdentityResponse_Lock {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetIdentityResponse_Lock> {
        match value {
            0 => ::std::option::Option::Some(GetIdentityResponse_Lock::UNLOCKED),
            1 => ::std::option::Option::Some(GetIdentityResponse_Lock::ADMIN_LOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetIdentityResponse_Lock] = &[
            GetIdentityResponse_Lock::UNLOCKED,
            GetIdentityResponse_Lock::ADMIN_LOCKED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GetIdentityResponse_Lock>("GetIdentityResponse.Lock", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GetIdentityResponse_Lock {
}

impl ::std::default::Default for GetIdentityResponse_Lock {
    fn default() -> Self {
        GetIdentityResponse_Lock::UNLOCKED
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentityResponse_Lock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentityByIdentifierRequest {
    // message fields
    pub attribute: ::std::string::String,
    pub value: ::std::string::String,
    pub connection_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentityByIdentifierRequest {
    fn default() -> &'a GetIdentityByIdentifierRequest {
        <GetIdentityByIdentifierRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentityByIdentifierRequest {
    pub fn new() -> GetIdentityByIdentifierRequest {
        ::std::default::Default::default()
    }

    // string attribute = 1;


    pub fn get_attribute(&self) -> &str {
        &self.attribute
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::std::string::String) {
        self.attribute = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute(&mut self) -> &mut ::std::string::String {
        &mut self.attribute
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.attribute, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // string connection_id = 3;


    pub fn get_connection_id(&self) -> &str {
        &self.connection_id
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: ::std::string::String) {
        self.connection_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_id(&mut self) -> &mut ::std::string::String {
        &mut self.connection_id
    }

    // Take field
    pub fn take_connection_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.connection_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetIdentityByIdentifierRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.attribute)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.connection_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.attribute);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        if !self.connection_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.connection_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.attribute.is_empty() {
            os.write_string(1, &self.attribute)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        if !self.connection_id.is_empty() {
            os.write_string(3, &self.connection_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentityByIdentifierRequest {
        GetIdentityByIdentifierRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attribute",
                |m: &GetIdentityByIdentifierRequest| { &m.attribute },
                |m: &mut GetIdentityByIdentifierRequest| { &mut m.attribute },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &GetIdentityByIdentifierRequest| { &m.value },
                |m: &mut GetIdentityByIdentifierRequest| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "connection_id",
                |m: &GetIdentityByIdentifierRequest| { &m.connection_id },
                |m: &mut GetIdentityByIdentifierRequest| { &mut m.connection_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentityByIdentifierRequest>(
                "GetIdentityByIdentifierRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentityByIdentifierRequest {
        static instance: ::protobuf::rt::LazyV2<GetIdentityByIdentifierRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentityByIdentifierRequest::new)
    }
}

impl ::protobuf::Clear for GetIdentityByIdentifierRequest {
    fn clear(&mut self) {
        self.attribute.clear();
        self.value.clear();
        self.connection_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentityByIdentifierRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentityByIdentifierRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentityByIdentifierResponse {
    // message fields
    pub identity: ::protobuf::SingularPtrField<GetIdentityByIdentifierResponse_Identity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentityByIdentifierResponse {
    fn default() -> &'a GetIdentityByIdentifierResponse {
        <GetIdentityByIdentifierResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentityByIdentifierResponse {
    pub fn new() -> GetIdentityByIdentifierResponse {
        ::std::default::Default::default()
    }

    // .depot.devtools.auth.v0.identity.admin.GetIdentityByIdentifierResponse.Identity identity = 1;


    pub fn get_identity(&self) -> &GetIdentityByIdentifierResponse_Identity {
        self.identity.as_ref().unwrap_or_else(|| <GetIdentityByIdentifierResponse_Identity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_identity(&mut self) {
        self.identity.clear();
    }

    pub fn has_identity(&self) -> bool {
        self.identity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identity(&mut self, v: GetIdentityByIdentifierResponse_Identity) {
        self.identity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity(&mut self) -> &mut GetIdentityByIdentifierResponse_Identity {
        if self.identity.is_none() {
            self.identity.set_default();
        }
        self.identity.as_mut().unwrap()
    }

    // Take field
    pub fn take_identity(&mut self) -> GetIdentityByIdentifierResponse_Identity {
        self.identity.take().unwrap_or_else(|| GetIdentityByIdentifierResponse_Identity::new())
    }
}

impl ::protobuf::Message for GetIdentityByIdentifierResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.identity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.identity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.identity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.identity.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentityByIdentifierResponse {
        GetIdentityByIdentifierResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetIdentityByIdentifierResponse_Identity>>(
                "identity",
                |m: &GetIdentityByIdentifierResponse| { &m.identity },
                |m: &mut GetIdentityByIdentifierResponse| { &mut m.identity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentityByIdentifierResponse>(
                "GetIdentityByIdentifierResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentityByIdentifierResponse {
        static instance: ::protobuf::rt::LazyV2<GetIdentityByIdentifierResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentityByIdentifierResponse::new)
    }
}

impl ::protobuf::Clear for GetIdentityByIdentifierResponse {
    fn clear(&mut self) {
        self.identity.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentityByIdentifierResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentityByIdentifierResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentityByIdentifierResponse_Identity {
    // message fields
    pub identity_id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub main_identifier: ::std::string::String,
    pub traits_id: ::std::string::String,
    pub addresses_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub credentials_ids: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub schema_id: ::std::string::String,
    pub lock: GetIdentityByIdentifierResponse_Identity_Lock,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentityByIdentifierResponse_Identity {
    fn default() -> &'a GetIdentityByIdentifierResponse_Identity {
        <GetIdentityByIdentifierResponse_Identity as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentityByIdentifierResponse_Identity {
    pub fn new() -> GetIdentityByIdentifierResponse_Identity {
        ::std::default::Default::default()
    }

    // string identity_id = 1;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 2;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated_at = 3;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string main_identifier = 4;


    pub fn get_main_identifier(&self) -> &str {
        &self.main_identifier
    }
    pub fn clear_main_identifier(&mut self) {
        self.main_identifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_main_identifier(&mut self, v: ::std::string::String) {
        self.main_identifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_identifier(&mut self) -> &mut ::std::string::String {
        &mut self.main_identifier
    }

    // Take field
    pub fn take_main_identifier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.main_identifier, ::std::string::String::new())
    }

    // string traits_id = 5;


    pub fn get_traits_id(&self) -> &str {
        &self.traits_id
    }
    pub fn clear_traits_id(&mut self) {
        self.traits_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_traits_id(&mut self, v: ::std::string::String) {
        self.traits_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traits_id(&mut self) -> &mut ::std::string::String {
        &mut self.traits_id
    }

    // Take field
    pub fn take_traits_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.traits_id, ::std::string::String::new())
    }

    // repeated string addresses_ids = 6;


    pub fn get_addresses_ids(&self) -> &[::std::string::String] {
        &self.addresses_ids
    }
    pub fn clear_addresses_ids(&mut self) {
        self.addresses_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.addresses_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.addresses_ids
    }

    // Take field
    pub fn take_addresses_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.addresses_ids, ::protobuf::RepeatedField::new())
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetIdentityByIdentifierResponse.Identity.CredentialsIdsEntry credentials_ids = 7;


    pub fn get_credentials_ids(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.credentials_ids
    }
    pub fn clear_credentials_ids(&mut self) {
        self.credentials_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_credentials_ids(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.credentials_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_credentials_ids(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.credentials_ids
    }

    // Take field
    pub fn take_credentials_ids(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.credentials_ids, ::std::collections::HashMap::new())
    }

    // string schema_id = 8;


    pub fn get_schema_id(&self) -> &str {
        &self.schema_id
    }
    pub fn clear_schema_id(&mut self) {
        self.schema_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_schema_id(&mut self, v: ::std::string::String) {
        self.schema_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_id(&mut self) -> &mut ::std::string::String {
        &mut self.schema_id
    }

    // Take field
    pub fn take_schema_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.schema_id, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.GetIdentityByIdentifierResponse.Identity.Lock lock = 9;


    pub fn get_lock(&self) -> GetIdentityByIdentifierResponse_Identity_Lock {
        self.lock
    }
    pub fn clear_lock(&mut self) {
        self.lock = GetIdentityByIdentifierResponse_Identity_Lock::UNLOCKED;
    }

    // Param is passed by value, moved
    pub fn set_lock(&mut self, v: GetIdentityByIdentifierResponse_Identity_Lock) {
        self.lock = v;
    }
}

impl ::protobuf::Message for GetIdentityByIdentifierResponse_Identity {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.main_identifier)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.traits_id)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.addresses_ids)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.credentials_ids)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.schema_id)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.lock, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.main_identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.main_identifier);
        }
        if !self.traits_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.traits_id);
        }
        for value in &self.addresses_ids {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.credentials_ids);
        if !self.schema_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.schema_id);
        }
        if self.lock != GetIdentityByIdentifierResponse_Identity_Lock::UNLOCKED {
            my_size += ::protobuf::rt::enum_size(9, self.lock);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(1, &self.identity_id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.main_identifier.is_empty() {
            os.write_string(4, &self.main_identifier)?;
        }
        if !self.traits_id.is_empty() {
            os.write_string(5, &self.traits_id)?;
        }
        for v in &self.addresses_ids {
            os.write_string(6, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.credentials_ids, os)?;
        if !self.schema_id.is_empty() {
            os.write_string(8, &self.schema_id)?;
        }
        if self.lock != GetIdentityByIdentifierResponse_Identity_Lock::UNLOCKED {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.lock))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentityByIdentifierResponse_Identity {
        GetIdentityByIdentifierResponse_Identity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetIdentityByIdentifierResponse_Identity| { &m.identity_id },
                |m: &mut GetIdentityByIdentifierResponse_Identity| { &mut m.identity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &GetIdentityByIdentifierResponse_Identity| { &m.created_at },
                |m: &mut GetIdentityByIdentifierResponse_Identity| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "updated_at",
                |m: &GetIdentityByIdentifierResponse_Identity| { &m.updated_at },
                |m: &mut GetIdentityByIdentifierResponse_Identity| { &mut m.updated_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "main_identifier",
                |m: &GetIdentityByIdentifierResponse_Identity| { &m.main_identifier },
                |m: &mut GetIdentityByIdentifierResponse_Identity| { &mut m.main_identifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "traits_id",
                |m: &GetIdentityByIdentifierResponse_Identity| { &m.traits_id },
                |m: &mut GetIdentityByIdentifierResponse_Identity| { &mut m.traits_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addresses_ids",
                |m: &GetIdentityByIdentifierResponse_Identity| { &m.addresses_ids },
                |m: &mut GetIdentityByIdentifierResponse_Identity| { &mut m.addresses_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "credentials_ids",
                |m: &GetIdentityByIdentifierResponse_Identity| { &m.credentials_ids },
                |m: &mut GetIdentityByIdentifierResponse_Identity| { &mut m.credentials_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "schema_id",
                |m: &GetIdentityByIdentifierResponse_Identity| { &m.schema_id },
                |m: &mut GetIdentityByIdentifierResponse_Identity| { &mut m.schema_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GetIdentityByIdentifierResponse_Identity_Lock>>(
                "lock",
                |m: &GetIdentityByIdentifierResponse_Identity| { &m.lock },
                |m: &mut GetIdentityByIdentifierResponse_Identity| { &mut m.lock },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentityByIdentifierResponse_Identity>(
                "GetIdentityByIdentifierResponse.Identity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentityByIdentifierResponse_Identity {
        static instance: ::protobuf::rt::LazyV2<GetIdentityByIdentifierResponse_Identity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentityByIdentifierResponse_Identity::new)
    }
}

impl ::protobuf::Clear for GetIdentityByIdentifierResponse_Identity {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.main_identifier.clear();
        self.traits_id.clear();
        self.addresses_ids.clear();
        self.credentials_ids.clear();
        self.schema_id.clear();
        self.lock = GetIdentityByIdentifierResponse_Identity_Lock::UNLOCKED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentityByIdentifierResponse_Identity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentityByIdentifierResponse_Identity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetIdentityByIdentifierResponse_Identity_Lock {
    UNLOCKED = 0,
    ADMIN_LOCKED = 1,
}

impl ::protobuf::ProtobufEnum for GetIdentityByIdentifierResponse_Identity_Lock {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetIdentityByIdentifierResponse_Identity_Lock> {
        match value {
            0 => ::std::option::Option::Some(GetIdentityByIdentifierResponse_Identity_Lock::UNLOCKED),
            1 => ::std::option::Option::Some(GetIdentityByIdentifierResponse_Identity_Lock::ADMIN_LOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetIdentityByIdentifierResponse_Identity_Lock] = &[
            GetIdentityByIdentifierResponse_Identity_Lock::UNLOCKED,
            GetIdentityByIdentifierResponse_Identity_Lock::ADMIN_LOCKED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GetIdentityByIdentifierResponse_Identity_Lock>("GetIdentityByIdentifierResponse.Identity.Lock", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GetIdentityByIdentifierResponse_Identity_Lock {
}

impl ::std::default::Default for GetIdentityByIdentifierResponse_Identity_Lock {
    fn default() -> Self {
        GetIdentityByIdentifierResponse_Identity_Lock::UNLOCKED
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentityByIdentifierResponse_Identity_Lock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentitiesByAttributeRequest {
    // message fields
    pub attribute: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentitiesByAttributeRequest {
    fn default() -> &'a GetIdentitiesByAttributeRequest {
        <GetIdentitiesByAttributeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentitiesByAttributeRequest {
    pub fn new() -> GetIdentitiesByAttributeRequest {
        ::std::default::Default::default()
    }

    // string attribute = 1;


    pub fn get_attribute(&self) -> &str {
        &self.attribute
    }
    pub fn clear_attribute(&mut self) {
        self.attribute.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute(&mut self, v: ::std::string::String) {
        self.attribute = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attribute(&mut self) -> &mut ::std::string::String {
        &mut self.attribute
    }

    // Take field
    pub fn take_attribute(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.attribute, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetIdentitiesByAttributeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.attribute)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.attribute);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.attribute.is_empty() {
            os.write_string(1, &self.attribute)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentitiesByAttributeRequest {
        GetIdentitiesByAttributeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "attribute",
                |m: &GetIdentitiesByAttributeRequest| { &m.attribute },
                |m: &mut GetIdentitiesByAttributeRequest| { &mut m.attribute },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &GetIdentitiesByAttributeRequest| { &m.value },
                |m: &mut GetIdentitiesByAttributeRequest| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentitiesByAttributeRequest>(
                "GetIdentitiesByAttributeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentitiesByAttributeRequest {
        static instance: ::protobuf::rt::LazyV2<GetIdentitiesByAttributeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentitiesByAttributeRequest::new)
    }
}

impl ::protobuf::Clear for GetIdentitiesByAttributeRequest {
    fn clear(&mut self) {
        self.attribute.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentitiesByAttributeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentitiesByAttributeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentitiesByAttributeResponse {
    // message fields
    pub identities: ::protobuf::RepeatedField<GetIdentitiesByAttributeResponse_Identity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentitiesByAttributeResponse {
    fn default() -> &'a GetIdentitiesByAttributeResponse {
        <GetIdentitiesByAttributeResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentitiesByAttributeResponse {
    pub fn new() -> GetIdentitiesByAttributeResponse {
        ::std::default::Default::default()
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetIdentitiesByAttributeResponse.Identity identities = 1;


    pub fn get_identities(&self) -> &[GetIdentitiesByAttributeResponse_Identity] {
        &self.identities
    }
    pub fn clear_identities(&mut self) {
        self.identities.clear();
    }

    // Param is passed by value, moved
    pub fn set_identities(&mut self, v: ::protobuf::RepeatedField<GetIdentitiesByAttributeResponse_Identity>) {
        self.identities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_identities(&mut self) -> &mut ::protobuf::RepeatedField<GetIdentitiesByAttributeResponse_Identity> {
        &mut self.identities
    }

    // Take field
    pub fn take_identities(&mut self) -> ::protobuf::RepeatedField<GetIdentitiesByAttributeResponse_Identity> {
        ::std::mem::replace(&mut self.identities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetIdentitiesByAttributeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.identities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.identities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.identities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.identities {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentitiesByAttributeResponse {
        GetIdentitiesByAttributeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetIdentitiesByAttributeResponse_Identity>>(
                "identities",
                |m: &GetIdentitiesByAttributeResponse| { &m.identities },
                |m: &mut GetIdentitiesByAttributeResponse| { &mut m.identities },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentitiesByAttributeResponse>(
                "GetIdentitiesByAttributeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentitiesByAttributeResponse {
        static instance: ::protobuf::rt::LazyV2<GetIdentitiesByAttributeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentitiesByAttributeResponse::new)
    }
}

impl ::protobuf::Clear for GetIdentitiesByAttributeResponse {
    fn clear(&mut self) {
        self.identities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentitiesByAttributeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentitiesByAttributeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentitiesByAttributeResponse_Identity {
    // message fields
    pub identity_id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub main_identifier: ::std::string::String,
    pub traits_id: ::std::string::String,
    pub addresses_ids: ::protobuf::RepeatedField<::std::string::String>,
    pub credentials_ids: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub schema_id: ::std::string::String,
    pub lock: GetIdentitiesByAttributeResponse_Identity_Lock,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentitiesByAttributeResponse_Identity {
    fn default() -> &'a GetIdentitiesByAttributeResponse_Identity {
        <GetIdentitiesByAttributeResponse_Identity as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentitiesByAttributeResponse_Identity {
    pub fn new() -> GetIdentitiesByAttributeResponse_Identity {
        ::std::default::Default::default()
    }

    // string identity_id = 1;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 2;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated_at = 3;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string main_identifier = 4;


    pub fn get_main_identifier(&self) -> &str {
        &self.main_identifier
    }
    pub fn clear_main_identifier(&mut self) {
        self.main_identifier.clear();
    }

    // Param is passed by value, moved
    pub fn set_main_identifier(&mut self, v: ::std::string::String) {
        self.main_identifier = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_identifier(&mut self) -> &mut ::std::string::String {
        &mut self.main_identifier
    }

    // Take field
    pub fn take_main_identifier(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.main_identifier, ::std::string::String::new())
    }

    // string traits_id = 5;


    pub fn get_traits_id(&self) -> &str {
        &self.traits_id
    }
    pub fn clear_traits_id(&mut self) {
        self.traits_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_traits_id(&mut self, v: ::std::string::String) {
        self.traits_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traits_id(&mut self) -> &mut ::std::string::String {
        &mut self.traits_id
    }

    // Take field
    pub fn take_traits_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.traits_id, ::std::string::String::new())
    }

    // repeated string addresses_ids = 6;


    pub fn get_addresses_ids(&self) -> &[::std::string::String] {
        &self.addresses_ids
    }
    pub fn clear_addresses_ids(&mut self) {
        self.addresses_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses_ids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.addresses_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses_ids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.addresses_ids
    }

    // Take field
    pub fn take_addresses_ids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.addresses_ids, ::protobuf::RepeatedField::new())
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetIdentitiesByAttributeResponse.Identity.CredentialsIdsEntry credentials_ids = 7;


    pub fn get_credentials_ids(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.credentials_ids
    }
    pub fn clear_credentials_ids(&mut self) {
        self.credentials_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_credentials_ids(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.credentials_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_credentials_ids(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.credentials_ids
    }

    // Take field
    pub fn take_credentials_ids(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.credentials_ids, ::std::collections::HashMap::new())
    }

    // string schema_id = 8;


    pub fn get_schema_id(&self) -> &str {
        &self.schema_id
    }
    pub fn clear_schema_id(&mut self) {
        self.schema_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_schema_id(&mut self, v: ::std::string::String) {
        self.schema_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema_id(&mut self) -> &mut ::std::string::String {
        &mut self.schema_id
    }

    // Take field
    pub fn take_schema_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.schema_id, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.GetIdentitiesByAttributeResponse.Identity.Lock lock = 9;


    pub fn get_lock(&self) -> GetIdentitiesByAttributeResponse_Identity_Lock {
        self.lock
    }
    pub fn clear_lock(&mut self) {
        self.lock = GetIdentitiesByAttributeResponse_Identity_Lock::UNLOCKED;
    }

    // Param is passed by value, moved
    pub fn set_lock(&mut self, v: GetIdentitiesByAttributeResponse_Identity_Lock) {
        self.lock = v;
    }
}

impl ::protobuf::Message for GetIdentitiesByAttributeResponse_Identity {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.main_identifier)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.traits_id)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.addresses_ids)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.credentials_ids)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.schema_id)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.lock, 9, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.main_identifier.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.main_identifier);
        }
        if !self.traits_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.traits_id);
        }
        for value in &self.addresses_ids {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.credentials_ids);
        if !self.schema_id.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.schema_id);
        }
        if self.lock != GetIdentitiesByAttributeResponse_Identity_Lock::UNLOCKED {
            my_size += ::protobuf::rt::enum_size(9, self.lock);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(1, &self.identity_id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.main_identifier.is_empty() {
            os.write_string(4, &self.main_identifier)?;
        }
        if !self.traits_id.is_empty() {
            os.write_string(5, &self.traits_id)?;
        }
        for v in &self.addresses_ids {
            os.write_string(6, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.credentials_ids, os)?;
        if !self.schema_id.is_empty() {
            os.write_string(8, &self.schema_id)?;
        }
        if self.lock != GetIdentitiesByAttributeResponse_Identity_Lock::UNLOCKED {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.lock))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentitiesByAttributeResponse_Identity {
        GetIdentitiesByAttributeResponse_Identity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetIdentitiesByAttributeResponse_Identity| { &m.identity_id },
                |m: &mut GetIdentitiesByAttributeResponse_Identity| { &mut m.identity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &GetIdentitiesByAttributeResponse_Identity| { &m.created_at },
                |m: &mut GetIdentitiesByAttributeResponse_Identity| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "updated_at",
                |m: &GetIdentitiesByAttributeResponse_Identity| { &m.updated_at },
                |m: &mut GetIdentitiesByAttributeResponse_Identity| { &mut m.updated_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "main_identifier",
                |m: &GetIdentitiesByAttributeResponse_Identity| { &m.main_identifier },
                |m: &mut GetIdentitiesByAttributeResponse_Identity| { &mut m.main_identifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "traits_id",
                |m: &GetIdentitiesByAttributeResponse_Identity| { &m.traits_id },
                |m: &mut GetIdentitiesByAttributeResponse_Identity| { &mut m.traits_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addresses_ids",
                |m: &GetIdentitiesByAttributeResponse_Identity| { &m.addresses_ids },
                |m: &mut GetIdentitiesByAttributeResponse_Identity| { &mut m.addresses_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "credentials_ids",
                |m: &GetIdentitiesByAttributeResponse_Identity| { &m.credentials_ids },
                |m: &mut GetIdentitiesByAttributeResponse_Identity| { &mut m.credentials_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "schema_id",
                |m: &GetIdentitiesByAttributeResponse_Identity| { &m.schema_id },
                |m: &mut GetIdentitiesByAttributeResponse_Identity| { &mut m.schema_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GetIdentitiesByAttributeResponse_Identity_Lock>>(
                "lock",
                |m: &GetIdentitiesByAttributeResponse_Identity| { &m.lock },
                |m: &mut GetIdentitiesByAttributeResponse_Identity| { &mut m.lock },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentitiesByAttributeResponse_Identity>(
                "GetIdentitiesByAttributeResponse.Identity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentitiesByAttributeResponse_Identity {
        static instance: ::protobuf::rt::LazyV2<GetIdentitiesByAttributeResponse_Identity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentitiesByAttributeResponse_Identity::new)
    }
}

impl ::protobuf::Clear for GetIdentitiesByAttributeResponse_Identity {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.main_identifier.clear();
        self.traits_id.clear();
        self.addresses_ids.clear();
        self.credentials_ids.clear();
        self.schema_id.clear();
        self.lock = GetIdentitiesByAttributeResponse_Identity_Lock::UNLOCKED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentitiesByAttributeResponse_Identity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentitiesByAttributeResponse_Identity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetIdentitiesByAttributeResponse_Identity_Lock {
    UNLOCKED = 0,
    ADMIN_LOCKED = 1,
}

impl ::protobuf::ProtobufEnum for GetIdentitiesByAttributeResponse_Identity_Lock {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetIdentitiesByAttributeResponse_Identity_Lock> {
        match value {
            0 => ::std::option::Option::Some(GetIdentitiesByAttributeResponse_Identity_Lock::UNLOCKED),
            1 => ::std::option::Option::Some(GetIdentitiesByAttributeResponse_Identity_Lock::ADMIN_LOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetIdentitiesByAttributeResponse_Identity_Lock] = &[
            GetIdentitiesByAttributeResponse_Identity_Lock::UNLOCKED,
            GetIdentitiesByAttributeResponse_Identity_Lock::ADMIN_LOCKED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GetIdentitiesByAttributeResponse_Identity_Lock>("GetIdentitiesByAttributeResponse.Identity.Lock", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GetIdentitiesByAttributeResponse_Identity_Lock {
}

impl ::std::default::Default for GetIdentitiesByAttributeResponse_Identity_Lock {
    fn default() -> Self {
        GetIdentitiesByAttributeResponse_Identity_Lock::UNLOCKED
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentitiesByAttributeResponse_Identity_Lock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateIdentityRequest {
    // message fields
    pub identity_id: ::std::string::String,
    pub lock: UpdateIdentityRequest_Lock,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateIdentityRequest {
    fn default() -> &'a UpdateIdentityRequest {
        <UpdateIdentityRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateIdentityRequest {
    pub fn new() -> UpdateIdentityRequest {
        ::std::default::Default::default()
    }

    // string identity_id = 1;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.UpdateIdentityRequest.Lock lock = 2;


    pub fn get_lock(&self) -> UpdateIdentityRequest_Lock {
        self.lock
    }
    pub fn clear_lock(&mut self) {
        self.lock = UpdateIdentityRequest_Lock::UNLOCKED;
    }

    // Param is passed by value, moved
    pub fn set_lock(&mut self, v: UpdateIdentityRequest_Lock) {
        self.lock = v;
    }
}

impl ::protobuf::Message for UpdateIdentityRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.lock, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_id);
        }
        if self.lock != UpdateIdentityRequest_Lock::UNLOCKED {
            my_size += ::protobuf::rt::enum_size(2, self.lock);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(1, &self.identity_id)?;
        }
        if self.lock != UpdateIdentityRequest_Lock::UNLOCKED {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.lock))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateIdentityRequest {
        UpdateIdentityRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &UpdateIdentityRequest| { &m.identity_id },
                |m: &mut UpdateIdentityRequest| { &mut m.identity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UpdateIdentityRequest_Lock>>(
                "lock",
                |m: &UpdateIdentityRequest| { &m.lock },
                |m: &mut UpdateIdentityRequest| { &mut m.lock },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateIdentityRequest>(
                "UpdateIdentityRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateIdentityRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateIdentityRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateIdentityRequest::new)
    }
}

impl ::protobuf::Clear for UpdateIdentityRequest {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.lock = UpdateIdentityRequest_Lock::UNLOCKED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateIdentityRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateIdentityRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UpdateIdentityRequest_Lock {
    UNLOCKED = 0,
    ADMIN_LOCKED = 1,
}

impl ::protobuf::ProtobufEnum for UpdateIdentityRequest_Lock {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UpdateIdentityRequest_Lock> {
        match value {
            0 => ::std::option::Option::Some(UpdateIdentityRequest_Lock::UNLOCKED),
            1 => ::std::option::Option::Some(UpdateIdentityRequest_Lock::ADMIN_LOCKED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UpdateIdentityRequest_Lock] = &[
            UpdateIdentityRequest_Lock::UNLOCKED,
            UpdateIdentityRequest_Lock::ADMIN_LOCKED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UpdateIdentityRequest_Lock>("UpdateIdentityRequest.Lock", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UpdateIdentityRequest_Lock {
}

impl ::std::default::Default for UpdateIdentityRequest_Lock {
    fn default() -> Self {
        UpdateIdentityRequest_Lock::UNLOCKED
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateIdentityRequest_Lock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateIdentityResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateIdentityResponse {
    fn default() -> &'a UpdateIdentityResponse {
        <UpdateIdentityResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateIdentityResponse {
    pub fn new() -> UpdateIdentityResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateIdentityResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateIdentityResponse {
        UpdateIdentityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateIdentityResponse>(
                "UpdateIdentityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateIdentityResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateIdentityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateIdentityResponse::new)
    }
}

impl ::protobuf::Clear for UpdateIdentityResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateIdentityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateIdentityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteIdentityRequest {
    // message fields
    pub identity_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteIdentityRequest {
    fn default() -> &'a DeleteIdentityRequest {
        <DeleteIdentityRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteIdentityRequest {
    pub fn new() -> DeleteIdentityRequest {
        ::std::default::Default::default()
    }

    // string identity_id = 1;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteIdentityRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(1, &self.identity_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteIdentityRequest {
        DeleteIdentityRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &DeleteIdentityRequest| { &m.identity_id },
                |m: &mut DeleteIdentityRequest| { &mut m.identity_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteIdentityRequest>(
                "DeleteIdentityRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteIdentityRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteIdentityRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteIdentityRequest::new)
    }
}

impl ::protobuf::Clear for DeleteIdentityRequest {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteIdentityRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteIdentityRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteIdentityResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteIdentityResponse {
    fn default() -> &'a DeleteIdentityResponse {
        <DeleteIdentityResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteIdentityResponse {
    pub fn new() -> DeleteIdentityResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteIdentityResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteIdentityResponse {
        DeleteIdentityResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteIdentityResponse>(
                "DeleteIdentityResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteIdentityResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteIdentityResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteIdentityResponse::new)
    }
}

impl ::protobuf::Clear for DeleteIdentityResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteIdentityResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteIdentityResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCredentialsRequest {
    // message fields
    pub identity_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCredentialsRequest {
    fn default() -> &'a GetCredentialsRequest {
        <GetCredentialsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetCredentialsRequest {
    pub fn new() -> GetCredentialsRequest {
        ::std::default::Default::default()
    }

    // string identity_id = 1;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetCredentialsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(1, &self.identity_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCredentialsRequest {
        GetCredentialsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetCredentialsRequest| { &m.identity_id },
                |m: &mut GetCredentialsRequest| { &mut m.identity_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCredentialsRequest>(
                "GetCredentialsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCredentialsRequest {
        static instance: ::protobuf::rt::LazyV2<GetCredentialsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCredentialsRequest::new)
    }
}

impl ::protobuf::Clear for GetCredentialsRequest {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCredentialsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCredentialsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCredentialsResponse {
    // message fields
    pub credentials: ::std::collections::HashMap<::std::string::String, GetCredentialsResponse_Credential>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCredentialsResponse {
    fn default() -> &'a GetCredentialsResponse {
        <GetCredentialsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetCredentialsResponse {
    pub fn new() -> GetCredentialsResponse {
        ::std::default::Default::default()
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetCredentialsResponse.CredentialsEntry credentials = 1;


    pub fn get_credentials(&self) -> &::std::collections::HashMap<::std::string::String, GetCredentialsResponse_Credential> {
        &self.credentials
    }
    pub fn clear_credentials(&mut self) {
        self.credentials.clear();
    }

    // Param is passed by value, moved
    pub fn set_credentials(&mut self, v: ::std::collections::HashMap<::std::string::String, GetCredentialsResponse_Credential>) {
        self.credentials = v;
    }

    // Mutable pointer to the field.
    pub fn mut_credentials(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, GetCredentialsResponse_Credential> {
        &mut self.credentials
    }

    // Take field
    pub fn take_credentials(&mut self) -> ::std::collections::HashMap<::std::string::String, GetCredentialsResponse_Credential> {
        ::std::mem::replace(&mut self.credentials, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for GetCredentialsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<GetCredentialsResponse_Credential>>(wire_type, is, &mut self.credentials)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<GetCredentialsResponse_Credential>>(1, &self.credentials);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<GetCredentialsResponse_Credential>>(1, &self.credentials, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCredentialsResponse {
        GetCredentialsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<GetCredentialsResponse_Credential>>(
                "credentials",
                |m: &GetCredentialsResponse| { &m.credentials },
                |m: &mut GetCredentialsResponse| { &mut m.credentials },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCredentialsResponse>(
                "GetCredentialsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCredentialsResponse {
        static instance: ::protobuf::rt::LazyV2<GetCredentialsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCredentialsResponse::new)
    }
}

impl ::protobuf::Clear for GetCredentialsResponse {
    fn clear(&mut self) {
        self.credentials.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCredentialsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCredentialsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetCredentialsResponse_Credential {
    // message fields
    pub credential_id: ::std::string::String,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub identity_id: ::std::string::String,
    pub field_type: i32,
    pub name: ::std::string::String,
    pub configured: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetCredentialsResponse_Credential {
    fn default() -> &'a GetCredentialsResponse_Credential {
        <GetCredentialsResponse_Credential as ::protobuf::Message>::default_instance()
    }
}

impl GetCredentialsResponse_Credential {
    pub fn new() -> GetCredentialsResponse_Credential {
        ::std::default::Default::default()
    }

    // string credential_id = 1;


    pub fn get_credential_id(&self) -> &str {
        &self.credential_id
    }
    pub fn clear_credential_id(&mut self) {
        self.credential_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_credential_id(&mut self, v: ::std::string::String) {
        self.credential_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_credential_id(&mut self) -> &mut ::std::string::String {
        &mut self.credential_id
    }

    // Take field
    pub fn take_credential_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.credential_id, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp created_at = 2;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated_at = 3;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string identity_id = 4;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }

    // int32 type = 5;


    pub fn get_field_type(&self) -> i32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = v;
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bool configured = 7;


    pub fn get_configured(&self) -> bool {
        self.configured
    }
    pub fn clear_configured(&mut self) {
        self.configured = false;
    }

    // Param is passed by value, moved
    pub fn set_configured(&mut self, v: bool) {
        self.configured = v;
    }
}

impl ::protobuf::Message for GetCredentialsResponse_Credential {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.credential_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.configured = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.credential_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.credential_id);
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.identity_id);
        }
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(5, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        if self.configured != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.credential_id.is_empty() {
            os.write_string(1, &self.credential_id)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.identity_id.is_empty() {
            os.write_string(4, &self.identity_id)?;
        }
        if self.field_type != 0 {
            os.write_int32(5, self.field_type)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        if self.configured != false {
            os.write_bool(7, self.configured)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetCredentialsResponse_Credential {
        GetCredentialsResponse_Credential::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "credential_id",
                |m: &GetCredentialsResponse_Credential| { &m.credential_id },
                |m: &mut GetCredentialsResponse_Credential| { &mut m.credential_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &GetCredentialsResponse_Credential| { &m.created_at },
                |m: &mut GetCredentialsResponse_Credential| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "updated_at",
                |m: &GetCredentialsResponse_Credential| { &m.updated_at },
                |m: &mut GetCredentialsResponse_Credential| { &mut m.updated_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetCredentialsResponse_Credential| { &m.identity_id },
                |m: &mut GetCredentialsResponse_Credential| { &mut m.identity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &GetCredentialsResponse_Credential| { &m.field_type },
                |m: &mut GetCredentialsResponse_Credential| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetCredentialsResponse_Credential| { &m.name },
                |m: &mut GetCredentialsResponse_Credential| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "configured",
                |m: &GetCredentialsResponse_Credential| { &m.configured },
                |m: &mut GetCredentialsResponse_Credential| { &mut m.configured },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetCredentialsResponse_Credential>(
                "GetCredentialsResponse.Credential",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetCredentialsResponse_Credential {
        static instance: ::protobuf::rt::LazyV2<GetCredentialsResponse_Credential> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetCredentialsResponse_Credential::new)
    }
}

impl ::protobuf::Clear for GetCredentialsResponse_Credential {
    fn clear(&mut self) {
        self.credential_id.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.identity_id.clear();
        self.field_type = 0;
        self.name.clear();
        self.configured = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetCredentialsResponse_Credential {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCredentialsResponse_Credential {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateCredentialRequest {
    // message fields
    pub data: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub connection_id: ::std::string::String,
    pub identity_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateCredentialRequest {
    fn default() -> &'a UpdateCredentialRequest {
        <UpdateCredentialRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateCredentialRequest {
    pub fn new() -> UpdateCredentialRequest {
        ::std::default::Default::default()
    }

    // .google.protobuf.Struct data = 1;


    pub fn get_data(&self) -> &::protobuf::well_known_types::Struct {
        self.data.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::well_known_types::Struct {
        self.data.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string connection_id = 2;


    pub fn get_connection_id(&self) -> &str {
        &self.connection_id
    }
    pub fn clear_connection_id(&mut self) {
        self.connection_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_connection_id(&mut self, v: ::std::string::String) {
        self.connection_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connection_id(&mut self) -> &mut ::std::string::String {
        &mut self.connection_id
    }

    // Take field
    pub fn take_connection_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.connection_id, ::std::string::String::new())
    }

    // string identity_id = 3;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateCredentialRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.connection_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.connection_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.connection_id);
        }
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.identity_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.connection_id.is_empty() {
            os.write_string(2, &self.connection_id)?;
        }
        if !self.identity_id.is_empty() {
            os.write_string(3, &self.identity_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateCredentialRequest {
        UpdateCredentialRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "data",
                |m: &UpdateCredentialRequest| { &m.data },
                |m: &mut UpdateCredentialRequest| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "connection_id",
                |m: &UpdateCredentialRequest| { &m.connection_id },
                |m: &mut UpdateCredentialRequest| { &mut m.connection_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &UpdateCredentialRequest| { &m.identity_id },
                |m: &mut UpdateCredentialRequest| { &mut m.identity_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateCredentialRequest>(
                "UpdateCredentialRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateCredentialRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateCredentialRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateCredentialRequest::new)
    }
}

impl ::protobuf::Clear for UpdateCredentialRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.connection_id.clear();
        self.identity_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateCredentialRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateCredentialRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateCredentialResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateCredentialResponse {
    fn default() -> &'a UpdateCredentialResponse {
        <UpdateCredentialResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateCredentialResponse {
    pub fn new() -> UpdateCredentialResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateCredentialResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateCredentialResponse {
        UpdateCredentialResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateCredentialResponse>(
                "UpdateCredentialResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateCredentialResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateCredentialResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateCredentialResponse::new)
    }
}

impl ::protobuf::Clear for UpdateCredentialResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateCredentialResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateCredentialResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateConnectionRequest {
    // message fields
    pub name: ::std::string::String,
    pub client_id: ::std::string::String,
    pub client_secret: ::std::string::String,
    pub button_image_url: ::std::string::String,
    pub provider: CreateConnectionRequest_Providers,
    pub oidc_discovery_url: ::std::string::String,
    pub mfa: ::protobuf::RepeatedField<::std::string::String>,
    pub field_type: CreateConnectionRequest_Types,
    pub scopes: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateConnectionRequest {
    fn default() -> &'a CreateConnectionRequest {
        <CreateConnectionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateConnectionRequest {
    pub fn new() -> CreateConnectionRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string client_id = 2;


    pub fn get_client_id(&self) -> &str {
        &self.client_id
    }
    pub fn clear_client_id(&mut self) {
        self.client_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: ::std::string::String) {
        self.client_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_id(&mut self) -> &mut ::std::string::String {
        &mut self.client_id
    }

    // Take field
    pub fn take_client_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_id, ::std::string::String::new())
    }

    // string client_secret = 3;


    pub fn get_client_secret(&self) -> &str {
        &self.client_secret
    }
    pub fn clear_client_secret(&mut self) {
        self.client_secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_secret(&mut self, v: ::std::string::String) {
        self.client_secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_secret(&mut self) -> &mut ::std::string::String {
        &mut self.client_secret
    }

    // Take field
    pub fn take_client_secret(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_secret, ::std::string::String::new())
    }

    // string button_image_url = 4;


    pub fn get_button_image_url(&self) -> &str {
        &self.button_image_url
    }
    pub fn clear_button_image_url(&mut self) {
        self.button_image_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_button_image_url(&mut self, v: ::std::string::String) {
        self.button_image_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_button_image_url(&mut self) -> &mut ::std::string::String {
        &mut self.button_image_url
    }

    // Take field
    pub fn take_button_image_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.button_image_url, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.CreateConnectionRequest.Providers provider = 6;


    pub fn get_provider(&self) -> CreateConnectionRequest_Providers {
        self.provider
    }
    pub fn clear_provider(&mut self) {
        self.provider = CreateConnectionRequest_Providers::NONE;
    }

    // Param is passed by value, moved
    pub fn set_provider(&mut self, v: CreateConnectionRequest_Providers) {
        self.provider = v;
    }

    // string oidc_discovery_url = 7;


    pub fn get_oidc_discovery_url(&self) -> &str {
        &self.oidc_discovery_url
    }
    pub fn clear_oidc_discovery_url(&mut self) {
        self.oidc_discovery_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_oidc_discovery_url(&mut self, v: ::std::string::String) {
        self.oidc_discovery_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oidc_discovery_url(&mut self) -> &mut ::std::string::String {
        &mut self.oidc_discovery_url
    }

    // Take field
    pub fn take_oidc_discovery_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oidc_discovery_url, ::std::string::String::new())
    }

    // repeated string mfa = 8;


    pub fn get_mfa(&self) -> &[::std::string::String] {
        &self.mfa
    }
    pub fn clear_mfa(&mut self) {
        self.mfa.clear();
    }

    // Param is passed by value, moved
    pub fn set_mfa(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mfa = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mfa(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mfa
    }

    // Take field
    pub fn take_mfa(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mfa, ::protobuf::RepeatedField::new())
    }

    // .depot.devtools.auth.v0.identity.admin.CreateConnectionRequest.Types type = 9;


    pub fn get_field_type(&self) -> CreateConnectionRequest_Types {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = CreateConnectionRequest_Types::UNSET;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: CreateConnectionRequest_Types) {
        self.field_type = v;
    }

    // string scopes = 10;


    pub fn get_scopes(&self) -> &str {
        &self.scopes
    }
    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::std::string::String) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scopes(&mut self) -> &mut ::std::string::String {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scopes, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateConnectionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_secret)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.button_image_url)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.provider, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oidc_discovery_url)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mfa)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scopes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.client_id);
        }
        if !self.client_secret.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.client_secret);
        }
        if !self.button_image_url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.button_image_url);
        }
        if self.provider != CreateConnectionRequest_Providers::NONE {
            my_size += ::protobuf::rt::enum_size(6, self.provider);
        }
        if !self.oidc_discovery_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.oidc_discovery_url);
        }
        for value in &self.mfa {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if self.field_type != CreateConnectionRequest_Types::UNSET {
            my_size += ::protobuf::rt::enum_size(9, self.field_type);
        }
        if !self.scopes.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.scopes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.client_id.is_empty() {
            os.write_string(2, &self.client_id)?;
        }
        if !self.client_secret.is_empty() {
            os.write_string(3, &self.client_secret)?;
        }
        if !self.button_image_url.is_empty() {
            os.write_string(4, &self.button_image_url)?;
        }
        if self.provider != CreateConnectionRequest_Providers::NONE {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.provider))?;
        }
        if !self.oidc_discovery_url.is_empty() {
            os.write_string(7, &self.oidc_discovery_url)?;
        }
        for v in &self.mfa {
            os.write_string(8, &v)?;
        };
        if self.field_type != CreateConnectionRequest_Types::UNSET {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.scopes.is_empty() {
            os.write_string(10, &self.scopes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateConnectionRequest {
        CreateConnectionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CreateConnectionRequest| { &m.name },
                |m: &mut CreateConnectionRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_id",
                |m: &CreateConnectionRequest| { &m.client_id },
                |m: &mut CreateConnectionRequest| { &mut m.client_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_secret",
                |m: &CreateConnectionRequest| { &m.client_secret },
                |m: &mut CreateConnectionRequest| { &mut m.client_secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "button_image_url",
                |m: &CreateConnectionRequest| { &m.button_image_url },
                |m: &mut CreateConnectionRequest| { &mut m.button_image_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CreateConnectionRequest_Providers>>(
                "provider",
                |m: &CreateConnectionRequest| { &m.provider },
                |m: &mut CreateConnectionRequest| { &mut m.provider },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "oidc_discovery_url",
                |m: &CreateConnectionRequest| { &m.oidc_discovery_url },
                |m: &mut CreateConnectionRequest| { &mut m.oidc_discovery_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mfa",
                |m: &CreateConnectionRequest| { &m.mfa },
                |m: &mut CreateConnectionRequest| { &mut m.mfa },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CreateConnectionRequest_Types>>(
                "type",
                |m: &CreateConnectionRequest| { &m.field_type },
                |m: &mut CreateConnectionRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scopes",
                |m: &CreateConnectionRequest| { &m.scopes },
                |m: &mut CreateConnectionRequest| { &mut m.scopes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateConnectionRequest>(
                "CreateConnectionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateConnectionRequest {
        static instance: ::protobuf::rt::LazyV2<CreateConnectionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateConnectionRequest::new)
    }
}

impl ::protobuf::Clear for CreateConnectionRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.client_id.clear();
        self.client_secret.clear();
        self.button_image_url.clear();
        self.provider = CreateConnectionRequest_Providers::NONE;
        self.oidc_discovery_url.clear();
        self.mfa.clear();
        self.field_type = CreateConnectionRequest_Types::UNSET;
        self.scopes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateConnectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateConnectionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CreateConnectionRequest_Providers {
    NONE = 0,
    OPENID = 1,
    AMAZON = 2,
    BITBUCKET = 3,
    BOX = 4,
    DAILYMOTION = 5,
    DEEZER = 6,
    DIGITALOCEAN = 7,
    DISCORD = 8,
    DROPBOX = 9,
    EVEONLINE = 10,
    FACEBOOK = 11,
    FITBIT = 12,
    GITEA = 13,
    GITHUB = 14,
    GITLAB = 15,
    GOOGLE = 16,
    SHOPIFY = 18,
    SOUNDCLOUD = 19,
    SPOTIFY = 20,
    STEAM = 21,
    STRIPE = 22,
    TWITCH = 23,
    UBER = 24,
    WEPAY = 25,
    YAHOO = 26,
    YAMMER = 27,
    HEROKU = 28,
    INSTAGRAM = 29,
    INTERCOM = 30,
    KAKAO = 31,
    LASTFM = 32,
    LINKEDIN = 33,
    LINE = 34,
    ONEDRIVE = 35,
    AZUREAD = 36,
    MICROSOFTONLINE = 37,
    BATTLENET = 38,
    PAYPAL = 39,
    TWITTER = 40,
    SALESFORCE = 41,
    TYPETALK = 42,
    SLACK = 43,
    MEETUP = 44,
    XERO = 46,
    VK = 47,
    NAVER = 48,
    YANDEX = 49,
    NEXTCLOUD = 50,
    APPLE = 52,
    STRAVA = 53,
}

impl ::protobuf::ProtobufEnum for CreateConnectionRequest_Providers {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CreateConnectionRequest_Providers> {
        match value {
            0 => ::std::option::Option::Some(CreateConnectionRequest_Providers::NONE),
            1 => ::std::option::Option::Some(CreateConnectionRequest_Providers::OPENID),
            2 => ::std::option::Option::Some(CreateConnectionRequest_Providers::AMAZON),
            3 => ::std::option::Option::Some(CreateConnectionRequest_Providers::BITBUCKET),
            4 => ::std::option::Option::Some(CreateConnectionRequest_Providers::BOX),
            5 => ::std::option::Option::Some(CreateConnectionRequest_Providers::DAILYMOTION),
            6 => ::std::option::Option::Some(CreateConnectionRequest_Providers::DEEZER),
            7 => ::std::option::Option::Some(CreateConnectionRequest_Providers::DIGITALOCEAN),
            8 => ::std::option::Option::Some(CreateConnectionRequest_Providers::DISCORD),
            9 => ::std::option::Option::Some(CreateConnectionRequest_Providers::DROPBOX),
            10 => ::std::option::Option::Some(CreateConnectionRequest_Providers::EVEONLINE),
            11 => ::std::option::Option::Some(CreateConnectionRequest_Providers::FACEBOOK),
            12 => ::std::option::Option::Some(CreateConnectionRequest_Providers::FITBIT),
            13 => ::std::option::Option::Some(CreateConnectionRequest_Providers::GITEA),
            14 => ::std::option::Option::Some(CreateConnectionRequest_Providers::GITHUB),
            15 => ::std::option::Option::Some(CreateConnectionRequest_Providers::GITLAB),
            16 => ::std::option::Option::Some(CreateConnectionRequest_Providers::GOOGLE),
            18 => ::std::option::Option::Some(CreateConnectionRequest_Providers::SHOPIFY),
            19 => ::std::option::Option::Some(CreateConnectionRequest_Providers::SOUNDCLOUD),
            20 => ::std::option::Option::Some(CreateConnectionRequest_Providers::SPOTIFY),
            21 => ::std::option::Option::Some(CreateConnectionRequest_Providers::STEAM),
            22 => ::std::option::Option::Some(CreateConnectionRequest_Providers::STRIPE),
            23 => ::std::option::Option::Some(CreateConnectionRequest_Providers::TWITCH),
            24 => ::std::option::Option::Some(CreateConnectionRequest_Providers::UBER),
            25 => ::std::option::Option::Some(CreateConnectionRequest_Providers::WEPAY),
            26 => ::std::option::Option::Some(CreateConnectionRequest_Providers::YAHOO),
            27 => ::std::option::Option::Some(CreateConnectionRequest_Providers::YAMMER),
            28 => ::std::option::Option::Some(CreateConnectionRequest_Providers::HEROKU),
            29 => ::std::option::Option::Some(CreateConnectionRequest_Providers::INSTAGRAM),
            30 => ::std::option::Option::Some(CreateConnectionRequest_Providers::INTERCOM),
            31 => ::std::option::Option::Some(CreateConnectionRequest_Providers::KAKAO),
            32 => ::std::option::Option::Some(CreateConnectionRequest_Providers::LASTFM),
            33 => ::std::option::Option::Some(CreateConnectionRequest_Providers::LINKEDIN),
            34 => ::std::option::Option::Some(CreateConnectionRequest_Providers::LINE),
            35 => ::std::option::Option::Some(CreateConnectionRequest_Providers::ONEDRIVE),
            36 => ::std::option::Option::Some(CreateConnectionRequest_Providers::AZUREAD),
            37 => ::std::option::Option::Some(CreateConnectionRequest_Providers::MICROSOFTONLINE),
            38 => ::std::option::Option::Some(CreateConnectionRequest_Providers::BATTLENET),
            39 => ::std::option::Option::Some(CreateConnectionRequest_Providers::PAYPAL),
            40 => ::std::option::Option::Some(CreateConnectionRequest_Providers::TWITTER),
            41 => ::std::option::Option::Some(CreateConnectionRequest_Providers::SALESFORCE),
            42 => ::std::option::Option::Some(CreateConnectionRequest_Providers::TYPETALK),
            43 => ::std::option::Option::Some(CreateConnectionRequest_Providers::SLACK),
            44 => ::std::option::Option::Some(CreateConnectionRequest_Providers::MEETUP),
            46 => ::std::option::Option::Some(CreateConnectionRequest_Providers::XERO),
            47 => ::std::option::Option::Some(CreateConnectionRequest_Providers::VK),
            48 => ::std::option::Option::Some(CreateConnectionRequest_Providers::NAVER),
            49 => ::std::option::Option::Some(CreateConnectionRequest_Providers::YANDEX),
            50 => ::std::option::Option::Some(CreateConnectionRequest_Providers::NEXTCLOUD),
            52 => ::std::option::Option::Some(CreateConnectionRequest_Providers::APPLE),
            53 => ::std::option::Option::Some(CreateConnectionRequest_Providers::STRAVA),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CreateConnectionRequest_Providers] = &[
            CreateConnectionRequest_Providers::NONE,
            CreateConnectionRequest_Providers::OPENID,
            CreateConnectionRequest_Providers::AMAZON,
            CreateConnectionRequest_Providers::BITBUCKET,
            CreateConnectionRequest_Providers::BOX,
            CreateConnectionRequest_Providers::DAILYMOTION,
            CreateConnectionRequest_Providers::DEEZER,
            CreateConnectionRequest_Providers::DIGITALOCEAN,
            CreateConnectionRequest_Providers::DISCORD,
            CreateConnectionRequest_Providers::DROPBOX,
            CreateConnectionRequest_Providers::EVEONLINE,
            CreateConnectionRequest_Providers::FACEBOOK,
            CreateConnectionRequest_Providers::FITBIT,
            CreateConnectionRequest_Providers::GITEA,
            CreateConnectionRequest_Providers::GITHUB,
            CreateConnectionRequest_Providers::GITLAB,
            CreateConnectionRequest_Providers::GOOGLE,
            CreateConnectionRequest_Providers::SHOPIFY,
            CreateConnectionRequest_Providers::SOUNDCLOUD,
            CreateConnectionRequest_Providers::SPOTIFY,
            CreateConnectionRequest_Providers::STEAM,
            CreateConnectionRequest_Providers::STRIPE,
            CreateConnectionRequest_Providers::TWITCH,
            CreateConnectionRequest_Providers::UBER,
            CreateConnectionRequest_Providers::WEPAY,
            CreateConnectionRequest_Providers::YAHOO,
            CreateConnectionRequest_Providers::YAMMER,
            CreateConnectionRequest_Providers::HEROKU,
            CreateConnectionRequest_Providers::INSTAGRAM,
            CreateConnectionRequest_Providers::INTERCOM,
            CreateConnectionRequest_Providers::KAKAO,
            CreateConnectionRequest_Providers::LASTFM,
            CreateConnectionRequest_Providers::LINKEDIN,
            CreateConnectionRequest_Providers::LINE,
            CreateConnectionRequest_Providers::ONEDRIVE,
            CreateConnectionRequest_Providers::AZUREAD,
            CreateConnectionRequest_Providers::MICROSOFTONLINE,
            CreateConnectionRequest_Providers::BATTLENET,
            CreateConnectionRequest_Providers::PAYPAL,
            CreateConnectionRequest_Providers::TWITTER,
            CreateConnectionRequest_Providers::SALESFORCE,
            CreateConnectionRequest_Providers::TYPETALK,
            CreateConnectionRequest_Providers::SLACK,
            CreateConnectionRequest_Providers::MEETUP,
            CreateConnectionRequest_Providers::XERO,
            CreateConnectionRequest_Providers::VK,
            CreateConnectionRequest_Providers::NAVER,
            CreateConnectionRequest_Providers::YANDEX,
            CreateConnectionRequest_Providers::NEXTCLOUD,
            CreateConnectionRequest_Providers::APPLE,
            CreateConnectionRequest_Providers::STRAVA,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CreateConnectionRequest_Providers>("CreateConnectionRequest.Providers", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CreateConnectionRequest_Providers {
}

impl ::std::default::Default for CreateConnectionRequest_Providers {
    fn default() -> Self {
        CreateConnectionRequest_Providers::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateConnectionRequest_Providers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CreateConnectionRequest_Types {
    UNSET = 0,
    PASSWORD = 1,
    OTP = 2,
    TOTP = 3,
    OIDC = 4,
}

impl ::protobuf::ProtobufEnum for CreateConnectionRequest_Types {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CreateConnectionRequest_Types> {
        match value {
            0 => ::std::option::Option::Some(CreateConnectionRequest_Types::UNSET),
            1 => ::std::option::Option::Some(CreateConnectionRequest_Types::PASSWORD),
            2 => ::std::option::Option::Some(CreateConnectionRequest_Types::OTP),
            3 => ::std::option::Option::Some(CreateConnectionRequest_Types::TOTP),
            4 => ::std::option::Option::Some(CreateConnectionRequest_Types::OIDC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CreateConnectionRequest_Types] = &[
            CreateConnectionRequest_Types::UNSET,
            CreateConnectionRequest_Types::PASSWORD,
            CreateConnectionRequest_Types::OTP,
            CreateConnectionRequest_Types::TOTP,
            CreateConnectionRequest_Types::OIDC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CreateConnectionRequest_Types>("CreateConnectionRequest.Types", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CreateConnectionRequest_Types {
}

impl ::std::default::Default for CreateConnectionRequest_Types {
    fn default() -> Self {
        CreateConnectionRequest_Types::UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateConnectionRequest_Types {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateConnectionResponse {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateConnectionResponse {
    fn default() -> &'a CreateConnectionResponse {
        <CreateConnectionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateConnectionResponse {
    pub fn new() -> CreateConnectionResponse {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateConnectionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateConnectionResponse {
        CreateConnectionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CreateConnectionResponse| { &m.name },
                |m: &mut CreateConnectionResponse| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateConnectionResponse>(
                "CreateConnectionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateConnectionResponse {
        static instance: ::protobuf::rt::LazyV2<CreateConnectionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateConnectionResponse::new)
    }
}

impl ::protobuf::Clear for CreateConnectionResponse {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateConnectionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateConnectionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConnectionsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConnectionsRequest {
    fn default() -> &'a GetConnectionsRequest {
        <GetConnectionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConnectionsRequest {
    pub fn new() -> GetConnectionsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetConnectionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConnectionsRequest {
        GetConnectionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConnectionsRequest>(
                "GetConnectionsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConnectionsRequest {
        static instance: ::protobuf::rt::LazyV2<GetConnectionsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConnectionsRequest::new)
    }
}

impl ::protobuf::Clear for GetConnectionsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConnectionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConnectionsResponse {
    // message fields
    pub connections: ::protobuf::RepeatedField<GetConnectionsResponse_Connection>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConnectionsResponse {
    fn default() -> &'a GetConnectionsResponse {
        <GetConnectionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetConnectionsResponse {
    pub fn new() -> GetConnectionsResponse {
        ::std::default::Default::default()
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetConnectionsResponse.Connection connections = 1;


    pub fn get_connections(&self) -> &[GetConnectionsResponse_Connection] {
        &self.connections
    }
    pub fn clear_connections(&mut self) {
        self.connections.clear();
    }

    // Param is passed by value, moved
    pub fn set_connections(&mut self, v: ::protobuf::RepeatedField<GetConnectionsResponse_Connection>) {
        self.connections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_connections(&mut self) -> &mut ::protobuf::RepeatedField<GetConnectionsResponse_Connection> {
        &mut self.connections
    }

    // Take field
    pub fn take_connections(&mut self) -> ::protobuf::RepeatedField<GetConnectionsResponse_Connection> {
        ::std::mem::replace(&mut self.connections, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetConnectionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.connections {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.connections)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.connections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.connections {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConnectionsResponse {
        GetConnectionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetConnectionsResponse_Connection>>(
                "connections",
                |m: &GetConnectionsResponse| { &m.connections },
                |m: &mut GetConnectionsResponse| { &mut m.connections },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConnectionsResponse>(
                "GetConnectionsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConnectionsResponse {
        static instance: ::protobuf::rt::LazyV2<GetConnectionsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConnectionsResponse::new)
    }
}

impl ::protobuf::Clear for GetConnectionsResponse {
    fn clear(&mut self) {
        self.connections.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConnectionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConnectionsResponse_Connection {
    // message fields
    pub name: ::std::string::String,
    pub client_id: ::std::string::String,
    pub client_secret: ::std::string::String,
    pub button_image_url: ::std::string::String,
    pub provider: GetConnectionsResponse_Providers,
    pub oidc_discovery_url: ::std::string::String,
    pub mfa: ::protobuf::RepeatedField<::std::string::String>,
    pub field_type: GetConnectionsResponse_Types,
    pub id: ::std::string::String,
    pub scopes: ::std::string::String,
    pub purpose: GetConnectionsResponse_Purposes,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConnectionsResponse_Connection {
    fn default() -> &'a GetConnectionsResponse_Connection {
        <GetConnectionsResponse_Connection as ::protobuf::Message>::default_instance()
    }
}

impl GetConnectionsResponse_Connection {
    pub fn new() -> GetConnectionsResponse_Connection {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string client_id = 2;


    pub fn get_client_id(&self) -> &str {
        &self.client_id
    }
    pub fn clear_client_id(&mut self) {
        self.client_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: ::std::string::String) {
        self.client_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_id(&mut self) -> &mut ::std::string::String {
        &mut self.client_id
    }

    // Take field
    pub fn take_client_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_id, ::std::string::String::new())
    }

    // string client_secret = 3;


    pub fn get_client_secret(&self) -> &str {
        &self.client_secret
    }
    pub fn clear_client_secret(&mut self) {
        self.client_secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_secret(&mut self, v: ::std::string::String) {
        self.client_secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_secret(&mut self) -> &mut ::std::string::String {
        &mut self.client_secret
    }

    // Take field
    pub fn take_client_secret(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_secret, ::std::string::String::new())
    }

    // string button_image_url = 4;


    pub fn get_button_image_url(&self) -> &str {
        &self.button_image_url
    }
    pub fn clear_button_image_url(&mut self) {
        self.button_image_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_button_image_url(&mut self, v: ::std::string::String) {
        self.button_image_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_button_image_url(&mut self) -> &mut ::std::string::String {
        &mut self.button_image_url
    }

    // Take field
    pub fn take_button_image_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.button_image_url, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.GetConnectionsResponse.Providers provider = 6;


    pub fn get_provider(&self) -> GetConnectionsResponse_Providers {
        self.provider
    }
    pub fn clear_provider(&mut self) {
        self.provider = GetConnectionsResponse_Providers::NONE;
    }

    // Param is passed by value, moved
    pub fn set_provider(&mut self, v: GetConnectionsResponse_Providers) {
        self.provider = v;
    }

    // string oidc_discovery_url = 7;


    pub fn get_oidc_discovery_url(&self) -> &str {
        &self.oidc_discovery_url
    }
    pub fn clear_oidc_discovery_url(&mut self) {
        self.oidc_discovery_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_oidc_discovery_url(&mut self, v: ::std::string::String) {
        self.oidc_discovery_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oidc_discovery_url(&mut self) -> &mut ::std::string::String {
        &mut self.oidc_discovery_url
    }

    // Take field
    pub fn take_oidc_discovery_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oidc_discovery_url, ::std::string::String::new())
    }

    // repeated string mfa = 8;


    pub fn get_mfa(&self) -> &[::std::string::String] {
        &self.mfa
    }
    pub fn clear_mfa(&mut self) {
        self.mfa.clear();
    }

    // Param is passed by value, moved
    pub fn set_mfa(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mfa = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mfa(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mfa
    }

    // Take field
    pub fn take_mfa(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mfa, ::protobuf::RepeatedField::new())
    }

    // .depot.devtools.auth.v0.identity.admin.GetConnectionsResponse.Types type = 9;


    pub fn get_field_type(&self) -> GetConnectionsResponse_Types {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = GetConnectionsResponse_Types::UNSET;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: GetConnectionsResponse_Types) {
        self.field_type = v;
    }

    // string id = 10;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string scopes = 11;


    pub fn get_scopes(&self) -> &str {
        &self.scopes
    }
    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::std::string::String) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scopes(&mut self) -> &mut ::std::string::String {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scopes, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.GetConnectionsResponse.Purposes purpose = 12;


    pub fn get_purpose(&self) -> GetConnectionsResponse_Purposes {
        self.purpose
    }
    pub fn clear_purpose(&mut self) {
        self.purpose = GetConnectionsResponse_Purposes::PURPOSE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_purpose(&mut self, v: GetConnectionsResponse_Purposes) {
        self.purpose = v;
    }
}

impl ::protobuf::Message for GetConnectionsResponse_Connection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_secret)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.button_image_url)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.provider, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oidc_discovery_url)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mfa)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scopes)?;
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.purpose, 12, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.client_id);
        }
        if !self.client_secret.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.client_secret);
        }
        if !self.button_image_url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.button_image_url);
        }
        if self.provider != GetConnectionsResponse_Providers::NONE {
            my_size += ::protobuf::rt::enum_size(6, self.provider);
        }
        if !self.oidc_discovery_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.oidc_discovery_url);
        }
        for value in &self.mfa {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if self.field_type != GetConnectionsResponse_Types::UNSET {
            my_size += ::protobuf::rt::enum_size(9, self.field_type);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.id);
        }
        if !self.scopes.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.scopes);
        }
        if self.purpose != GetConnectionsResponse_Purposes::PURPOSE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(12, self.purpose);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.client_id.is_empty() {
            os.write_string(2, &self.client_id)?;
        }
        if !self.client_secret.is_empty() {
            os.write_string(3, &self.client_secret)?;
        }
        if !self.button_image_url.is_empty() {
            os.write_string(4, &self.button_image_url)?;
        }
        if self.provider != GetConnectionsResponse_Providers::NONE {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.provider))?;
        }
        if !self.oidc_discovery_url.is_empty() {
            os.write_string(7, &self.oidc_discovery_url)?;
        }
        for v in &self.mfa {
            os.write_string(8, &v)?;
        };
        if self.field_type != GetConnectionsResponse_Types::UNSET {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.id.is_empty() {
            os.write_string(10, &self.id)?;
        }
        if !self.scopes.is_empty() {
            os.write_string(11, &self.scopes)?;
        }
        if self.purpose != GetConnectionsResponse_Purposes::PURPOSE_UNKNOWN {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&self.purpose))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConnectionsResponse_Connection {
        GetConnectionsResponse_Connection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetConnectionsResponse_Connection| { &m.name },
                |m: &mut GetConnectionsResponse_Connection| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_id",
                |m: &GetConnectionsResponse_Connection| { &m.client_id },
                |m: &mut GetConnectionsResponse_Connection| { &mut m.client_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_secret",
                |m: &GetConnectionsResponse_Connection| { &m.client_secret },
                |m: &mut GetConnectionsResponse_Connection| { &mut m.client_secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "button_image_url",
                |m: &GetConnectionsResponse_Connection| { &m.button_image_url },
                |m: &mut GetConnectionsResponse_Connection| { &mut m.button_image_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GetConnectionsResponse_Providers>>(
                "provider",
                |m: &GetConnectionsResponse_Connection| { &m.provider },
                |m: &mut GetConnectionsResponse_Connection| { &mut m.provider },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "oidc_discovery_url",
                |m: &GetConnectionsResponse_Connection| { &m.oidc_discovery_url },
                |m: &mut GetConnectionsResponse_Connection| { &mut m.oidc_discovery_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mfa",
                |m: &GetConnectionsResponse_Connection| { &m.mfa },
                |m: &mut GetConnectionsResponse_Connection| { &mut m.mfa },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GetConnectionsResponse_Types>>(
                "type",
                |m: &GetConnectionsResponse_Connection| { &m.field_type },
                |m: &mut GetConnectionsResponse_Connection| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetConnectionsResponse_Connection| { &m.id },
                |m: &mut GetConnectionsResponse_Connection| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scopes",
                |m: &GetConnectionsResponse_Connection| { &m.scopes },
                |m: &mut GetConnectionsResponse_Connection| { &mut m.scopes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GetConnectionsResponse_Purposes>>(
                "purpose",
                |m: &GetConnectionsResponse_Connection| { &m.purpose },
                |m: &mut GetConnectionsResponse_Connection| { &mut m.purpose },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetConnectionsResponse_Connection>(
                "GetConnectionsResponse.Connection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetConnectionsResponse_Connection {
        static instance: ::protobuf::rt::LazyV2<GetConnectionsResponse_Connection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetConnectionsResponse_Connection::new)
    }
}

impl ::protobuf::Clear for GetConnectionsResponse_Connection {
    fn clear(&mut self) {
        self.name.clear();
        self.client_id.clear();
        self.client_secret.clear();
        self.button_image_url.clear();
        self.provider = GetConnectionsResponse_Providers::NONE;
        self.oidc_discovery_url.clear();
        self.mfa.clear();
        self.field_type = GetConnectionsResponse_Types::UNSET;
        self.id.clear();
        self.scopes.clear();
        self.purpose = GetConnectionsResponse_Purposes::PURPOSE_UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConnectionsResponse_Connection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectionsResponse_Connection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetConnectionsResponse_Providers {
    NONE = 0,
    OPENID = 1,
    AMAZON = 2,
    BITBUCKET = 3,
    BOX = 4,
    DAILYMOTION = 5,
    DEEZER = 6,
    DIGITALOCEAN = 7,
    DISCORD = 8,
    DROPBOX = 9,
    EVEONLINE = 10,
    FACEBOOK = 11,
    FITBIT = 12,
    GITEA = 13,
    GITHUB = 14,
    GITLAB = 15,
    GOOGLE = 16,
    SHOPIFY = 18,
    SOUNDCLOUD = 19,
    SPOTIFY = 20,
    STEAM = 21,
    STRIPE = 22,
    TWITCH = 23,
    UBER = 24,
    WEPAY = 25,
    YAHOO = 26,
    YAMMER = 27,
    HEROKU = 28,
    INSTAGRAM = 29,
    INTERCOM = 30,
    KAKAO = 31,
    LASTFM = 32,
    LINKEDIN = 33,
    LINE = 34,
    ONEDRIVE = 35,
    AZUREAD = 36,
    MICROSOFTONLINE = 37,
    BATTLENET = 38,
    PAYPAL = 39,
    TWITTER = 40,
    SALESFORCE = 41,
    TYPETALK = 42,
    SLACK = 43,
    MEETUP = 44,
    XERO = 46,
    VK = 47,
    NAVER = 48,
    YANDEX = 49,
    NEXTCLOUD = 50,
    APPLE = 52,
    STRAVA = 53,
}

impl ::protobuf::ProtobufEnum for GetConnectionsResponse_Providers {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetConnectionsResponse_Providers> {
        match value {
            0 => ::std::option::Option::Some(GetConnectionsResponse_Providers::NONE),
            1 => ::std::option::Option::Some(GetConnectionsResponse_Providers::OPENID),
            2 => ::std::option::Option::Some(GetConnectionsResponse_Providers::AMAZON),
            3 => ::std::option::Option::Some(GetConnectionsResponse_Providers::BITBUCKET),
            4 => ::std::option::Option::Some(GetConnectionsResponse_Providers::BOX),
            5 => ::std::option::Option::Some(GetConnectionsResponse_Providers::DAILYMOTION),
            6 => ::std::option::Option::Some(GetConnectionsResponse_Providers::DEEZER),
            7 => ::std::option::Option::Some(GetConnectionsResponse_Providers::DIGITALOCEAN),
            8 => ::std::option::Option::Some(GetConnectionsResponse_Providers::DISCORD),
            9 => ::std::option::Option::Some(GetConnectionsResponse_Providers::DROPBOX),
            10 => ::std::option::Option::Some(GetConnectionsResponse_Providers::EVEONLINE),
            11 => ::std::option::Option::Some(GetConnectionsResponse_Providers::FACEBOOK),
            12 => ::std::option::Option::Some(GetConnectionsResponse_Providers::FITBIT),
            13 => ::std::option::Option::Some(GetConnectionsResponse_Providers::GITEA),
            14 => ::std::option::Option::Some(GetConnectionsResponse_Providers::GITHUB),
            15 => ::std::option::Option::Some(GetConnectionsResponse_Providers::GITLAB),
            16 => ::std::option::Option::Some(GetConnectionsResponse_Providers::GOOGLE),
            18 => ::std::option::Option::Some(GetConnectionsResponse_Providers::SHOPIFY),
            19 => ::std::option::Option::Some(GetConnectionsResponse_Providers::SOUNDCLOUD),
            20 => ::std::option::Option::Some(GetConnectionsResponse_Providers::SPOTIFY),
            21 => ::std::option::Option::Some(GetConnectionsResponse_Providers::STEAM),
            22 => ::std::option::Option::Some(GetConnectionsResponse_Providers::STRIPE),
            23 => ::std::option::Option::Some(GetConnectionsResponse_Providers::TWITCH),
            24 => ::std::option::Option::Some(GetConnectionsResponse_Providers::UBER),
            25 => ::std::option::Option::Some(GetConnectionsResponse_Providers::WEPAY),
            26 => ::std::option::Option::Some(GetConnectionsResponse_Providers::YAHOO),
            27 => ::std::option::Option::Some(GetConnectionsResponse_Providers::YAMMER),
            28 => ::std::option::Option::Some(GetConnectionsResponse_Providers::HEROKU),
            29 => ::std::option::Option::Some(GetConnectionsResponse_Providers::INSTAGRAM),
            30 => ::std::option::Option::Some(GetConnectionsResponse_Providers::INTERCOM),
            31 => ::std::option::Option::Some(GetConnectionsResponse_Providers::KAKAO),
            32 => ::std::option::Option::Some(GetConnectionsResponse_Providers::LASTFM),
            33 => ::std::option::Option::Some(GetConnectionsResponse_Providers::LINKEDIN),
            34 => ::std::option::Option::Some(GetConnectionsResponse_Providers::LINE),
            35 => ::std::option::Option::Some(GetConnectionsResponse_Providers::ONEDRIVE),
            36 => ::std::option::Option::Some(GetConnectionsResponse_Providers::AZUREAD),
            37 => ::std::option::Option::Some(GetConnectionsResponse_Providers::MICROSOFTONLINE),
            38 => ::std::option::Option::Some(GetConnectionsResponse_Providers::BATTLENET),
            39 => ::std::option::Option::Some(GetConnectionsResponse_Providers::PAYPAL),
            40 => ::std::option::Option::Some(GetConnectionsResponse_Providers::TWITTER),
            41 => ::std::option::Option::Some(GetConnectionsResponse_Providers::SALESFORCE),
            42 => ::std::option::Option::Some(GetConnectionsResponse_Providers::TYPETALK),
            43 => ::std::option::Option::Some(GetConnectionsResponse_Providers::SLACK),
            44 => ::std::option::Option::Some(GetConnectionsResponse_Providers::MEETUP),
            46 => ::std::option::Option::Some(GetConnectionsResponse_Providers::XERO),
            47 => ::std::option::Option::Some(GetConnectionsResponse_Providers::VK),
            48 => ::std::option::Option::Some(GetConnectionsResponse_Providers::NAVER),
            49 => ::std::option::Option::Some(GetConnectionsResponse_Providers::YANDEX),
            50 => ::std::option::Option::Some(GetConnectionsResponse_Providers::NEXTCLOUD),
            52 => ::std::option::Option::Some(GetConnectionsResponse_Providers::APPLE),
            53 => ::std::option::Option::Some(GetConnectionsResponse_Providers::STRAVA),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetConnectionsResponse_Providers] = &[
            GetConnectionsResponse_Providers::NONE,
            GetConnectionsResponse_Providers::OPENID,
            GetConnectionsResponse_Providers::AMAZON,
            GetConnectionsResponse_Providers::BITBUCKET,
            GetConnectionsResponse_Providers::BOX,
            GetConnectionsResponse_Providers::DAILYMOTION,
            GetConnectionsResponse_Providers::DEEZER,
            GetConnectionsResponse_Providers::DIGITALOCEAN,
            GetConnectionsResponse_Providers::DISCORD,
            GetConnectionsResponse_Providers::DROPBOX,
            GetConnectionsResponse_Providers::EVEONLINE,
            GetConnectionsResponse_Providers::FACEBOOK,
            GetConnectionsResponse_Providers::FITBIT,
            GetConnectionsResponse_Providers::GITEA,
            GetConnectionsResponse_Providers::GITHUB,
            GetConnectionsResponse_Providers::GITLAB,
            GetConnectionsResponse_Providers::GOOGLE,
            GetConnectionsResponse_Providers::SHOPIFY,
            GetConnectionsResponse_Providers::SOUNDCLOUD,
            GetConnectionsResponse_Providers::SPOTIFY,
            GetConnectionsResponse_Providers::STEAM,
            GetConnectionsResponse_Providers::STRIPE,
            GetConnectionsResponse_Providers::TWITCH,
            GetConnectionsResponse_Providers::UBER,
            GetConnectionsResponse_Providers::WEPAY,
            GetConnectionsResponse_Providers::YAHOO,
            GetConnectionsResponse_Providers::YAMMER,
            GetConnectionsResponse_Providers::HEROKU,
            GetConnectionsResponse_Providers::INSTAGRAM,
            GetConnectionsResponse_Providers::INTERCOM,
            GetConnectionsResponse_Providers::KAKAO,
            GetConnectionsResponse_Providers::LASTFM,
            GetConnectionsResponse_Providers::LINKEDIN,
            GetConnectionsResponse_Providers::LINE,
            GetConnectionsResponse_Providers::ONEDRIVE,
            GetConnectionsResponse_Providers::AZUREAD,
            GetConnectionsResponse_Providers::MICROSOFTONLINE,
            GetConnectionsResponse_Providers::BATTLENET,
            GetConnectionsResponse_Providers::PAYPAL,
            GetConnectionsResponse_Providers::TWITTER,
            GetConnectionsResponse_Providers::SALESFORCE,
            GetConnectionsResponse_Providers::TYPETALK,
            GetConnectionsResponse_Providers::SLACK,
            GetConnectionsResponse_Providers::MEETUP,
            GetConnectionsResponse_Providers::XERO,
            GetConnectionsResponse_Providers::VK,
            GetConnectionsResponse_Providers::NAVER,
            GetConnectionsResponse_Providers::YANDEX,
            GetConnectionsResponse_Providers::NEXTCLOUD,
            GetConnectionsResponse_Providers::APPLE,
            GetConnectionsResponse_Providers::STRAVA,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GetConnectionsResponse_Providers>("GetConnectionsResponse.Providers", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GetConnectionsResponse_Providers {
}

impl ::std::default::Default for GetConnectionsResponse_Providers {
    fn default() -> Self {
        GetConnectionsResponse_Providers::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectionsResponse_Providers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetConnectionsResponse_Types {
    UNSET = 0,
    PASSWORD = 1,
    OTP = 2,
    TOTP = 3,
    OIDC = 4,
}

impl ::protobuf::ProtobufEnum for GetConnectionsResponse_Types {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetConnectionsResponse_Types> {
        match value {
            0 => ::std::option::Option::Some(GetConnectionsResponse_Types::UNSET),
            1 => ::std::option::Option::Some(GetConnectionsResponse_Types::PASSWORD),
            2 => ::std::option::Option::Some(GetConnectionsResponse_Types::OTP),
            3 => ::std::option::Option::Some(GetConnectionsResponse_Types::TOTP),
            4 => ::std::option::Option::Some(GetConnectionsResponse_Types::OIDC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetConnectionsResponse_Types] = &[
            GetConnectionsResponse_Types::UNSET,
            GetConnectionsResponse_Types::PASSWORD,
            GetConnectionsResponse_Types::OTP,
            GetConnectionsResponse_Types::TOTP,
            GetConnectionsResponse_Types::OIDC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GetConnectionsResponse_Types>("GetConnectionsResponse.Types", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GetConnectionsResponse_Types {
}

impl ::std::default::Default for GetConnectionsResponse_Types {
    fn default() -> Self {
        GetConnectionsResponse_Types::UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectionsResponse_Types {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GetConnectionsResponse_Purposes {
    PURPOSE_UNKNOWN = 0,
    PURPOSE_MAIN_FACTOR = 1,
    PURPOSE_SECOND_FACTOR = 2,
}

impl ::protobuf::ProtobufEnum for GetConnectionsResponse_Purposes {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GetConnectionsResponse_Purposes> {
        match value {
            0 => ::std::option::Option::Some(GetConnectionsResponse_Purposes::PURPOSE_UNKNOWN),
            1 => ::std::option::Option::Some(GetConnectionsResponse_Purposes::PURPOSE_MAIN_FACTOR),
            2 => ::std::option::Option::Some(GetConnectionsResponse_Purposes::PURPOSE_SECOND_FACTOR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GetConnectionsResponse_Purposes] = &[
            GetConnectionsResponse_Purposes::PURPOSE_UNKNOWN,
            GetConnectionsResponse_Purposes::PURPOSE_MAIN_FACTOR,
            GetConnectionsResponse_Purposes::PURPOSE_SECOND_FACTOR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GetConnectionsResponse_Purposes>("GetConnectionsResponse.Purposes", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GetConnectionsResponse_Purposes {
}

impl ::std::default::Default for GetConnectionsResponse_Purposes {
    fn default() -> Self {
        GetConnectionsResponse_Purposes::PURPOSE_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectionsResponse_Purposes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateConnectionRequest {
    // message fields
    pub client_id: ::std::string::String,
    pub client_secret: ::std::string::String,
    pub button_image_url: ::std::string::String,
    pub provider: UpdateConnectionRequest_Providers,
    pub oidc_discovery_url: ::std::string::String,
    pub mfa: ::protobuf::RepeatedField<::std::string::String>,
    pub field_type: UpdateConnectionRequest_Types,
    pub id: ::std::string::String,
    pub scopes: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateConnectionRequest {
    fn default() -> &'a UpdateConnectionRequest {
        <UpdateConnectionRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateConnectionRequest {
    pub fn new() -> UpdateConnectionRequest {
        ::std::default::Default::default()
    }

    // string client_id = 2;


    pub fn get_client_id(&self) -> &str {
        &self.client_id
    }
    pub fn clear_client_id(&mut self) {
        self.client_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: ::std::string::String) {
        self.client_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_id(&mut self) -> &mut ::std::string::String {
        &mut self.client_id
    }

    // Take field
    pub fn take_client_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_id, ::std::string::String::new())
    }

    // string client_secret = 3;


    pub fn get_client_secret(&self) -> &str {
        &self.client_secret
    }
    pub fn clear_client_secret(&mut self) {
        self.client_secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_secret(&mut self, v: ::std::string::String) {
        self.client_secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_secret(&mut self) -> &mut ::std::string::String {
        &mut self.client_secret
    }

    // Take field
    pub fn take_client_secret(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_secret, ::std::string::String::new())
    }

    // string button_image_url = 4;


    pub fn get_button_image_url(&self) -> &str {
        &self.button_image_url
    }
    pub fn clear_button_image_url(&mut self) {
        self.button_image_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_button_image_url(&mut self, v: ::std::string::String) {
        self.button_image_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_button_image_url(&mut self) -> &mut ::std::string::String {
        &mut self.button_image_url
    }

    // Take field
    pub fn take_button_image_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.button_image_url, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.UpdateConnectionRequest.Providers provider = 6;


    pub fn get_provider(&self) -> UpdateConnectionRequest_Providers {
        self.provider
    }
    pub fn clear_provider(&mut self) {
        self.provider = UpdateConnectionRequest_Providers::NONE;
    }

    // Param is passed by value, moved
    pub fn set_provider(&mut self, v: UpdateConnectionRequest_Providers) {
        self.provider = v;
    }

    // string oidc_discovery_url = 7;


    pub fn get_oidc_discovery_url(&self) -> &str {
        &self.oidc_discovery_url
    }
    pub fn clear_oidc_discovery_url(&mut self) {
        self.oidc_discovery_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_oidc_discovery_url(&mut self, v: ::std::string::String) {
        self.oidc_discovery_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_oidc_discovery_url(&mut self) -> &mut ::std::string::String {
        &mut self.oidc_discovery_url
    }

    // Take field
    pub fn take_oidc_discovery_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.oidc_discovery_url, ::std::string::String::new())
    }

    // repeated string mfa = 8;


    pub fn get_mfa(&self) -> &[::std::string::String] {
        &self.mfa
    }
    pub fn clear_mfa(&mut self) {
        self.mfa.clear();
    }

    // Param is passed by value, moved
    pub fn set_mfa(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mfa = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mfa(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mfa
    }

    // Take field
    pub fn take_mfa(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mfa, ::protobuf::RepeatedField::new())
    }

    // .depot.devtools.auth.v0.identity.admin.UpdateConnectionRequest.Types type = 9;


    pub fn get_field_type(&self) -> UpdateConnectionRequest_Types {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = UpdateConnectionRequest_Types::UNSET;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: UpdateConnectionRequest_Types) {
        self.field_type = v;
    }

    // string id = 10;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string scopes = 11;


    pub fn get_scopes(&self) -> &str {
        &self.scopes
    }
    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::std::string::String) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scopes(&mut self) -> &mut ::std::string::String {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scopes, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateConnectionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_secret)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.button_image_url)?;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.provider, 6, &mut self.unknown_fields)?
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.oidc_discovery_url)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mfa)?;
                },
                9 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 9, &mut self.unknown_fields)?
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scopes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.client_id);
        }
        if !self.client_secret.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.client_secret);
        }
        if !self.button_image_url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.button_image_url);
        }
        if self.provider != UpdateConnectionRequest_Providers::NONE {
            my_size += ::protobuf::rt::enum_size(6, self.provider);
        }
        if !self.oidc_discovery_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.oidc_discovery_url);
        }
        for value in &self.mfa {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if self.field_type != UpdateConnectionRequest_Types::UNSET {
            my_size += ::protobuf::rt::enum_size(9, self.field_type);
        }
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.id);
        }
        if !self.scopes.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.scopes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.client_id.is_empty() {
            os.write_string(2, &self.client_id)?;
        }
        if !self.client_secret.is_empty() {
            os.write_string(3, &self.client_secret)?;
        }
        if !self.button_image_url.is_empty() {
            os.write_string(4, &self.button_image_url)?;
        }
        if self.provider != UpdateConnectionRequest_Providers::NONE {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.provider))?;
        }
        if !self.oidc_discovery_url.is_empty() {
            os.write_string(7, &self.oidc_discovery_url)?;
        }
        for v in &self.mfa {
            os.write_string(8, &v)?;
        };
        if self.field_type != UpdateConnectionRequest_Types::UNSET {
            os.write_enum(9, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if !self.id.is_empty() {
            os.write_string(10, &self.id)?;
        }
        if !self.scopes.is_empty() {
            os.write_string(11, &self.scopes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateConnectionRequest {
        UpdateConnectionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_id",
                |m: &UpdateConnectionRequest| { &m.client_id },
                |m: &mut UpdateConnectionRequest| { &mut m.client_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_secret",
                |m: &UpdateConnectionRequest| { &m.client_secret },
                |m: &mut UpdateConnectionRequest| { &mut m.client_secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "button_image_url",
                |m: &UpdateConnectionRequest| { &m.button_image_url },
                |m: &mut UpdateConnectionRequest| { &mut m.button_image_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UpdateConnectionRequest_Providers>>(
                "provider",
                |m: &UpdateConnectionRequest| { &m.provider },
                |m: &mut UpdateConnectionRequest| { &mut m.provider },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "oidc_discovery_url",
                |m: &UpdateConnectionRequest| { &m.oidc_discovery_url },
                |m: &mut UpdateConnectionRequest| { &mut m.oidc_discovery_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mfa",
                |m: &UpdateConnectionRequest| { &m.mfa },
                |m: &mut UpdateConnectionRequest| { &mut m.mfa },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UpdateConnectionRequest_Types>>(
                "type",
                |m: &UpdateConnectionRequest| { &m.field_type },
                |m: &mut UpdateConnectionRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &UpdateConnectionRequest| { &m.id },
                |m: &mut UpdateConnectionRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scopes",
                |m: &UpdateConnectionRequest| { &m.scopes },
                |m: &mut UpdateConnectionRequest| { &mut m.scopes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateConnectionRequest>(
                "UpdateConnectionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateConnectionRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateConnectionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateConnectionRequest::new)
    }
}

impl ::protobuf::Clear for UpdateConnectionRequest {
    fn clear(&mut self) {
        self.client_id.clear();
        self.client_secret.clear();
        self.button_image_url.clear();
        self.provider = UpdateConnectionRequest_Providers::NONE;
        self.oidc_discovery_url.clear();
        self.mfa.clear();
        self.field_type = UpdateConnectionRequest_Types::UNSET;
        self.id.clear();
        self.scopes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateConnectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateConnectionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UpdateConnectionRequest_Providers {
    NONE = 0,
    OPENID = 1,
    AMAZON = 2,
    BITBUCKET = 3,
    BOX = 4,
    DAILYMOTION = 5,
    DEEZER = 6,
    DIGITALOCEAN = 7,
    DISCORD = 8,
    DROPBOX = 9,
    EVEONLINE = 10,
    FACEBOOK = 11,
    FITBIT = 12,
    GITEA = 13,
    GITHUB = 14,
    GITLAB = 15,
    GOOGLE = 16,
    SHOPIFY = 18,
    SOUNDCLOUD = 19,
    SPOTIFY = 20,
    STEAM = 21,
    STRIPE = 22,
    TWITCH = 23,
    UBER = 24,
    WEPAY = 25,
    YAHOO = 26,
    YAMMER = 27,
    HEROKU = 28,
    INSTAGRAM = 29,
    INTERCOM = 30,
    KAKAO = 31,
    LASTFM = 32,
    LINKEDIN = 33,
    LINE = 34,
    ONEDRIVE = 35,
    AZUREAD = 36,
    MICROSOFTONLINE = 37,
    BATTLENET = 38,
    PAYPAL = 39,
    TWITTER = 40,
    SALESFORCE = 41,
    TYPETALK = 42,
    SLACK = 43,
    MEETUP = 44,
    XERO = 46,
    VK = 47,
    NAVER = 48,
    YANDEX = 49,
    NEXTCLOUD = 50,
    APPLE = 52,
    STRAVA = 53,
}

impl ::protobuf::ProtobufEnum for UpdateConnectionRequest_Providers {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UpdateConnectionRequest_Providers> {
        match value {
            0 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::NONE),
            1 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::OPENID),
            2 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::AMAZON),
            3 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::BITBUCKET),
            4 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::BOX),
            5 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::DAILYMOTION),
            6 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::DEEZER),
            7 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::DIGITALOCEAN),
            8 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::DISCORD),
            9 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::DROPBOX),
            10 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::EVEONLINE),
            11 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::FACEBOOK),
            12 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::FITBIT),
            13 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::GITEA),
            14 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::GITHUB),
            15 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::GITLAB),
            16 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::GOOGLE),
            18 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::SHOPIFY),
            19 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::SOUNDCLOUD),
            20 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::SPOTIFY),
            21 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::STEAM),
            22 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::STRIPE),
            23 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::TWITCH),
            24 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::UBER),
            25 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::WEPAY),
            26 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::YAHOO),
            27 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::YAMMER),
            28 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::HEROKU),
            29 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::INSTAGRAM),
            30 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::INTERCOM),
            31 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::KAKAO),
            32 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::LASTFM),
            33 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::LINKEDIN),
            34 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::LINE),
            35 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::ONEDRIVE),
            36 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::AZUREAD),
            37 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::MICROSOFTONLINE),
            38 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::BATTLENET),
            39 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::PAYPAL),
            40 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::TWITTER),
            41 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::SALESFORCE),
            42 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::TYPETALK),
            43 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::SLACK),
            44 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::MEETUP),
            46 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::XERO),
            47 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::VK),
            48 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::NAVER),
            49 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::YANDEX),
            50 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::NEXTCLOUD),
            52 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::APPLE),
            53 => ::std::option::Option::Some(UpdateConnectionRequest_Providers::STRAVA),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UpdateConnectionRequest_Providers] = &[
            UpdateConnectionRequest_Providers::NONE,
            UpdateConnectionRequest_Providers::OPENID,
            UpdateConnectionRequest_Providers::AMAZON,
            UpdateConnectionRequest_Providers::BITBUCKET,
            UpdateConnectionRequest_Providers::BOX,
            UpdateConnectionRequest_Providers::DAILYMOTION,
            UpdateConnectionRequest_Providers::DEEZER,
            UpdateConnectionRequest_Providers::DIGITALOCEAN,
            UpdateConnectionRequest_Providers::DISCORD,
            UpdateConnectionRequest_Providers::DROPBOX,
            UpdateConnectionRequest_Providers::EVEONLINE,
            UpdateConnectionRequest_Providers::FACEBOOK,
            UpdateConnectionRequest_Providers::FITBIT,
            UpdateConnectionRequest_Providers::GITEA,
            UpdateConnectionRequest_Providers::GITHUB,
            UpdateConnectionRequest_Providers::GITLAB,
            UpdateConnectionRequest_Providers::GOOGLE,
            UpdateConnectionRequest_Providers::SHOPIFY,
            UpdateConnectionRequest_Providers::SOUNDCLOUD,
            UpdateConnectionRequest_Providers::SPOTIFY,
            UpdateConnectionRequest_Providers::STEAM,
            UpdateConnectionRequest_Providers::STRIPE,
            UpdateConnectionRequest_Providers::TWITCH,
            UpdateConnectionRequest_Providers::UBER,
            UpdateConnectionRequest_Providers::WEPAY,
            UpdateConnectionRequest_Providers::YAHOO,
            UpdateConnectionRequest_Providers::YAMMER,
            UpdateConnectionRequest_Providers::HEROKU,
            UpdateConnectionRequest_Providers::INSTAGRAM,
            UpdateConnectionRequest_Providers::INTERCOM,
            UpdateConnectionRequest_Providers::KAKAO,
            UpdateConnectionRequest_Providers::LASTFM,
            UpdateConnectionRequest_Providers::LINKEDIN,
            UpdateConnectionRequest_Providers::LINE,
            UpdateConnectionRequest_Providers::ONEDRIVE,
            UpdateConnectionRequest_Providers::AZUREAD,
            UpdateConnectionRequest_Providers::MICROSOFTONLINE,
            UpdateConnectionRequest_Providers::BATTLENET,
            UpdateConnectionRequest_Providers::PAYPAL,
            UpdateConnectionRequest_Providers::TWITTER,
            UpdateConnectionRequest_Providers::SALESFORCE,
            UpdateConnectionRequest_Providers::TYPETALK,
            UpdateConnectionRequest_Providers::SLACK,
            UpdateConnectionRequest_Providers::MEETUP,
            UpdateConnectionRequest_Providers::XERO,
            UpdateConnectionRequest_Providers::VK,
            UpdateConnectionRequest_Providers::NAVER,
            UpdateConnectionRequest_Providers::YANDEX,
            UpdateConnectionRequest_Providers::NEXTCLOUD,
            UpdateConnectionRequest_Providers::APPLE,
            UpdateConnectionRequest_Providers::STRAVA,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UpdateConnectionRequest_Providers>("UpdateConnectionRequest.Providers", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UpdateConnectionRequest_Providers {
}

impl ::std::default::Default for UpdateConnectionRequest_Providers {
    fn default() -> Self {
        UpdateConnectionRequest_Providers::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateConnectionRequest_Providers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UpdateConnectionRequest_Types {
    UNSET = 0,
    PASSWORD = 1,
    OTP = 2,
    TOTP = 3,
    OIDC = 4,
}

impl ::protobuf::ProtobufEnum for UpdateConnectionRequest_Types {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UpdateConnectionRequest_Types> {
        match value {
            0 => ::std::option::Option::Some(UpdateConnectionRequest_Types::UNSET),
            1 => ::std::option::Option::Some(UpdateConnectionRequest_Types::PASSWORD),
            2 => ::std::option::Option::Some(UpdateConnectionRequest_Types::OTP),
            3 => ::std::option::Option::Some(UpdateConnectionRequest_Types::TOTP),
            4 => ::std::option::Option::Some(UpdateConnectionRequest_Types::OIDC),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UpdateConnectionRequest_Types] = &[
            UpdateConnectionRequest_Types::UNSET,
            UpdateConnectionRequest_Types::PASSWORD,
            UpdateConnectionRequest_Types::OTP,
            UpdateConnectionRequest_Types::TOTP,
            UpdateConnectionRequest_Types::OIDC,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UpdateConnectionRequest_Types>("UpdateConnectionRequest.Types", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UpdateConnectionRequest_Types {
}

impl ::std::default::Default for UpdateConnectionRequest_Types {
    fn default() -> Self {
        UpdateConnectionRequest_Types::UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateConnectionRequest_Types {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateConnectionResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateConnectionResponse {
    fn default() -> &'a UpdateConnectionResponse {
        <UpdateConnectionResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateConnectionResponse {
    pub fn new() -> UpdateConnectionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateConnectionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateConnectionResponse {
        UpdateConnectionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateConnectionResponse>(
                "UpdateConnectionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateConnectionResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateConnectionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateConnectionResponse::new)
    }
}

impl ::protobuf::Clear for UpdateConnectionResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateConnectionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateConnectionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteConnectionRequest {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteConnectionRequest {
    fn default() -> &'a DeleteConnectionRequest {
        <DeleteConnectionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteConnectionRequest {
    pub fn new() -> DeleteConnectionRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteConnectionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteConnectionRequest {
        DeleteConnectionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &DeleteConnectionRequest| { &m.id },
                |m: &mut DeleteConnectionRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteConnectionRequest>(
                "DeleteConnectionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteConnectionRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteConnectionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteConnectionRequest::new)
    }
}

impl ::protobuf::Clear for DeleteConnectionRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteConnectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteConnectionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteConnectionResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteConnectionResponse {
    fn default() -> &'a DeleteConnectionResponse {
        <DeleteConnectionResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteConnectionResponse {
    pub fn new() -> DeleteConnectionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteConnectionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteConnectionResponse {
        DeleteConnectionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteConnectionResponse>(
                "DeleteConnectionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteConnectionResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteConnectionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteConnectionResponse::new)
    }
}

impl ::protobuf::Clear for DeleteConnectionResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteConnectionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteConnectionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetOAuth2ClientsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetOAuth2ClientsRequest {
    fn default() -> &'a GetOAuth2ClientsRequest {
        <GetOAuth2ClientsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetOAuth2ClientsRequest {
    pub fn new() -> GetOAuth2ClientsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetOAuth2ClientsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOAuth2ClientsRequest {
        GetOAuth2ClientsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetOAuth2ClientsRequest>(
                "GetOAuth2ClientsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetOAuth2ClientsRequest {
        static instance: ::protobuf::rt::LazyV2<GetOAuth2ClientsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetOAuth2ClientsRequest::new)
    }
}

impl ::protobuf::Clear for GetOAuth2ClientsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOAuth2ClientsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOAuth2ClientsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetOAuth2ClientsResponse {
    // message fields
    pub clients: ::protobuf::RepeatedField<GetOAuth2ClientsResponse_Client>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetOAuth2ClientsResponse {
    fn default() -> &'a GetOAuth2ClientsResponse {
        <GetOAuth2ClientsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetOAuth2ClientsResponse {
    pub fn new() -> GetOAuth2ClientsResponse {
        ::std::default::Default::default()
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetOAuth2ClientsResponse.Client clients = 1;


    pub fn get_clients(&self) -> &[GetOAuth2ClientsResponse_Client] {
        &self.clients
    }
    pub fn clear_clients(&mut self) {
        self.clients.clear();
    }

    // Param is passed by value, moved
    pub fn set_clients(&mut self, v: ::protobuf::RepeatedField<GetOAuth2ClientsResponse_Client>) {
        self.clients = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clients(&mut self) -> &mut ::protobuf::RepeatedField<GetOAuth2ClientsResponse_Client> {
        &mut self.clients
    }

    // Take field
    pub fn take_clients(&mut self) -> ::protobuf::RepeatedField<GetOAuth2ClientsResponse_Client> {
        ::std::mem::replace(&mut self.clients, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetOAuth2ClientsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.clients {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.clients)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.clients {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.clients {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOAuth2ClientsResponse {
        GetOAuth2ClientsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetOAuth2ClientsResponse_Client>>(
                "clients",
                |m: &GetOAuth2ClientsResponse| { &m.clients },
                |m: &mut GetOAuth2ClientsResponse| { &mut m.clients },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetOAuth2ClientsResponse>(
                "GetOAuth2ClientsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetOAuth2ClientsResponse {
        static instance: ::protobuf::rt::LazyV2<GetOAuth2ClientsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetOAuth2ClientsResponse::new)
    }
}

impl ::protobuf::Clear for GetOAuth2ClientsResponse {
    fn clear(&mut self) {
        self.clients.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOAuth2ClientsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOAuth2ClientsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetOAuth2ClientsResponse_Client {
    // message fields
    pub allowed_cors_origins: ::protobuf::RepeatedField<::std::string::String>,
    pub audience: ::protobuf::RepeatedField<::std::string::String>,
    pub backchannel_logout_session_required: bool,
    pub backchannel_logout_uri: ::std::string::String,
    pub client_id: ::std::string::String,
    pub client_name: ::std::string::String,
    pub client_secret_expires_at: i64,
    pub client_uri: ::std::string::String,
    pub contacts: ::protobuf::RepeatedField<::std::string::String>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub frontchannel_logout_session_required: bool,
    pub frontchannel_logout_uri: ::std::string::String,
    pub grant_types: ::std::vec::Vec<GrantType>,
    pub jwks: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub jwks_uri: ::std::string::String,
    pub logo_uri: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub owner: ::std::string::String,
    pub policy_uri: ::std::string::String,
    pub post_logout_redirect_uris: ::protobuf::RepeatedField<::std::string::String>,
    pub redirect_uris: ::protobuf::RepeatedField<::std::string::String>,
    pub request_object_signing_alg: RequestObjectSigningAlg,
    pub request_uris: ::protobuf::RepeatedField<::std::string::String>,
    pub response_types: ::std::vec::Vec<ResponseType>,
    pub scope: ::std::string::String,
    pub sector_identifier_uri: ::std::string::String,
    pub subject_type: SubjectType,
    pub token_endpoint_auth_method: TokenEndpointAuthMethod,
    pub token_endpoint_auth_signing_alg: TokenEndpointAuthSigningAlg,
    pub tos_uri: ::std::string::String,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub userinfo_signed_response_alg: UserinfoSignedResponseAlg,
    pub client_type: ClientType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetOAuth2ClientsResponse_Client {
    fn default() -> &'a GetOAuth2ClientsResponse_Client {
        <GetOAuth2ClientsResponse_Client as ::protobuf::Message>::default_instance()
    }
}

impl GetOAuth2ClientsResponse_Client {
    pub fn new() -> GetOAuth2ClientsResponse_Client {
        ::std::default::Default::default()
    }

    // repeated string allowed_cors_origins = 1;


    pub fn get_allowed_cors_origins(&self) -> &[::std::string::String] {
        &self.allowed_cors_origins
    }
    pub fn clear_allowed_cors_origins(&mut self) {
        self.allowed_cors_origins.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_cors_origins(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allowed_cors_origins = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_cors_origins(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allowed_cors_origins
    }

    // Take field
    pub fn take_allowed_cors_origins(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allowed_cors_origins, ::protobuf::RepeatedField::new())
    }

    // repeated string audience = 2;


    pub fn get_audience(&self) -> &[::std::string::String] {
        &self.audience
    }
    pub fn clear_audience(&mut self) {
        self.audience.clear();
    }

    // Param is passed by value, moved
    pub fn set_audience(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.audience = v;
    }

    // Mutable pointer to the field.
    pub fn mut_audience(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.audience
    }

    // Take field
    pub fn take_audience(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.audience, ::protobuf::RepeatedField::new())
    }

    // bool backchannel_logout_session_required = 3;


    pub fn get_backchannel_logout_session_required(&self) -> bool {
        self.backchannel_logout_session_required
    }
    pub fn clear_backchannel_logout_session_required(&mut self) {
        self.backchannel_logout_session_required = false;
    }

    // Param is passed by value, moved
    pub fn set_backchannel_logout_session_required(&mut self, v: bool) {
        self.backchannel_logout_session_required = v;
    }

    // string backchannel_logout_uri = 4;


    pub fn get_backchannel_logout_uri(&self) -> &str {
        &self.backchannel_logout_uri
    }
    pub fn clear_backchannel_logout_uri(&mut self) {
        self.backchannel_logout_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_backchannel_logout_uri(&mut self, v: ::std::string::String) {
        self.backchannel_logout_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backchannel_logout_uri(&mut self) -> &mut ::std::string::String {
        &mut self.backchannel_logout_uri
    }

    // Take field
    pub fn take_backchannel_logout_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backchannel_logout_uri, ::std::string::String::new())
    }

    // string client_id = 5;


    pub fn get_client_id(&self) -> &str {
        &self.client_id
    }
    pub fn clear_client_id(&mut self) {
        self.client_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: ::std::string::String) {
        self.client_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_id(&mut self) -> &mut ::std::string::String {
        &mut self.client_id
    }

    // Take field
    pub fn take_client_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_id, ::std::string::String::new())
    }

    // string client_name = 6;


    pub fn get_client_name(&self) -> &str {
        &self.client_name
    }
    pub fn clear_client_name(&mut self) {
        self.client_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_name(&mut self, v: ::std::string::String) {
        self.client_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_name(&mut self) -> &mut ::std::string::String {
        &mut self.client_name
    }

    // Take field
    pub fn take_client_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_name, ::std::string::String::new())
    }

    // int64 client_secret_expires_at = 7;


    pub fn get_client_secret_expires_at(&self) -> i64 {
        self.client_secret_expires_at
    }
    pub fn clear_client_secret_expires_at(&mut self) {
        self.client_secret_expires_at = 0;
    }

    // Param is passed by value, moved
    pub fn set_client_secret_expires_at(&mut self, v: i64) {
        self.client_secret_expires_at = v;
    }

    // string client_uri = 8;


    pub fn get_client_uri(&self) -> &str {
        &self.client_uri
    }
    pub fn clear_client_uri(&mut self) {
        self.client_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_uri(&mut self, v: ::std::string::String) {
        self.client_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_uri(&mut self) -> &mut ::std::string::String {
        &mut self.client_uri
    }

    // Take field
    pub fn take_client_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_uri, ::std::string::String::new())
    }

    // repeated string contacts = 9;


    pub fn get_contacts(&self) -> &[::std::string::String] {
        &self.contacts
    }
    pub fn clear_contacts(&mut self) {
        self.contacts.clear();
    }

    // Param is passed by value, moved
    pub fn set_contacts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.contacts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contacts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.contacts
    }

    // Take field
    pub fn take_contacts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.contacts, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp created_at = 10;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // bool frontchannel_logout_session_required = 11;


    pub fn get_frontchannel_logout_session_required(&self) -> bool {
        self.frontchannel_logout_session_required
    }
    pub fn clear_frontchannel_logout_session_required(&mut self) {
        self.frontchannel_logout_session_required = false;
    }

    // Param is passed by value, moved
    pub fn set_frontchannel_logout_session_required(&mut self, v: bool) {
        self.frontchannel_logout_session_required = v;
    }

    // string frontchannel_logout_uri = 12;


    pub fn get_frontchannel_logout_uri(&self) -> &str {
        &self.frontchannel_logout_uri
    }
    pub fn clear_frontchannel_logout_uri(&mut self) {
        self.frontchannel_logout_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_frontchannel_logout_uri(&mut self, v: ::std::string::String) {
        self.frontchannel_logout_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frontchannel_logout_uri(&mut self) -> &mut ::std::string::String {
        &mut self.frontchannel_logout_uri
    }

    // Take field
    pub fn take_frontchannel_logout_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.frontchannel_logout_uri, ::std::string::String::new())
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GrantType grant_types = 13;


    pub fn get_grant_types(&self) -> &[GrantType] {
        &self.grant_types
    }
    pub fn clear_grant_types(&mut self) {
        self.grant_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_grant_types(&mut self, v: ::std::vec::Vec<GrantType>) {
        self.grant_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_grant_types(&mut self) -> &mut ::std::vec::Vec<GrantType> {
        &mut self.grant_types
    }

    // Take field
    pub fn take_grant_types(&mut self) -> ::std::vec::Vec<GrantType> {
        ::std::mem::replace(&mut self.grant_types, ::std::vec::Vec::new())
    }

    // .google.protobuf.Struct jwks = 14;


    pub fn get_jwks(&self) -> &::protobuf::well_known_types::Struct {
        self.jwks.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jwks(&mut self) {
        self.jwks.clear();
    }

    pub fn has_jwks(&self) -> bool {
        self.jwks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jwks(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.jwks = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jwks(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.jwks.is_none() {
            self.jwks.set_default();
        }
        self.jwks.as_mut().unwrap()
    }

    // Take field
    pub fn take_jwks(&mut self) -> ::protobuf::well_known_types::Struct {
        self.jwks.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string jwks_uri = 15;


    pub fn get_jwks_uri(&self) -> &str {
        &self.jwks_uri
    }
    pub fn clear_jwks_uri(&mut self) {
        self.jwks_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_jwks_uri(&mut self, v: ::std::string::String) {
        self.jwks_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jwks_uri(&mut self) -> &mut ::std::string::String {
        &mut self.jwks_uri
    }

    // Take field
    pub fn take_jwks_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.jwks_uri, ::std::string::String::new())
    }

    // string logo_uri = 16;


    pub fn get_logo_uri(&self) -> &str {
        &self.logo_uri
    }
    pub fn clear_logo_uri(&mut self) {
        self.logo_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_logo_uri(&mut self, v: ::std::string::String) {
        self.logo_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logo_uri(&mut self) -> &mut ::std::string::String {
        &mut self.logo_uri
    }

    // Take field
    pub fn take_logo_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logo_uri, ::std::string::String::new())
    }

    // .google.protobuf.Struct metadata = 17;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string owner = 18;


    pub fn get_owner(&self) -> &str {
        &self.owner
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        &mut self.owner
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.owner, ::std::string::String::new())
    }

    // string policy_uri = 19;


    pub fn get_policy_uri(&self) -> &str {
        &self.policy_uri
    }
    pub fn clear_policy_uri(&mut self) {
        self.policy_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_policy_uri(&mut self, v: ::std::string::String) {
        self.policy_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policy_uri(&mut self) -> &mut ::std::string::String {
        &mut self.policy_uri
    }

    // Take field
    pub fn take_policy_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.policy_uri, ::std::string::String::new())
    }

    // repeated string post_logout_redirect_uris = 20;


    pub fn get_post_logout_redirect_uris(&self) -> &[::std::string::String] {
        &self.post_logout_redirect_uris
    }
    pub fn clear_post_logout_redirect_uris(&mut self) {
        self.post_logout_redirect_uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_post_logout_redirect_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.post_logout_redirect_uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_post_logout_redirect_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.post_logout_redirect_uris
    }

    // Take field
    pub fn take_post_logout_redirect_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.post_logout_redirect_uris, ::protobuf::RepeatedField::new())
    }

    // repeated string redirect_uris = 21;


    pub fn get_redirect_uris(&self) -> &[::std::string::String] {
        &self.redirect_uris
    }
    pub fn clear_redirect_uris(&mut self) {
        self.redirect_uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_redirect_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.redirect_uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_redirect_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.redirect_uris
    }

    // Take field
    pub fn take_redirect_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.redirect_uris, ::protobuf::RepeatedField::new())
    }

    // .depot.devtools.auth.v0.identity.admin.RequestObjectSigningAlg request_object_signing_alg = 22;


    pub fn get_request_object_signing_alg(&self) -> RequestObjectSigningAlg {
        self.request_object_signing_alg
    }
    pub fn clear_request_object_signing_alg(&mut self) {
        self.request_object_signing_alg = RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_request_object_signing_alg(&mut self, v: RequestObjectSigningAlg) {
        self.request_object_signing_alg = v;
    }

    // repeated string request_uris = 23;


    pub fn get_request_uris(&self) -> &[::std::string::String] {
        &self.request_uris
    }
    pub fn clear_request_uris(&mut self) {
        self.request_uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.request_uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.request_uris
    }

    // Take field
    pub fn take_request_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.request_uris, ::protobuf::RepeatedField::new())
    }

    // repeated .depot.devtools.auth.v0.identity.admin.ResponseType response_types = 24;


    pub fn get_response_types(&self) -> &[ResponseType] {
        &self.response_types
    }
    pub fn clear_response_types(&mut self) {
        self.response_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_types(&mut self, v: ::std::vec::Vec<ResponseType>) {
        self.response_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_types(&mut self) -> &mut ::std::vec::Vec<ResponseType> {
        &mut self.response_types
    }

    // Take field
    pub fn take_response_types(&mut self) -> ::std::vec::Vec<ResponseType> {
        ::std::mem::replace(&mut self.response_types, ::std::vec::Vec::new())
    }

    // string scope = 25;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // string sector_identifier_uri = 26;


    pub fn get_sector_identifier_uri(&self) -> &str {
        &self.sector_identifier_uri
    }
    pub fn clear_sector_identifier_uri(&mut self) {
        self.sector_identifier_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_sector_identifier_uri(&mut self, v: ::std::string::String) {
        self.sector_identifier_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sector_identifier_uri(&mut self) -> &mut ::std::string::String {
        &mut self.sector_identifier_uri
    }

    // Take field
    pub fn take_sector_identifier_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sector_identifier_uri, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.SubjectType subject_type = 27;


    pub fn get_subject_type(&self) -> SubjectType {
        self.subject_type
    }
    pub fn clear_subject_type(&mut self) {
        self.subject_type = SubjectType::SUBJECT_TYPE_PUBLIC;
    }

    // Param is passed by value, moved
    pub fn set_subject_type(&mut self, v: SubjectType) {
        self.subject_type = v;
    }

    // .depot.devtools.auth.v0.identity.admin.TokenEndpointAuthMethod token_endpoint_auth_method = 28;


    pub fn get_token_endpoint_auth_method(&self) -> TokenEndpointAuthMethod {
        self.token_endpoint_auth_method
    }
    pub fn clear_token_endpoint_auth_method(&mut self) {
        self.token_endpoint_auth_method = TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC;
    }

    // Param is passed by value, moved
    pub fn set_token_endpoint_auth_method(&mut self, v: TokenEndpointAuthMethod) {
        self.token_endpoint_auth_method = v;
    }

    // .depot.devtools.auth.v0.identity.admin.TokenEndpointAuthSigningAlg token_endpoint_auth_signing_alg = 29;


    pub fn get_token_endpoint_auth_signing_alg(&self) -> TokenEndpointAuthSigningAlg {
        self.token_endpoint_auth_signing_alg
    }
    pub fn clear_token_endpoint_auth_signing_alg(&mut self) {
        self.token_endpoint_auth_signing_alg = TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_token_endpoint_auth_signing_alg(&mut self, v: TokenEndpointAuthSigningAlg) {
        self.token_endpoint_auth_signing_alg = v;
    }

    // string tos_uri = 30;


    pub fn get_tos_uri(&self) -> &str {
        &self.tos_uri
    }
    pub fn clear_tos_uri(&mut self) {
        self.tos_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_tos_uri(&mut self, v: ::std::string::String) {
        self.tos_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tos_uri(&mut self) -> &mut ::std::string::String {
        &mut self.tos_uri
    }

    // Take field
    pub fn take_tos_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tos_uri, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp updated_at = 31;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .depot.devtools.auth.v0.identity.admin.UserinfoSignedResponseAlg userinfo_signed_response_alg = 32;


    pub fn get_userinfo_signed_response_alg(&self) -> UserinfoSignedResponseAlg {
        self.userinfo_signed_response_alg
    }
    pub fn clear_userinfo_signed_response_alg(&mut self) {
        self.userinfo_signed_response_alg = UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_userinfo_signed_response_alg(&mut self, v: UserinfoSignedResponseAlg) {
        self.userinfo_signed_response_alg = v;
    }

    // .depot.devtools.auth.v0.identity.admin.ClientType client_type = 33;


    pub fn get_client_type(&self) -> ClientType {
        self.client_type
    }
    pub fn clear_client_type(&mut self) {
        self.client_type = ClientType::CLIENT_TYPE_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_client_type(&mut self, v: ClientType) {
        self.client_type = v;
    }
}

impl ::protobuf::Message for GetOAuth2ClientsResponse_Client {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.jwks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allowed_cors_origins)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.audience)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.backchannel_logout_session_required = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backchannel_logout_uri)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.client_secret_expires_at = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_uri)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.contacts)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.frontchannel_logout_session_required = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.frontchannel_logout_uri)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.grant_types, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jwks)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.jwks_uri)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logo_uri)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.owner)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.policy_uri)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.post_logout_redirect_uris)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.redirect_uris)?;
                },
                22 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.request_object_signing_alg, 22, &mut self.unknown_fields)?
                },
                23 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.request_uris)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.response_types, 24, &mut self.unknown_fields)?
                },
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sector_identifier_uri)?;
                },
                27 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.subject_type, 27, &mut self.unknown_fields)?
                },
                28 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.token_endpoint_auth_method, 28, &mut self.unknown_fields)?
                },
                29 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.token_endpoint_auth_signing_alg, 29, &mut self.unknown_fields)?
                },
                30 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tos_uri)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                32 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.userinfo_signed_response_alg, 32, &mut self.unknown_fields)?
                },
                33 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.client_type, 33, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allowed_cors_origins {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.audience {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.backchannel_logout_session_required != false {
            my_size += 2;
        }
        if !self.backchannel_logout_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.backchannel_logout_uri);
        }
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.client_id);
        }
        if !self.client_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.client_name);
        }
        if self.client_secret_expires_at != 0 {
            my_size += ::protobuf::rt::value_size(7, self.client_secret_expires_at, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.client_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.client_uri);
        }
        for value in &self.contacts {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.frontchannel_logout_session_required != false {
            my_size += 2;
        }
        if !self.frontchannel_logout_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.frontchannel_logout_uri);
        }
        for value in &self.grant_types {
            my_size += ::protobuf::rt::enum_size(13, *value);
        };
        if let Some(ref v) = self.jwks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.jwks_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.jwks_uri);
        }
        if !self.logo_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.logo_uri);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.owner);
        }
        if !self.policy_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.policy_uri);
        }
        for value in &self.post_logout_redirect_uris {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.redirect_uris {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        if self.request_object_signing_alg != RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET {
            my_size += ::protobuf::rt::enum_size(22, self.request_object_signing_alg);
        }
        for value in &self.request_uris {
            my_size += ::protobuf::rt::string_size(23, &value);
        };
        for value in &self.response_types {
            my_size += ::protobuf::rt::enum_size(24, *value);
        };
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.scope);
        }
        if !self.sector_identifier_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.sector_identifier_uri);
        }
        if self.subject_type != SubjectType::SUBJECT_TYPE_PUBLIC {
            my_size += ::protobuf::rt::enum_size(27, self.subject_type);
        }
        if self.token_endpoint_auth_method != TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC {
            my_size += ::protobuf::rt::enum_size(28, self.token_endpoint_auth_method);
        }
        if self.token_endpoint_auth_signing_alg != TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET {
            my_size += ::protobuf::rt::enum_size(29, self.token_endpoint_auth_signing_alg);
        }
        if !self.tos_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.tos_uri);
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.userinfo_signed_response_alg != UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET {
            my_size += ::protobuf::rt::enum_size(32, self.userinfo_signed_response_alg);
        }
        if self.client_type != ClientType::CLIENT_TYPE_UNSET {
            my_size += ::protobuf::rt::enum_size(33, self.client_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allowed_cors_origins {
            os.write_string(1, &v)?;
        };
        for v in &self.audience {
            os.write_string(2, &v)?;
        };
        if self.backchannel_logout_session_required != false {
            os.write_bool(3, self.backchannel_logout_session_required)?;
        }
        if !self.backchannel_logout_uri.is_empty() {
            os.write_string(4, &self.backchannel_logout_uri)?;
        }
        if !self.client_id.is_empty() {
            os.write_string(5, &self.client_id)?;
        }
        if !self.client_name.is_empty() {
            os.write_string(6, &self.client_name)?;
        }
        if self.client_secret_expires_at != 0 {
            os.write_int64(7, self.client_secret_expires_at)?;
        }
        if !self.client_uri.is_empty() {
            os.write_string(8, &self.client_uri)?;
        }
        for v in &self.contacts {
            os.write_string(9, &v)?;
        };
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.frontchannel_logout_session_required != false {
            os.write_bool(11, self.frontchannel_logout_session_required)?;
        }
        if !self.frontchannel_logout_uri.is_empty() {
            os.write_string(12, &self.frontchannel_logout_uri)?;
        }
        for v in &self.grant_types {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(ref v) = self.jwks.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.jwks_uri.is_empty() {
            os.write_string(15, &self.jwks_uri)?;
        }
        if !self.logo_uri.is_empty() {
            os.write_string(16, &self.logo_uri)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.owner.is_empty() {
            os.write_string(18, &self.owner)?;
        }
        if !self.policy_uri.is_empty() {
            os.write_string(19, &self.policy_uri)?;
        }
        for v in &self.post_logout_redirect_uris {
            os.write_string(20, &v)?;
        };
        for v in &self.redirect_uris {
            os.write_string(21, &v)?;
        };
        if self.request_object_signing_alg != RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET {
            os.write_enum(22, ::protobuf::ProtobufEnum::value(&self.request_object_signing_alg))?;
        }
        for v in &self.request_uris {
            os.write_string(23, &v)?;
        };
        for v in &self.response_types {
            os.write_enum(24, ::protobuf::ProtobufEnum::value(v))?;
        };
        if !self.scope.is_empty() {
            os.write_string(25, &self.scope)?;
        }
        if !self.sector_identifier_uri.is_empty() {
            os.write_string(26, &self.sector_identifier_uri)?;
        }
        if self.subject_type != SubjectType::SUBJECT_TYPE_PUBLIC {
            os.write_enum(27, ::protobuf::ProtobufEnum::value(&self.subject_type))?;
        }
        if self.token_endpoint_auth_method != TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC {
            os.write_enum(28, ::protobuf::ProtobufEnum::value(&self.token_endpoint_auth_method))?;
        }
        if self.token_endpoint_auth_signing_alg != TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET {
            os.write_enum(29, ::protobuf::ProtobufEnum::value(&self.token_endpoint_auth_signing_alg))?;
        }
        if !self.tos_uri.is_empty() {
            os.write_string(30, &self.tos_uri)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.userinfo_signed_response_alg != UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET {
            os.write_enum(32, ::protobuf::ProtobufEnum::value(&self.userinfo_signed_response_alg))?;
        }
        if self.client_type != ClientType::CLIENT_TYPE_UNSET {
            os.write_enum(33, ::protobuf::ProtobufEnum::value(&self.client_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOAuth2ClientsResponse_Client {
        GetOAuth2ClientsResponse_Client::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allowed_cors_origins",
                |m: &GetOAuth2ClientsResponse_Client| { &m.allowed_cors_origins },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.allowed_cors_origins },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "audience",
                |m: &GetOAuth2ClientsResponse_Client| { &m.audience },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.audience },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "backchannel_logout_session_required",
                |m: &GetOAuth2ClientsResponse_Client| { &m.backchannel_logout_session_required },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.backchannel_logout_session_required },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backchannel_logout_uri",
                |m: &GetOAuth2ClientsResponse_Client| { &m.backchannel_logout_uri },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.backchannel_logout_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_id",
                |m: &GetOAuth2ClientsResponse_Client| { &m.client_id },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.client_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_name",
                |m: &GetOAuth2ClientsResponse_Client| { &m.client_name },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.client_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "client_secret_expires_at",
                |m: &GetOAuth2ClientsResponse_Client| { &m.client_secret_expires_at },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.client_secret_expires_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_uri",
                |m: &GetOAuth2ClientsResponse_Client| { &m.client_uri },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.client_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contacts",
                |m: &GetOAuth2ClientsResponse_Client| { &m.contacts },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.contacts },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &GetOAuth2ClientsResponse_Client| { &m.created_at },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "frontchannel_logout_session_required",
                |m: &GetOAuth2ClientsResponse_Client| { &m.frontchannel_logout_session_required },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.frontchannel_logout_session_required },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "frontchannel_logout_uri",
                |m: &GetOAuth2ClientsResponse_Client| { &m.frontchannel_logout_uri },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.frontchannel_logout_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GrantType>>(
                "grant_types",
                |m: &GetOAuth2ClientsResponse_Client| { &m.grant_types },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.grant_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "jwks",
                |m: &GetOAuth2ClientsResponse_Client| { &m.jwks },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.jwks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "jwks_uri",
                |m: &GetOAuth2ClientsResponse_Client| { &m.jwks_uri },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.jwks_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "logo_uri",
                |m: &GetOAuth2ClientsResponse_Client| { &m.logo_uri },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.logo_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &GetOAuth2ClientsResponse_Client| { &m.metadata },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "owner",
                |m: &GetOAuth2ClientsResponse_Client| { &m.owner },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "policy_uri",
                |m: &GetOAuth2ClientsResponse_Client| { &m.policy_uri },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.policy_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "post_logout_redirect_uris",
                |m: &GetOAuth2ClientsResponse_Client| { &m.post_logout_redirect_uris },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.post_logout_redirect_uris },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "redirect_uris",
                |m: &GetOAuth2ClientsResponse_Client| { &m.redirect_uris },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.redirect_uris },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RequestObjectSigningAlg>>(
                "request_object_signing_alg",
                |m: &GetOAuth2ClientsResponse_Client| { &m.request_object_signing_alg },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.request_object_signing_alg },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "request_uris",
                |m: &GetOAuth2ClientsResponse_Client| { &m.request_uris },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.request_uris },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseType>>(
                "response_types",
                |m: &GetOAuth2ClientsResponse_Client| { &m.response_types },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.response_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &GetOAuth2ClientsResponse_Client| { &m.scope },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sector_identifier_uri",
                |m: &GetOAuth2ClientsResponse_Client| { &m.sector_identifier_uri },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.sector_identifier_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SubjectType>>(
                "subject_type",
                |m: &GetOAuth2ClientsResponse_Client| { &m.subject_type },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.subject_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TokenEndpointAuthMethod>>(
                "token_endpoint_auth_method",
                |m: &GetOAuth2ClientsResponse_Client| { &m.token_endpoint_auth_method },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.token_endpoint_auth_method },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TokenEndpointAuthSigningAlg>>(
                "token_endpoint_auth_signing_alg",
                |m: &GetOAuth2ClientsResponse_Client| { &m.token_endpoint_auth_signing_alg },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.token_endpoint_auth_signing_alg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tos_uri",
                |m: &GetOAuth2ClientsResponse_Client| { &m.tos_uri },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.tos_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "updated_at",
                |m: &GetOAuth2ClientsResponse_Client| { &m.updated_at },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.updated_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UserinfoSignedResponseAlg>>(
                "userinfo_signed_response_alg",
                |m: &GetOAuth2ClientsResponse_Client| { &m.userinfo_signed_response_alg },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.userinfo_signed_response_alg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClientType>>(
                "client_type",
                |m: &GetOAuth2ClientsResponse_Client| { &m.client_type },
                |m: &mut GetOAuth2ClientsResponse_Client| { &mut m.client_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetOAuth2ClientsResponse_Client>(
                "GetOAuth2ClientsResponse.Client",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetOAuth2ClientsResponse_Client {
        static instance: ::protobuf::rt::LazyV2<GetOAuth2ClientsResponse_Client> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetOAuth2ClientsResponse_Client::new)
    }
}

impl ::protobuf::Clear for GetOAuth2ClientsResponse_Client {
    fn clear(&mut self) {
        self.allowed_cors_origins.clear();
        self.audience.clear();
        self.backchannel_logout_session_required = false;
        self.backchannel_logout_uri.clear();
        self.client_id.clear();
        self.client_name.clear();
        self.client_secret_expires_at = 0;
        self.client_uri.clear();
        self.contacts.clear();
        self.created_at.clear();
        self.frontchannel_logout_session_required = false;
        self.frontchannel_logout_uri.clear();
        self.grant_types.clear();
        self.jwks.clear();
        self.jwks_uri.clear();
        self.logo_uri.clear();
        self.metadata.clear();
        self.owner.clear();
        self.policy_uri.clear();
        self.post_logout_redirect_uris.clear();
        self.redirect_uris.clear();
        self.request_object_signing_alg = RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET;
        self.request_uris.clear();
        self.response_types.clear();
        self.scope.clear();
        self.sector_identifier_uri.clear();
        self.subject_type = SubjectType::SUBJECT_TYPE_PUBLIC;
        self.token_endpoint_auth_method = TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC;
        self.token_endpoint_auth_signing_alg = TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET;
        self.tos_uri.clear();
        self.updated_at.clear();
        self.userinfo_signed_response_alg = UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET;
        self.client_type = ClientType::CLIENT_TYPE_UNSET;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOAuth2ClientsResponse_Client {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOAuth2ClientsResponse_Client {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateOAuth2ClientRequest {
    // message fields
    pub allowed_cors_origins: ::protobuf::RepeatedField<::std::string::String>,
    pub audience: ::protobuf::RepeatedField<::std::string::String>,
    pub backchannel_logout_session_required: bool,
    pub backchannel_logout_uri: ::std::string::String,
    pub client_name: ::std::string::String,
    pub client_uri: ::std::string::String,
    pub contacts: ::protobuf::RepeatedField<::std::string::String>,
    pub frontchannel_logout_session_required: bool,
    pub frontchannel_logout_uri: ::std::string::String,
    pub grant_types: ::std::vec::Vec<GrantType>,
    pub jwks: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub jwks_uri: ::std::string::String,
    pub logo_uri: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub owner: ::std::string::String,
    pub policy_uri: ::std::string::String,
    pub post_logout_redirect_uris: ::protobuf::RepeatedField<::std::string::String>,
    pub redirect_uris: ::protobuf::RepeatedField<::std::string::String>,
    pub request_object_signing_alg: RequestObjectSigningAlg,
    pub request_uris: ::protobuf::RepeatedField<::std::string::String>,
    pub response_types: ::std::vec::Vec<ResponseType>,
    pub scope: ::std::string::String,
    pub sector_identifier_uri: ::std::string::String,
    pub subject_type: SubjectType,
    pub token_endpoint_auth_method: TokenEndpointAuthMethod,
    pub token_endpoint_auth_signing_alg: TokenEndpointAuthSigningAlg,
    pub tos_uri: ::std::string::String,
    pub userinfo_signed_response_alg: UserinfoSignedResponseAlg,
    pub client_secret: ::std::string::String,
    pub client_type: ClientType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateOAuth2ClientRequest {
    fn default() -> &'a CreateOAuth2ClientRequest {
        <CreateOAuth2ClientRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateOAuth2ClientRequest {
    pub fn new() -> CreateOAuth2ClientRequest {
        ::std::default::Default::default()
    }

    // repeated string allowed_cors_origins = 1;


    pub fn get_allowed_cors_origins(&self) -> &[::std::string::String] {
        &self.allowed_cors_origins
    }
    pub fn clear_allowed_cors_origins(&mut self) {
        self.allowed_cors_origins.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_cors_origins(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allowed_cors_origins = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_cors_origins(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allowed_cors_origins
    }

    // Take field
    pub fn take_allowed_cors_origins(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allowed_cors_origins, ::protobuf::RepeatedField::new())
    }

    // repeated string audience = 2;


    pub fn get_audience(&self) -> &[::std::string::String] {
        &self.audience
    }
    pub fn clear_audience(&mut self) {
        self.audience.clear();
    }

    // Param is passed by value, moved
    pub fn set_audience(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.audience = v;
    }

    // Mutable pointer to the field.
    pub fn mut_audience(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.audience
    }

    // Take field
    pub fn take_audience(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.audience, ::protobuf::RepeatedField::new())
    }

    // bool backchannel_logout_session_required = 3;


    pub fn get_backchannel_logout_session_required(&self) -> bool {
        self.backchannel_logout_session_required
    }
    pub fn clear_backchannel_logout_session_required(&mut self) {
        self.backchannel_logout_session_required = false;
    }

    // Param is passed by value, moved
    pub fn set_backchannel_logout_session_required(&mut self, v: bool) {
        self.backchannel_logout_session_required = v;
    }

    // string backchannel_logout_uri = 4;


    pub fn get_backchannel_logout_uri(&self) -> &str {
        &self.backchannel_logout_uri
    }
    pub fn clear_backchannel_logout_uri(&mut self) {
        self.backchannel_logout_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_backchannel_logout_uri(&mut self, v: ::std::string::String) {
        self.backchannel_logout_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backchannel_logout_uri(&mut self) -> &mut ::std::string::String {
        &mut self.backchannel_logout_uri
    }

    // Take field
    pub fn take_backchannel_logout_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backchannel_logout_uri, ::std::string::String::new())
    }

    // string client_name = 6;


    pub fn get_client_name(&self) -> &str {
        &self.client_name
    }
    pub fn clear_client_name(&mut self) {
        self.client_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_name(&mut self, v: ::std::string::String) {
        self.client_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_name(&mut self) -> &mut ::std::string::String {
        &mut self.client_name
    }

    // Take field
    pub fn take_client_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_name, ::std::string::String::new())
    }

    // string client_uri = 8;


    pub fn get_client_uri(&self) -> &str {
        &self.client_uri
    }
    pub fn clear_client_uri(&mut self) {
        self.client_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_uri(&mut self, v: ::std::string::String) {
        self.client_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_uri(&mut self) -> &mut ::std::string::String {
        &mut self.client_uri
    }

    // Take field
    pub fn take_client_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_uri, ::std::string::String::new())
    }

    // repeated string contacts = 9;


    pub fn get_contacts(&self) -> &[::std::string::String] {
        &self.contacts
    }
    pub fn clear_contacts(&mut self) {
        self.contacts.clear();
    }

    // Param is passed by value, moved
    pub fn set_contacts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.contacts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contacts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.contacts
    }

    // Take field
    pub fn take_contacts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.contacts, ::protobuf::RepeatedField::new())
    }

    // bool frontchannel_logout_session_required = 11;


    pub fn get_frontchannel_logout_session_required(&self) -> bool {
        self.frontchannel_logout_session_required
    }
    pub fn clear_frontchannel_logout_session_required(&mut self) {
        self.frontchannel_logout_session_required = false;
    }

    // Param is passed by value, moved
    pub fn set_frontchannel_logout_session_required(&mut self, v: bool) {
        self.frontchannel_logout_session_required = v;
    }

    // string frontchannel_logout_uri = 12;


    pub fn get_frontchannel_logout_uri(&self) -> &str {
        &self.frontchannel_logout_uri
    }
    pub fn clear_frontchannel_logout_uri(&mut self) {
        self.frontchannel_logout_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_frontchannel_logout_uri(&mut self, v: ::std::string::String) {
        self.frontchannel_logout_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frontchannel_logout_uri(&mut self) -> &mut ::std::string::String {
        &mut self.frontchannel_logout_uri
    }

    // Take field
    pub fn take_frontchannel_logout_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.frontchannel_logout_uri, ::std::string::String::new())
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GrantType grant_types = 13;


    pub fn get_grant_types(&self) -> &[GrantType] {
        &self.grant_types
    }
    pub fn clear_grant_types(&mut self) {
        self.grant_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_grant_types(&mut self, v: ::std::vec::Vec<GrantType>) {
        self.grant_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_grant_types(&mut self) -> &mut ::std::vec::Vec<GrantType> {
        &mut self.grant_types
    }

    // Take field
    pub fn take_grant_types(&mut self) -> ::std::vec::Vec<GrantType> {
        ::std::mem::replace(&mut self.grant_types, ::std::vec::Vec::new())
    }

    // .google.protobuf.Struct jwks = 14;


    pub fn get_jwks(&self) -> &::protobuf::well_known_types::Struct {
        self.jwks.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jwks(&mut self) {
        self.jwks.clear();
    }

    pub fn has_jwks(&self) -> bool {
        self.jwks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jwks(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.jwks = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jwks(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.jwks.is_none() {
            self.jwks.set_default();
        }
        self.jwks.as_mut().unwrap()
    }

    // Take field
    pub fn take_jwks(&mut self) -> ::protobuf::well_known_types::Struct {
        self.jwks.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string jwks_uri = 15;


    pub fn get_jwks_uri(&self) -> &str {
        &self.jwks_uri
    }
    pub fn clear_jwks_uri(&mut self) {
        self.jwks_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_jwks_uri(&mut self, v: ::std::string::String) {
        self.jwks_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jwks_uri(&mut self) -> &mut ::std::string::String {
        &mut self.jwks_uri
    }

    // Take field
    pub fn take_jwks_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.jwks_uri, ::std::string::String::new())
    }

    // string logo_uri = 16;


    pub fn get_logo_uri(&self) -> &str {
        &self.logo_uri
    }
    pub fn clear_logo_uri(&mut self) {
        self.logo_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_logo_uri(&mut self, v: ::std::string::String) {
        self.logo_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logo_uri(&mut self) -> &mut ::std::string::String {
        &mut self.logo_uri
    }

    // Take field
    pub fn take_logo_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logo_uri, ::std::string::String::new())
    }

    // .google.protobuf.Struct metadata = 17;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string owner = 18;


    pub fn get_owner(&self) -> &str {
        &self.owner
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        &mut self.owner
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.owner, ::std::string::String::new())
    }

    // string policy_uri = 19;


    pub fn get_policy_uri(&self) -> &str {
        &self.policy_uri
    }
    pub fn clear_policy_uri(&mut self) {
        self.policy_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_policy_uri(&mut self, v: ::std::string::String) {
        self.policy_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policy_uri(&mut self) -> &mut ::std::string::String {
        &mut self.policy_uri
    }

    // Take field
    pub fn take_policy_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.policy_uri, ::std::string::String::new())
    }

    // repeated string post_logout_redirect_uris = 20;


    pub fn get_post_logout_redirect_uris(&self) -> &[::std::string::String] {
        &self.post_logout_redirect_uris
    }
    pub fn clear_post_logout_redirect_uris(&mut self) {
        self.post_logout_redirect_uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_post_logout_redirect_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.post_logout_redirect_uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_post_logout_redirect_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.post_logout_redirect_uris
    }

    // Take field
    pub fn take_post_logout_redirect_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.post_logout_redirect_uris, ::protobuf::RepeatedField::new())
    }

    // repeated string redirect_uris = 21;


    pub fn get_redirect_uris(&self) -> &[::std::string::String] {
        &self.redirect_uris
    }
    pub fn clear_redirect_uris(&mut self) {
        self.redirect_uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_redirect_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.redirect_uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_redirect_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.redirect_uris
    }

    // Take field
    pub fn take_redirect_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.redirect_uris, ::protobuf::RepeatedField::new())
    }

    // .depot.devtools.auth.v0.identity.admin.RequestObjectSigningAlg request_object_signing_alg = 22;


    pub fn get_request_object_signing_alg(&self) -> RequestObjectSigningAlg {
        self.request_object_signing_alg
    }
    pub fn clear_request_object_signing_alg(&mut self) {
        self.request_object_signing_alg = RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_request_object_signing_alg(&mut self, v: RequestObjectSigningAlg) {
        self.request_object_signing_alg = v;
    }

    // repeated string request_uris = 23;


    pub fn get_request_uris(&self) -> &[::std::string::String] {
        &self.request_uris
    }
    pub fn clear_request_uris(&mut self) {
        self.request_uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.request_uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.request_uris
    }

    // Take field
    pub fn take_request_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.request_uris, ::protobuf::RepeatedField::new())
    }

    // repeated .depot.devtools.auth.v0.identity.admin.ResponseType response_types = 24;


    pub fn get_response_types(&self) -> &[ResponseType] {
        &self.response_types
    }
    pub fn clear_response_types(&mut self) {
        self.response_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_types(&mut self, v: ::std::vec::Vec<ResponseType>) {
        self.response_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_types(&mut self) -> &mut ::std::vec::Vec<ResponseType> {
        &mut self.response_types
    }

    // Take field
    pub fn take_response_types(&mut self) -> ::std::vec::Vec<ResponseType> {
        ::std::mem::replace(&mut self.response_types, ::std::vec::Vec::new())
    }

    // string scope = 25;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // string sector_identifier_uri = 26;


    pub fn get_sector_identifier_uri(&self) -> &str {
        &self.sector_identifier_uri
    }
    pub fn clear_sector_identifier_uri(&mut self) {
        self.sector_identifier_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_sector_identifier_uri(&mut self, v: ::std::string::String) {
        self.sector_identifier_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sector_identifier_uri(&mut self) -> &mut ::std::string::String {
        &mut self.sector_identifier_uri
    }

    // Take field
    pub fn take_sector_identifier_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sector_identifier_uri, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.SubjectType subject_type = 27;


    pub fn get_subject_type(&self) -> SubjectType {
        self.subject_type
    }
    pub fn clear_subject_type(&mut self) {
        self.subject_type = SubjectType::SUBJECT_TYPE_PUBLIC;
    }

    // Param is passed by value, moved
    pub fn set_subject_type(&mut self, v: SubjectType) {
        self.subject_type = v;
    }

    // .depot.devtools.auth.v0.identity.admin.TokenEndpointAuthMethod token_endpoint_auth_method = 28;


    pub fn get_token_endpoint_auth_method(&self) -> TokenEndpointAuthMethod {
        self.token_endpoint_auth_method
    }
    pub fn clear_token_endpoint_auth_method(&mut self) {
        self.token_endpoint_auth_method = TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC;
    }

    // Param is passed by value, moved
    pub fn set_token_endpoint_auth_method(&mut self, v: TokenEndpointAuthMethod) {
        self.token_endpoint_auth_method = v;
    }

    // .depot.devtools.auth.v0.identity.admin.TokenEndpointAuthSigningAlg token_endpoint_auth_signing_alg = 29;


    pub fn get_token_endpoint_auth_signing_alg(&self) -> TokenEndpointAuthSigningAlg {
        self.token_endpoint_auth_signing_alg
    }
    pub fn clear_token_endpoint_auth_signing_alg(&mut self) {
        self.token_endpoint_auth_signing_alg = TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_token_endpoint_auth_signing_alg(&mut self, v: TokenEndpointAuthSigningAlg) {
        self.token_endpoint_auth_signing_alg = v;
    }

    // string tos_uri = 30;


    pub fn get_tos_uri(&self) -> &str {
        &self.tos_uri
    }
    pub fn clear_tos_uri(&mut self) {
        self.tos_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_tos_uri(&mut self, v: ::std::string::String) {
        self.tos_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tos_uri(&mut self) -> &mut ::std::string::String {
        &mut self.tos_uri
    }

    // Take field
    pub fn take_tos_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tos_uri, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.UserinfoSignedResponseAlg userinfo_signed_response_alg = 31;


    pub fn get_userinfo_signed_response_alg(&self) -> UserinfoSignedResponseAlg {
        self.userinfo_signed_response_alg
    }
    pub fn clear_userinfo_signed_response_alg(&mut self) {
        self.userinfo_signed_response_alg = UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_userinfo_signed_response_alg(&mut self, v: UserinfoSignedResponseAlg) {
        self.userinfo_signed_response_alg = v;
    }

    // string client_secret = 32;


    pub fn get_client_secret(&self) -> &str {
        &self.client_secret
    }
    pub fn clear_client_secret(&mut self) {
        self.client_secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_secret(&mut self, v: ::std::string::String) {
        self.client_secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_secret(&mut self) -> &mut ::std::string::String {
        &mut self.client_secret
    }

    // Take field
    pub fn take_client_secret(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_secret, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.ClientType client_type = 33;


    pub fn get_client_type(&self) -> ClientType {
        self.client_type
    }
    pub fn clear_client_type(&mut self) {
        self.client_type = ClientType::CLIENT_TYPE_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_client_type(&mut self, v: ClientType) {
        self.client_type = v;
    }
}

impl ::protobuf::Message for CreateOAuth2ClientRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.jwks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allowed_cors_origins)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.audience)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.backchannel_logout_session_required = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backchannel_logout_uri)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_name)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_uri)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.contacts)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.frontchannel_logout_session_required = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.frontchannel_logout_uri)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.grant_types, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jwks)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.jwks_uri)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logo_uri)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.owner)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.policy_uri)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.post_logout_redirect_uris)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.redirect_uris)?;
                },
                22 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.request_object_signing_alg, 22, &mut self.unknown_fields)?
                },
                23 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.request_uris)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.response_types, 24, &mut self.unknown_fields)?
                },
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sector_identifier_uri)?;
                },
                27 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.subject_type, 27, &mut self.unknown_fields)?
                },
                28 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.token_endpoint_auth_method, 28, &mut self.unknown_fields)?
                },
                29 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.token_endpoint_auth_signing_alg, 29, &mut self.unknown_fields)?
                },
                30 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tos_uri)?;
                },
                31 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.userinfo_signed_response_alg, 31, &mut self.unknown_fields)?
                },
                32 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_secret)?;
                },
                33 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.client_type, 33, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allowed_cors_origins {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.audience {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.backchannel_logout_session_required != false {
            my_size += 2;
        }
        if !self.backchannel_logout_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.backchannel_logout_uri);
        }
        if !self.client_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.client_name);
        }
        if !self.client_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.client_uri);
        }
        for value in &self.contacts {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if self.frontchannel_logout_session_required != false {
            my_size += 2;
        }
        if !self.frontchannel_logout_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.frontchannel_logout_uri);
        }
        for value in &self.grant_types {
            my_size += ::protobuf::rt::enum_size(13, *value);
        };
        if let Some(ref v) = self.jwks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.jwks_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.jwks_uri);
        }
        if !self.logo_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.logo_uri);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.owner);
        }
        if !self.policy_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.policy_uri);
        }
        for value in &self.post_logout_redirect_uris {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.redirect_uris {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        if self.request_object_signing_alg != RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET {
            my_size += ::protobuf::rt::enum_size(22, self.request_object_signing_alg);
        }
        for value in &self.request_uris {
            my_size += ::protobuf::rt::string_size(23, &value);
        };
        for value in &self.response_types {
            my_size += ::protobuf::rt::enum_size(24, *value);
        };
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.scope);
        }
        if !self.sector_identifier_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.sector_identifier_uri);
        }
        if self.subject_type != SubjectType::SUBJECT_TYPE_PUBLIC {
            my_size += ::protobuf::rt::enum_size(27, self.subject_type);
        }
        if self.token_endpoint_auth_method != TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC {
            my_size += ::protobuf::rt::enum_size(28, self.token_endpoint_auth_method);
        }
        if self.token_endpoint_auth_signing_alg != TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET {
            my_size += ::protobuf::rt::enum_size(29, self.token_endpoint_auth_signing_alg);
        }
        if !self.tos_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.tos_uri);
        }
        if self.userinfo_signed_response_alg != UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET {
            my_size += ::protobuf::rt::enum_size(31, self.userinfo_signed_response_alg);
        }
        if !self.client_secret.is_empty() {
            my_size += ::protobuf::rt::string_size(32, &self.client_secret);
        }
        if self.client_type != ClientType::CLIENT_TYPE_UNSET {
            my_size += ::protobuf::rt::enum_size(33, self.client_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allowed_cors_origins {
            os.write_string(1, &v)?;
        };
        for v in &self.audience {
            os.write_string(2, &v)?;
        };
        if self.backchannel_logout_session_required != false {
            os.write_bool(3, self.backchannel_logout_session_required)?;
        }
        if !self.backchannel_logout_uri.is_empty() {
            os.write_string(4, &self.backchannel_logout_uri)?;
        }
        if !self.client_name.is_empty() {
            os.write_string(6, &self.client_name)?;
        }
        if !self.client_uri.is_empty() {
            os.write_string(8, &self.client_uri)?;
        }
        for v in &self.contacts {
            os.write_string(9, &v)?;
        };
        if self.frontchannel_logout_session_required != false {
            os.write_bool(11, self.frontchannel_logout_session_required)?;
        }
        if !self.frontchannel_logout_uri.is_empty() {
            os.write_string(12, &self.frontchannel_logout_uri)?;
        }
        for v in &self.grant_types {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(ref v) = self.jwks.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.jwks_uri.is_empty() {
            os.write_string(15, &self.jwks_uri)?;
        }
        if !self.logo_uri.is_empty() {
            os.write_string(16, &self.logo_uri)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.owner.is_empty() {
            os.write_string(18, &self.owner)?;
        }
        if !self.policy_uri.is_empty() {
            os.write_string(19, &self.policy_uri)?;
        }
        for v in &self.post_logout_redirect_uris {
            os.write_string(20, &v)?;
        };
        for v in &self.redirect_uris {
            os.write_string(21, &v)?;
        };
        if self.request_object_signing_alg != RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET {
            os.write_enum(22, ::protobuf::ProtobufEnum::value(&self.request_object_signing_alg))?;
        }
        for v in &self.request_uris {
            os.write_string(23, &v)?;
        };
        for v in &self.response_types {
            os.write_enum(24, ::protobuf::ProtobufEnum::value(v))?;
        };
        if !self.scope.is_empty() {
            os.write_string(25, &self.scope)?;
        }
        if !self.sector_identifier_uri.is_empty() {
            os.write_string(26, &self.sector_identifier_uri)?;
        }
        if self.subject_type != SubjectType::SUBJECT_TYPE_PUBLIC {
            os.write_enum(27, ::protobuf::ProtobufEnum::value(&self.subject_type))?;
        }
        if self.token_endpoint_auth_method != TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC {
            os.write_enum(28, ::protobuf::ProtobufEnum::value(&self.token_endpoint_auth_method))?;
        }
        if self.token_endpoint_auth_signing_alg != TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET {
            os.write_enum(29, ::protobuf::ProtobufEnum::value(&self.token_endpoint_auth_signing_alg))?;
        }
        if !self.tos_uri.is_empty() {
            os.write_string(30, &self.tos_uri)?;
        }
        if self.userinfo_signed_response_alg != UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET {
            os.write_enum(31, ::protobuf::ProtobufEnum::value(&self.userinfo_signed_response_alg))?;
        }
        if !self.client_secret.is_empty() {
            os.write_string(32, &self.client_secret)?;
        }
        if self.client_type != ClientType::CLIENT_TYPE_UNSET {
            os.write_enum(33, ::protobuf::ProtobufEnum::value(&self.client_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateOAuth2ClientRequest {
        CreateOAuth2ClientRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allowed_cors_origins",
                |m: &CreateOAuth2ClientRequest| { &m.allowed_cors_origins },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.allowed_cors_origins },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "audience",
                |m: &CreateOAuth2ClientRequest| { &m.audience },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.audience },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "backchannel_logout_session_required",
                |m: &CreateOAuth2ClientRequest| { &m.backchannel_logout_session_required },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.backchannel_logout_session_required },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backchannel_logout_uri",
                |m: &CreateOAuth2ClientRequest| { &m.backchannel_logout_uri },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.backchannel_logout_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_name",
                |m: &CreateOAuth2ClientRequest| { &m.client_name },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.client_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_uri",
                |m: &CreateOAuth2ClientRequest| { &m.client_uri },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.client_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contacts",
                |m: &CreateOAuth2ClientRequest| { &m.contacts },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.contacts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "frontchannel_logout_session_required",
                |m: &CreateOAuth2ClientRequest| { &m.frontchannel_logout_session_required },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.frontchannel_logout_session_required },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "frontchannel_logout_uri",
                |m: &CreateOAuth2ClientRequest| { &m.frontchannel_logout_uri },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.frontchannel_logout_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GrantType>>(
                "grant_types",
                |m: &CreateOAuth2ClientRequest| { &m.grant_types },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.grant_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "jwks",
                |m: &CreateOAuth2ClientRequest| { &m.jwks },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.jwks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "jwks_uri",
                |m: &CreateOAuth2ClientRequest| { &m.jwks_uri },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.jwks_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "logo_uri",
                |m: &CreateOAuth2ClientRequest| { &m.logo_uri },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.logo_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &CreateOAuth2ClientRequest| { &m.metadata },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "owner",
                |m: &CreateOAuth2ClientRequest| { &m.owner },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "policy_uri",
                |m: &CreateOAuth2ClientRequest| { &m.policy_uri },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.policy_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "post_logout_redirect_uris",
                |m: &CreateOAuth2ClientRequest| { &m.post_logout_redirect_uris },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.post_logout_redirect_uris },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "redirect_uris",
                |m: &CreateOAuth2ClientRequest| { &m.redirect_uris },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.redirect_uris },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RequestObjectSigningAlg>>(
                "request_object_signing_alg",
                |m: &CreateOAuth2ClientRequest| { &m.request_object_signing_alg },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.request_object_signing_alg },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "request_uris",
                |m: &CreateOAuth2ClientRequest| { &m.request_uris },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.request_uris },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseType>>(
                "response_types",
                |m: &CreateOAuth2ClientRequest| { &m.response_types },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.response_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &CreateOAuth2ClientRequest| { &m.scope },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sector_identifier_uri",
                |m: &CreateOAuth2ClientRequest| { &m.sector_identifier_uri },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.sector_identifier_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SubjectType>>(
                "subject_type",
                |m: &CreateOAuth2ClientRequest| { &m.subject_type },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.subject_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TokenEndpointAuthMethod>>(
                "token_endpoint_auth_method",
                |m: &CreateOAuth2ClientRequest| { &m.token_endpoint_auth_method },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.token_endpoint_auth_method },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TokenEndpointAuthSigningAlg>>(
                "token_endpoint_auth_signing_alg",
                |m: &CreateOAuth2ClientRequest| { &m.token_endpoint_auth_signing_alg },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.token_endpoint_auth_signing_alg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tos_uri",
                |m: &CreateOAuth2ClientRequest| { &m.tos_uri },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.tos_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UserinfoSignedResponseAlg>>(
                "userinfo_signed_response_alg",
                |m: &CreateOAuth2ClientRequest| { &m.userinfo_signed_response_alg },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.userinfo_signed_response_alg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_secret",
                |m: &CreateOAuth2ClientRequest| { &m.client_secret },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.client_secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ClientType>>(
                "client_type",
                |m: &CreateOAuth2ClientRequest| { &m.client_type },
                |m: &mut CreateOAuth2ClientRequest| { &mut m.client_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateOAuth2ClientRequest>(
                "CreateOAuth2ClientRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateOAuth2ClientRequest {
        static instance: ::protobuf::rt::LazyV2<CreateOAuth2ClientRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateOAuth2ClientRequest::new)
    }
}

impl ::protobuf::Clear for CreateOAuth2ClientRequest {
    fn clear(&mut self) {
        self.allowed_cors_origins.clear();
        self.audience.clear();
        self.backchannel_logout_session_required = false;
        self.backchannel_logout_uri.clear();
        self.client_name.clear();
        self.client_uri.clear();
        self.contacts.clear();
        self.frontchannel_logout_session_required = false;
        self.frontchannel_logout_uri.clear();
        self.grant_types.clear();
        self.jwks.clear();
        self.jwks_uri.clear();
        self.logo_uri.clear();
        self.metadata.clear();
        self.owner.clear();
        self.policy_uri.clear();
        self.post_logout_redirect_uris.clear();
        self.redirect_uris.clear();
        self.request_object_signing_alg = RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET;
        self.request_uris.clear();
        self.response_types.clear();
        self.scope.clear();
        self.sector_identifier_uri.clear();
        self.subject_type = SubjectType::SUBJECT_TYPE_PUBLIC;
        self.token_endpoint_auth_method = TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC;
        self.token_endpoint_auth_signing_alg = TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET;
        self.tos_uri.clear();
        self.userinfo_signed_response_alg = UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET;
        self.client_secret.clear();
        self.client_type = ClientType::CLIENT_TYPE_UNSET;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateOAuth2ClientRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateOAuth2ClientRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateOAuth2ClientResponse {
    // message fields
    pub client_id: ::std::string::String,
    pub client_secret: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateOAuth2ClientResponse {
    fn default() -> &'a CreateOAuth2ClientResponse {
        <CreateOAuth2ClientResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateOAuth2ClientResponse {
    pub fn new() -> CreateOAuth2ClientResponse {
        ::std::default::Default::default()
    }

    // string client_id = 1;


    pub fn get_client_id(&self) -> &str {
        &self.client_id
    }
    pub fn clear_client_id(&mut self) {
        self.client_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: ::std::string::String) {
        self.client_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_id(&mut self) -> &mut ::std::string::String {
        &mut self.client_id
    }

    // Take field
    pub fn take_client_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_id, ::std::string::String::new())
    }

    // string client_secret = 2;


    pub fn get_client_secret(&self) -> &str {
        &self.client_secret
    }
    pub fn clear_client_secret(&mut self) {
        self.client_secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_secret(&mut self, v: ::std::string::String) {
        self.client_secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_secret(&mut self) -> &mut ::std::string::String {
        &mut self.client_secret
    }

    // Take field
    pub fn take_client_secret(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_secret, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateOAuth2ClientResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_id);
        }
        if !self.client_secret.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.client_secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.client_id.is_empty() {
            os.write_string(1, &self.client_id)?;
        }
        if !self.client_secret.is_empty() {
            os.write_string(2, &self.client_secret)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateOAuth2ClientResponse {
        CreateOAuth2ClientResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_id",
                |m: &CreateOAuth2ClientResponse| { &m.client_id },
                |m: &mut CreateOAuth2ClientResponse| { &mut m.client_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_secret",
                |m: &CreateOAuth2ClientResponse| { &m.client_secret },
                |m: &mut CreateOAuth2ClientResponse| { &mut m.client_secret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateOAuth2ClientResponse>(
                "CreateOAuth2ClientResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateOAuth2ClientResponse {
        static instance: ::protobuf::rt::LazyV2<CreateOAuth2ClientResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateOAuth2ClientResponse::new)
    }
}

impl ::protobuf::Clear for CreateOAuth2ClientResponse {
    fn clear(&mut self) {
        self.client_id.clear();
        self.client_secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateOAuth2ClientResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateOAuth2ClientResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateOAuth2ClientRequest {
    // message fields
    pub allowed_cors_origins: ::protobuf::RepeatedField<::std::string::String>,
    pub audience: ::protobuf::RepeatedField<::std::string::String>,
    pub backchannel_logout_session_required: bool,
    pub backchannel_logout_uri: ::std::string::String,
    pub client_name: ::std::string::String,
    pub client_uri: ::std::string::String,
    pub contacts: ::protobuf::RepeatedField<::std::string::String>,
    pub frontchannel_logout_session_required: bool,
    pub frontchannel_logout_uri: ::std::string::String,
    pub grant_types: ::std::vec::Vec<GrantType>,
    pub jwks: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub jwks_uri: ::std::string::String,
    pub logo_uri: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub owner: ::std::string::String,
    pub policy_uri: ::std::string::String,
    pub post_logout_redirect_uris: ::protobuf::RepeatedField<::std::string::String>,
    pub redirect_uris: ::protobuf::RepeatedField<::std::string::String>,
    pub request_object_signing_alg: RequestObjectSigningAlg,
    pub request_uris: ::protobuf::RepeatedField<::std::string::String>,
    pub response_types: ::std::vec::Vec<ResponseType>,
    pub scope: ::std::string::String,
    pub sector_identifier_uri: ::std::string::String,
    pub subject_type: SubjectType,
    pub token_endpoint_auth_method: TokenEndpointAuthMethod,
    pub token_endpoint_auth_signing_alg: TokenEndpointAuthSigningAlg,
    pub tos_uri: ::std::string::String,
    pub userinfo_signed_response_alg: UserinfoSignedResponseAlg,
    pub client_secret: ::std::string::String,
    pub client_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateOAuth2ClientRequest {
    fn default() -> &'a UpdateOAuth2ClientRequest {
        <UpdateOAuth2ClientRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateOAuth2ClientRequest {
    pub fn new() -> UpdateOAuth2ClientRequest {
        ::std::default::Default::default()
    }

    // repeated string allowed_cors_origins = 1;


    pub fn get_allowed_cors_origins(&self) -> &[::std::string::String] {
        &self.allowed_cors_origins
    }
    pub fn clear_allowed_cors_origins(&mut self) {
        self.allowed_cors_origins.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowed_cors_origins(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allowed_cors_origins = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowed_cors_origins(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allowed_cors_origins
    }

    // Take field
    pub fn take_allowed_cors_origins(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allowed_cors_origins, ::protobuf::RepeatedField::new())
    }

    // repeated string audience = 2;


    pub fn get_audience(&self) -> &[::std::string::String] {
        &self.audience
    }
    pub fn clear_audience(&mut self) {
        self.audience.clear();
    }

    // Param is passed by value, moved
    pub fn set_audience(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.audience = v;
    }

    // Mutable pointer to the field.
    pub fn mut_audience(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.audience
    }

    // Take field
    pub fn take_audience(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.audience, ::protobuf::RepeatedField::new())
    }

    // bool backchannel_logout_session_required = 3;


    pub fn get_backchannel_logout_session_required(&self) -> bool {
        self.backchannel_logout_session_required
    }
    pub fn clear_backchannel_logout_session_required(&mut self) {
        self.backchannel_logout_session_required = false;
    }

    // Param is passed by value, moved
    pub fn set_backchannel_logout_session_required(&mut self, v: bool) {
        self.backchannel_logout_session_required = v;
    }

    // string backchannel_logout_uri = 4;


    pub fn get_backchannel_logout_uri(&self) -> &str {
        &self.backchannel_logout_uri
    }
    pub fn clear_backchannel_logout_uri(&mut self) {
        self.backchannel_logout_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_backchannel_logout_uri(&mut self, v: ::std::string::String) {
        self.backchannel_logout_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backchannel_logout_uri(&mut self) -> &mut ::std::string::String {
        &mut self.backchannel_logout_uri
    }

    // Take field
    pub fn take_backchannel_logout_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backchannel_logout_uri, ::std::string::String::new())
    }

    // string client_name = 6;


    pub fn get_client_name(&self) -> &str {
        &self.client_name
    }
    pub fn clear_client_name(&mut self) {
        self.client_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_name(&mut self, v: ::std::string::String) {
        self.client_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_name(&mut self) -> &mut ::std::string::String {
        &mut self.client_name
    }

    // Take field
    pub fn take_client_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_name, ::std::string::String::new())
    }

    // string client_uri = 8;


    pub fn get_client_uri(&self) -> &str {
        &self.client_uri
    }
    pub fn clear_client_uri(&mut self) {
        self.client_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_uri(&mut self, v: ::std::string::String) {
        self.client_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_uri(&mut self) -> &mut ::std::string::String {
        &mut self.client_uri
    }

    // Take field
    pub fn take_client_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_uri, ::std::string::String::new())
    }

    // repeated string contacts = 9;


    pub fn get_contacts(&self) -> &[::std::string::String] {
        &self.contacts
    }
    pub fn clear_contacts(&mut self) {
        self.contacts.clear();
    }

    // Param is passed by value, moved
    pub fn set_contacts(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.contacts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contacts(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.contacts
    }

    // Take field
    pub fn take_contacts(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.contacts, ::protobuf::RepeatedField::new())
    }

    // bool frontchannel_logout_session_required = 11;


    pub fn get_frontchannel_logout_session_required(&self) -> bool {
        self.frontchannel_logout_session_required
    }
    pub fn clear_frontchannel_logout_session_required(&mut self) {
        self.frontchannel_logout_session_required = false;
    }

    // Param is passed by value, moved
    pub fn set_frontchannel_logout_session_required(&mut self, v: bool) {
        self.frontchannel_logout_session_required = v;
    }

    // string frontchannel_logout_uri = 12;


    pub fn get_frontchannel_logout_uri(&self) -> &str {
        &self.frontchannel_logout_uri
    }
    pub fn clear_frontchannel_logout_uri(&mut self) {
        self.frontchannel_logout_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_frontchannel_logout_uri(&mut self, v: ::std::string::String) {
        self.frontchannel_logout_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frontchannel_logout_uri(&mut self) -> &mut ::std::string::String {
        &mut self.frontchannel_logout_uri
    }

    // Take field
    pub fn take_frontchannel_logout_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.frontchannel_logout_uri, ::std::string::String::new())
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GrantType grant_types = 13;


    pub fn get_grant_types(&self) -> &[GrantType] {
        &self.grant_types
    }
    pub fn clear_grant_types(&mut self) {
        self.grant_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_grant_types(&mut self, v: ::std::vec::Vec<GrantType>) {
        self.grant_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_grant_types(&mut self) -> &mut ::std::vec::Vec<GrantType> {
        &mut self.grant_types
    }

    // Take field
    pub fn take_grant_types(&mut self) -> ::std::vec::Vec<GrantType> {
        ::std::mem::replace(&mut self.grant_types, ::std::vec::Vec::new())
    }

    // .google.protobuf.Struct jwks = 14;


    pub fn get_jwks(&self) -> &::protobuf::well_known_types::Struct {
        self.jwks.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_jwks(&mut self) {
        self.jwks.clear();
    }

    pub fn has_jwks(&self) -> bool {
        self.jwks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jwks(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.jwks = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jwks(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.jwks.is_none() {
            self.jwks.set_default();
        }
        self.jwks.as_mut().unwrap()
    }

    // Take field
    pub fn take_jwks(&mut self) -> ::protobuf::well_known_types::Struct {
        self.jwks.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string jwks_uri = 15;


    pub fn get_jwks_uri(&self) -> &str {
        &self.jwks_uri
    }
    pub fn clear_jwks_uri(&mut self) {
        self.jwks_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_jwks_uri(&mut self, v: ::std::string::String) {
        self.jwks_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jwks_uri(&mut self) -> &mut ::std::string::String {
        &mut self.jwks_uri
    }

    // Take field
    pub fn take_jwks_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.jwks_uri, ::std::string::String::new())
    }

    // string logo_uri = 16;


    pub fn get_logo_uri(&self) -> &str {
        &self.logo_uri
    }
    pub fn clear_logo_uri(&mut self) {
        self.logo_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_logo_uri(&mut self, v: ::std::string::String) {
        self.logo_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logo_uri(&mut self) -> &mut ::std::string::String {
        &mut self.logo_uri
    }

    // Take field
    pub fn take_logo_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logo_uri, ::std::string::String::new())
    }

    // .google.protobuf.Struct metadata = 17;


    pub fn get_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // string owner = 18;


    pub fn get_owner(&self) -> &str {
        &self.owner
    }
    pub fn clear_owner(&mut self) {
        self.owner.clear();
    }

    // Param is passed by value, moved
    pub fn set_owner(&mut self, v: ::std::string::String) {
        self.owner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_owner(&mut self) -> &mut ::std::string::String {
        &mut self.owner
    }

    // Take field
    pub fn take_owner(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.owner, ::std::string::String::new())
    }

    // string policy_uri = 19;


    pub fn get_policy_uri(&self) -> &str {
        &self.policy_uri
    }
    pub fn clear_policy_uri(&mut self) {
        self.policy_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_policy_uri(&mut self, v: ::std::string::String) {
        self.policy_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_policy_uri(&mut self) -> &mut ::std::string::String {
        &mut self.policy_uri
    }

    // Take field
    pub fn take_policy_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.policy_uri, ::std::string::String::new())
    }

    // repeated string post_logout_redirect_uris = 20;


    pub fn get_post_logout_redirect_uris(&self) -> &[::std::string::String] {
        &self.post_logout_redirect_uris
    }
    pub fn clear_post_logout_redirect_uris(&mut self) {
        self.post_logout_redirect_uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_post_logout_redirect_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.post_logout_redirect_uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_post_logout_redirect_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.post_logout_redirect_uris
    }

    // Take field
    pub fn take_post_logout_redirect_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.post_logout_redirect_uris, ::protobuf::RepeatedField::new())
    }

    // repeated string redirect_uris = 21;


    pub fn get_redirect_uris(&self) -> &[::std::string::String] {
        &self.redirect_uris
    }
    pub fn clear_redirect_uris(&mut self) {
        self.redirect_uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_redirect_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.redirect_uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_redirect_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.redirect_uris
    }

    // Take field
    pub fn take_redirect_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.redirect_uris, ::protobuf::RepeatedField::new())
    }

    // .depot.devtools.auth.v0.identity.admin.RequestObjectSigningAlg request_object_signing_alg = 22;


    pub fn get_request_object_signing_alg(&self) -> RequestObjectSigningAlg {
        self.request_object_signing_alg
    }
    pub fn clear_request_object_signing_alg(&mut self) {
        self.request_object_signing_alg = RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_request_object_signing_alg(&mut self, v: RequestObjectSigningAlg) {
        self.request_object_signing_alg = v;
    }

    // repeated string request_uris = 23;


    pub fn get_request_uris(&self) -> &[::std::string::String] {
        &self.request_uris
    }
    pub fn clear_request_uris(&mut self) {
        self.request_uris.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_uris(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.request_uris = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_uris(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.request_uris
    }

    // Take field
    pub fn take_request_uris(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.request_uris, ::protobuf::RepeatedField::new())
    }

    // repeated .depot.devtools.auth.v0.identity.admin.ResponseType response_types = 24;


    pub fn get_response_types(&self) -> &[ResponseType] {
        &self.response_types
    }
    pub fn clear_response_types(&mut self) {
        self.response_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_types(&mut self, v: ::std::vec::Vec<ResponseType>) {
        self.response_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_types(&mut self) -> &mut ::std::vec::Vec<ResponseType> {
        &mut self.response_types
    }

    // Take field
    pub fn take_response_types(&mut self) -> ::std::vec::Vec<ResponseType> {
        ::std::mem::replace(&mut self.response_types, ::std::vec::Vec::new())
    }

    // string scope = 25;


    pub fn get_scope(&self) -> &str {
        &self.scope
    }
    pub fn clear_scope(&mut self) {
        self.scope.clear();
    }

    // Param is passed by value, moved
    pub fn set_scope(&mut self, v: ::std::string::String) {
        self.scope = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scope(&mut self) -> &mut ::std::string::String {
        &mut self.scope
    }

    // Take field
    pub fn take_scope(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.scope, ::std::string::String::new())
    }

    // string sector_identifier_uri = 26;


    pub fn get_sector_identifier_uri(&self) -> &str {
        &self.sector_identifier_uri
    }
    pub fn clear_sector_identifier_uri(&mut self) {
        self.sector_identifier_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_sector_identifier_uri(&mut self, v: ::std::string::String) {
        self.sector_identifier_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sector_identifier_uri(&mut self) -> &mut ::std::string::String {
        &mut self.sector_identifier_uri
    }

    // Take field
    pub fn take_sector_identifier_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sector_identifier_uri, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.SubjectType subject_type = 27;


    pub fn get_subject_type(&self) -> SubjectType {
        self.subject_type
    }
    pub fn clear_subject_type(&mut self) {
        self.subject_type = SubjectType::SUBJECT_TYPE_PUBLIC;
    }

    // Param is passed by value, moved
    pub fn set_subject_type(&mut self, v: SubjectType) {
        self.subject_type = v;
    }

    // .depot.devtools.auth.v0.identity.admin.TokenEndpointAuthMethod token_endpoint_auth_method = 28;


    pub fn get_token_endpoint_auth_method(&self) -> TokenEndpointAuthMethod {
        self.token_endpoint_auth_method
    }
    pub fn clear_token_endpoint_auth_method(&mut self) {
        self.token_endpoint_auth_method = TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC;
    }

    // Param is passed by value, moved
    pub fn set_token_endpoint_auth_method(&mut self, v: TokenEndpointAuthMethod) {
        self.token_endpoint_auth_method = v;
    }

    // .depot.devtools.auth.v0.identity.admin.TokenEndpointAuthSigningAlg token_endpoint_auth_signing_alg = 29;


    pub fn get_token_endpoint_auth_signing_alg(&self) -> TokenEndpointAuthSigningAlg {
        self.token_endpoint_auth_signing_alg
    }
    pub fn clear_token_endpoint_auth_signing_alg(&mut self) {
        self.token_endpoint_auth_signing_alg = TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_token_endpoint_auth_signing_alg(&mut self, v: TokenEndpointAuthSigningAlg) {
        self.token_endpoint_auth_signing_alg = v;
    }

    // string tos_uri = 30;


    pub fn get_tos_uri(&self) -> &str {
        &self.tos_uri
    }
    pub fn clear_tos_uri(&mut self) {
        self.tos_uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_tos_uri(&mut self, v: ::std::string::String) {
        self.tos_uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tos_uri(&mut self) -> &mut ::std::string::String {
        &mut self.tos_uri
    }

    // Take field
    pub fn take_tos_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tos_uri, ::std::string::String::new())
    }

    // .depot.devtools.auth.v0.identity.admin.UserinfoSignedResponseAlg userinfo_signed_response_alg = 31;


    pub fn get_userinfo_signed_response_alg(&self) -> UserinfoSignedResponseAlg {
        self.userinfo_signed_response_alg
    }
    pub fn clear_userinfo_signed_response_alg(&mut self) {
        self.userinfo_signed_response_alg = UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET;
    }

    // Param is passed by value, moved
    pub fn set_userinfo_signed_response_alg(&mut self, v: UserinfoSignedResponseAlg) {
        self.userinfo_signed_response_alg = v;
    }

    // string client_secret = 32;


    pub fn get_client_secret(&self) -> &str {
        &self.client_secret
    }
    pub fn clear_client_secret(&mut self) {
        self.client_secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_secret(&mut self, v: ::std::string::String) {
        self.client_secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_secret(&mut self) -> &mut ::std::string::String {
        &mut self.client_secret
    }

    // Take field
    pub fn take_client_secret(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_secret, ::std::string::String::new())
    }

    // string client_id = 33;


    pub fn get_client_id(&self) -> &str {
        &self.client_id
    }
    pub fn clear_client_id(&mut self) {
        self.client_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: ::std::string::String) {
        self.client_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_id(&mut self) -> &mut ::std::string::String {
        &mut self.client_id
    }

    // Take field
    pub fn take_client_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateOAuth2ClientRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.jwks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allowed_cors_origins)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.audience)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.backchannel_logout_session_required = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backchannel_logout_uri)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_name)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_uri)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.contacts)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.frontchannel_logout_session_required = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.frontchannel_logout_uri)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.grant_types, 13, &mut self.unknown_fields)?
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.jwks)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.jwks_uri)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logo_uri)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.owner)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.policy_uri)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.post_logout_redirect_uris)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.redirect_uris)?;
                },
                22 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.request_object_signing_alg, 22, &mut self.unknown_fields)?
                },
                23 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.request_uris)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.response_types, 24, &mut self.unknown_fields)?
                },
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.scope)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sector_identifier_uri)?;
                },
                27 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.subject_type, 27, &mut self.unknown_fields)?
                },
                28 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.token_endpoint_auth_method, 28, &mut self.unknown_fields)?
                },
                29 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.token_endpoint_auth_signing_alg, 29, &mut self.unknown_fields)?
                },
                30 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tos_uri)?;
                },
                31 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.userinfo_signed_response_alg, 31, &mut self.unknown_fields)?
                },
                32 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_secret)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allowed_cors_origins {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.audience {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.backchannel_logout_session_required != false {
            my_size += 2;
        }
        if !self.backchannel_logout_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.backchannel_logout_uri);
        }
        if !self.client_name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.client_name);
        }
        if !self.client_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.client_uri);
        }
        for value in &self.contacts {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if self.frontchannel_logout_session_required != false {
            my_size += 2;
        }
        if !self.frontchannel_logout_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.frontchannel_logout_uri);
        }
        for value in &self.grant_types {
            my_size += ::protobuf::rt::enum_size(13, *value);
        };
        if let Some(ref v) = self.jwks.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.jwks_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.jwks_uri);
        }
        if !self.logo_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.logo_uri);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.owner.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.owner);
        }
        if !self.policy_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.policy_uri);
        }
        for value in &self.post_logout_redirect_uris {
            my_size += ::protobuf::rt::string_size(20, &value);
        };
        for value in &self.redirect_uris {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        if self.request_object_signing_alg != RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET {
            my_size += ::protobuf::rt::enum_size(22, self.request_object_signing_alg);
        }
        for value in &self.request_uris {
            my_size += ::protobuf::rt::string_size(23, &value);
        };
        for value in &self.response_types {
            my_size += ::protobuf::rt::enum_size(24, *value);
        };
        if !self.scope.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.scope);
        }
        if !self.sector_identifier_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.sector_identifier_uri);
        }
        if self.subject_type != SubjectType::SUBJECT_TYPE_PUBLIC {
            my_size += ::protobuf::rt::enum_size(27, self.subject_type);
        }
        if self.token_endpoint_auth_method != TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC {
            my_size += ::protobuf::rt::enum_size(28, self.token_endpoint_auth_method);
        }
        if self.token_endpoint_auth_signing_alg != TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET {
            my_size += ::protobuf::rt::enum_size(29, self.token_endpoint_auth_signing_alg);
        }
        if !self.tos_uri.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.tos_uri);
        }
        if self.userinfo_signed_response_alg != UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET {
            my_size += ::protobuf::rt::enum_size(31, self.userinfo_signed_response_alg);
        }
        if !self.client_secret.is_empty() {
            my_size += ::protobuf::rt::string_size(32, &self.client_secret);
        }
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(33, &self.client_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allowed_cors_origins {
            os.write_string(1, &v)?;
        };
        for v in &self.audience {
            os.write_string(2, &v)?;
        };
        if self.backchannel_logout_session_required != false {
            os.write_bool(3, self.backchannel_logout_session_required)?;
        }
        if !self.backchannel_logout_uri.is_empty() {
            os.write_string(4, &self.backchannel_logout_uri)?;
        }
        if !self.client_name.is_empty() {
            os.write_string(6, &self.client_name)?;
        }
        if !self.client_uri.is_empty() {
            os.write_string(8, &self.client_uri)?;
        }
        for v in &self.contacts {
            os.write_string(9, &v)?;
        };
        if self.frontchannel_logout_session_required != false {
            os.write_bool(11, self.frontchannel_logout_session_required)?;
        }
        if !self.frontchannel_logout_uri.is_empty() {
            os.write_string(12, &self.frontchannel_logout_uri)?;
        }
        for v in &self.grant_types {
            os.write_enum(13, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(ref v) = self.jwks.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.jwks_uri.is_empty() {
            os.write_string(15, &self.jwks_uri)?;
        }
        if !self.logo_uri.is_empty() {
            os.write_string(16, &self.logo_uri)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.owner.is_empty() {
            os.write_string(18, &self.owner)?;
        }
        if !self.policy_uri.is_empty() {
            os.write_string(19, &self.policy_uri)?;
        }
        for v in &self.post_logout_redirect_uris {
            os.write_string(20, &v)?;
        };
        for v in &self.redirect_uris {
            os.write_string(21, &v)?;
        };
        if self.request_object_signing_alg != RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET {
            os.write_enum(22, ::protobuf::ProtobufEnum::value(&self.request_object_signing_alg))?;
        }
        for v in &self.request_uris {
            os.write_string(23, &v)?;
        };
        for v in &self.response_types {
            os.write_enum(24, ::protobuf::ProtobufEnum::value(v))?;
        };
        if !self.scope.is_empty() {
            os.write_string(25, &self.scope)?;
        }
        if !self.sector_identifier_uri.is_empty() {
            os.write_string(26, &self.sector_identifier_uri)?;
        }
        if self.subject_type != SubjectType::SUBJECT_TYPE_PUBLIC {
            os.write_enum(27, ::protobuf::ProtobufEnum::value(&self.subject_type))?;
        }
        if self.token_endpoint_auth_method != TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC {
            os.write_enum(28, ::protobuf::ProtobufEnum::value(&self.token_endpoint_auth_method))?;
        }
        if self.token_endpoint_auth_signing_alg != TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET {
            os.write_enum(29, ::protobuf::ProtobufEnum::value(&self.token_endpoint_auth_signing_alg))?;
        }
        if !self.tos_uri.is_empty() {
            os.write_string(30, &self.tos_uri)?;
        }
        if self.userinfo_signed_response_alg != UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET {
            os.write_enum(31, ::protobuf::ProtobufEnum::value(&self.userinfo_signed_response_alg))?;
        }
        if !self.client_secret.is_empty() {
            os.write_string(32, &self.client_secret)?;
        }
        if !self.client_id.is_empty() {
            os.write_string(33, &self.client_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateOAuth2ClientRequest {
        UpdateOAuth2ClientRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allowed_cors_origins",
                |m: &UpdateOAuth2ClientRequest| { &m.allowed_cors_origins },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.allowed_cors_origins },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "audience",
                |m: &UpdateOAuth2ClientRequest| { &m.audience },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.audience },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "backchannel_logout_session_required",
                |m: &UpdateOAuth2ClientRequest| { &m.backchannel_logout_session_required },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.backchannel_logout_session_required },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backchannel_logout_uri",
                |m: &UpdateOAuth2ClientRequest| { &m.backchannel_logout_uri },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.backchannel_logout_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_name",
                |m: &UpdateOAuth2ClientRequest| { &m.client_name },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.client_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_uri",
                |m: &UpdateOAuth2ClientRequest| { &m.client_uri },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.client_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "contacts",
                |m: &UpdateOAuth2ClientRequest| { &m.contacts },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.contacts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "frontchannel_logout_session_required",
                |m: &UpdateOAuth2ClientRequest| { &m.frontchannel_logout_session_required },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.frontchannel_logout_session_required },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "frontchannel_logout_uri",
                |m: &UpdateOAuth2ClientRequest| { &m.frontchannel_logout_uri },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.frontchannel_logout_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GrantType>>(
                "grant_types",
                |m: &UpdateOAuth2ClientRequest| { &m.grant_types },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.grant_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "jwks",
                |m: &UpdateOAuth2ClientRequest| { &m.jwks },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.jwks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "jwks_uri",
                |m: &UpdateOAuth2ClientRequest| { &m.jwks_uri },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.jwks_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "logo_uri",
                |m: &UpdateOAuth2ClientRequest| { &m.logo_uri },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.logo_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "metadata",
                |m: &UpdateOAuth2ClientRequest| { &m.metadata },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "owner",
                |m: &UpdateOAuth2ClientRequest| { &m.owner },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.owner },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "policy_uri",
                |m: &UpdateOAuth2ClientRequest| { &m.policy_uri },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.policy_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "post_logout_redirect_uris",
                |m: &UpdateOAuth2ClientRequest| { &m.post_logout_redirect_uris },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.post_logout_redirect_uris },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "redirect_uris",
                |m: &UpdateOAuth2ClientRequest| { &m.redirect_uris },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.redirect_uris },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RequestObjectSigningAlg>>(
                "request_object_signing_alg",
                |m: &UpdateOAuth2ClientRequest| { &m.request_object_signing_alg },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.request_object_signing_alg },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "request_uris",
                |m: &UpdateOAuth2ClientRequest| { &m.request_uris },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.request_uris },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseType>>(
                "response_types",
                |m: &UpdateOAuth2ClientRequest| { &m.response_types },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.response_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scope",
                |m: &UpdateOAuth2ClientRequest| { &m.scope },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.scope },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sector_identifier_uri",
                |m: &UpdateOAuth2ClientRequest| { &m.sector_identifier_uri },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.sector_identifier_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SubjectType>>(
                "subject_type",
                |m: &UpdateOAuth2ClientRequest| { &m.subject_type },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.subject_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TokenEndpointAuthMethod>>(
                "token_endpoint_auth_method",
                |m: &UpdateOAuth2ClientRequest| { &m.token_endpoint_auth_method },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.token_endpoint_auth_method },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TokenEndpointAuthSigningAlg>>(
                "token_endpoint_auth_signing_alg",
                |m: &UpdateOAuth2ClientRequest| { &m.token_endpoint_auth_signing_alg },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.token_endpoint_auth_signing_alg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tos_uri",
                |m: &UpdateOAuth2ClientRequest| { &m.tos_uri },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.tos_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UserinfoSignedResponseAlg>>(
                "userinfo_signed_response_alg",
                |m: &UpdateOAuth2ClientRequest| { &m.userinfo_signed_response_alg },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.userinfo_signed_response_alg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_secret",
                |m: &UpdateOAuth2ClientRequest| { &m.client_secret },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.client_secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_id",
                |m: &UpdateOAuth2ClientRequest| { &m.client_id },
                |m: &mut UpdateOAuth2ClientRequest| { &mut m.client_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateOAuth2ClientRequest>(
                "UpdateOAuth2ClientRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateOAuth2ClientRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateOAuth2ClientRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateOAuth2ClientRequest::new)
    }
}

impl ::protobuf::Clear for UpdateOAuth2ClientRequest {
    fn clear(&mut self) {
        self.allowed_cors_origins.clear();
        self.audience.clear();
        self.backchannel_logout_session_required = false;
        self.backchannel_logout_uri.clear();
        self.client_name.clear();
        self.client_uri.clear();
        self.contacts.clear();
        self.frontchannel_logout_session_required = false;
        self.frontchannel_logout_uri.clear();
        self.grant_types.clear();
        self.jwks.clear();
        self.jwks_uri.clear();
        self.logo_uri.clear();
        self.metadata.clear();
        self.owner.clear();
        self.policy_uri.clear();
        self.post_logout_redirect_uris.clear();
        self.redirect_uris.clear();
        self.request_object_signing_alg = RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET;
        self.request_uris.clear();
        self.response_types.clear();
        self.scope.clear();
        self.sector_identifier_uri.clear();
        self.subject_type = SubjectType::SUBJECT_TYPE_PUBLIC;
        self.token_endpoint_auth_method = TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC;
        self.token_endpoint_auth_signing_alg = TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET;
        self.tos_uri.clear();
        self.userinfo_signed_response_alg = UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET;
        self.client_secret.clear();
        self.client_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateOAuth2ClientRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateOAuth2ClientRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateOAuth2ClientResponse {
    // message fields
    pub client_id: ::std::string::String,
    pub client_secret: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateOAuth2ClientResponse {
    fn default() -> &'a UpdateOAuth2ClientResponse {
        <UpdateOAuth2ClientResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateOAuth2ClientResponse {
    pub fn new() -> UpdateOAuth2ClientResponse {
        ::std::default::Default::default()
    }

    // string client_id = 1;


    pub fn get_client_id(&self) -> &str {
        &self.client_id
    }
    pub fn clear_client_id(&mut self) {
        self.client_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: ::std::string::String) {
        self.client_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_id(&mut self) -> &mut ::std::string::String {
        &mut self.client_id
    }

    // Take field
    pub fn take_client_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_id, ::std::string::String::new())
    }

    // string client_secret = 2;


    pub fn get_client_secret(&self) -> &str {
        &self.client_secret
    }
    pub fn clear_client_secret(&mut self) {
        self.client_secret.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_secret(&mut self, v: ::std::string::String) {
        self.client_secret = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_secret(&mut self) -> &mut ::std::string::String {
        &mut self.client_secret
    }

    // Take field
    pub fn take_client_secret(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_secret, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateOAuth2ClientResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_id);
        }
        if !self.client_secret.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.client_secret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.client_id.is_empty() {
            os.write_string(1, &self.client_id)?;
        }
        if !self.client_secret.is_empty() {
            os.write_string(2, &self.client_secret)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateOAuth2ClientResponse {
        UpdateOAuth2ClientResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_id",
                |m: &UpdateOAuth2ClientResponse| { &m.client_id },
                |m: &mut UpdateOAuth2ClientResponse| { &mut m.client_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_secret",
                |m: &UpdateOAuth2ClientResponse| { &m.client_secret },
                |m: &mut UpdateOAuth2ClientResponse| { &mut m.client_secret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateOAuth2ClientResponse>(
                "UpdateOAuth2ClientResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateOAuth2ClientResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateOAuth2ClientResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateOAuth2ClientResponse::new)
    }
}

impl ::protobuf::Clear for UpdateOAuth2ClientResponse {
    fn clear(&mut self) {
        self.client_id.clear();
        self.client_secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateOAuth2ClientResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateOAuth2ClientResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteOAuth2ClientRequest {
    // message fields
    pub client_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteOAuth2ClientRequest {
    fn default() -> &'a DeleteOAuth2ClientRequest {
        <DeleteOAuth2ClientRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteOAuth2ClientRequest {
    pub fn new() -> DeleteOAuth2ClientRequest {
        ::std::default::Default::default()
    }

    // string client_id = 1;


    pub fn get_client_id(&self) -> &str {
        &self.client_id
    }
    pub fn clear_client_id(&mut self) {
        self.client_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: ::std::string::String) {
        self.client_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_id(&mut self) -> &mut ::std::string::String {
        &mut self.client_id
    }

    // Take field
    pub fn take_client_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteOAuth2ClientRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.client_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.client_id.is_empty() {
            os.write_string(1, &self.client_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteOAuth2ClientRequest {
        DeleteOAuth2ClientRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_id",
                |m: &DeleteOAuth2ClientRequest| { &m.client_id },
                |m: &mut DeleteOAuth2ClientRequest| { &mut m.client_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteOAuth2ClientRequest>(
                "DeleteOAuth2ClientRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteOAuth2ClientRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteOAuth2ClientRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteOAuth2ClientRequest::new)
    }
}

impl ::protobuf::Clear for DeleteOAuth2ClientRequest {
    fn clear(&mut self) {
        self.client_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteOAuth2ClientRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteOAuth2ClientRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteOAuth2ClientResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteOAuth2ClientResponse {
    fn default() -> &'a DeleteOAuth2ClientResponse {
        <DeleteOAuth2ClientResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteOAuth2ClientResponse {
    pub fn new() -> DeleteOAuth2ClientResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteOAuth2ClientResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteOAuth2ClientResponse {
        DeleteOAuth2ClientResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteOAuth2ClientResponse>(
                "DeleteOAuth2ClientResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteOAuth2ClientResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteOAuth2ClientResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteOAuth2ClientResponse::new)
    }
}

impl ::protobuf::Clear for DeleteOAuth2ClientResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteOAuth2ClientResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteOAuth2ClientResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAddressesRequest {
    // message fields
    pub identity_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAddressesRequest {
    fn default() -> &'a GetAddressesRequest {
        <GetAddressesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAddressesRequest {
    pub fn new() -> GetAddressesRequest {
        ::std::default::Default::default()
    }

    // string identity_id = 1;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAddressesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(1, &self.identity_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAddressesRequest {
        GetAddressesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetAddressesRequest| { &m.identity_id },
                |m: &mut GetAddressesRequest| { &mut m.identity_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAddressesRequest>(
                "GetAddressesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAddressesRequest {
        static instance: ::protobuf::rt::LazyV2<GetAddressesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAddressesRequest::new)
    }
}

impl ::protobuf::Clear for GetAddressesRequest {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAddressesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAddressesResponse {
    // message fields
    pub addresses: ::protobuf::RepeatedField<GetAddressesResponse_Address>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAddressesResponse {
    fn default() -> &'a GetAddressesResponse {
        <GetAddressesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAddressesResponse {
    pub fn new() -> GetAddressesResponse {
        ::std::default::Default::default()
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetAddressesResponse.Address addresses = 1;


    pub fn get_addresses(&self) -> &[GetAddressesResponse_Address] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<GetAddressesResponse_Address>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<GetAddressesResponse_Address> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<GetAddressesResponse_Address> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetAddressesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addresses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.addresses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAddressesResponse {
        GetAddressesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetAddressesResponse_Address>>(
                "addresses",
                |m: &GetAddressesResponse| { &m.addresses },
                |m: &mut GetAddressesResponse| { &mut m.addresses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAddressesResponse>(
                "GetAddressesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAddressesResponse {
        static instance: ::protobuf::rt::LazyV2<GetAddressesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAddressesResponse::new)
    }
}

impl ::protobuf::Clear for GetAddressesResponse {
    fn clear(&mut self) {
        self.addresses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAddressesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAddressesResponse_Address {
    // message fields
    pub id: ::std::string::String,
    pub identity_id: ::std::string::String,
    pub name: ::std::string::String,
    pub address: ::std::string::String,
    pub verified: bool,
    pub id_schema_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAddressesResponse_Address {
    fn default() -> &'a GetAddressesResponse_Address {
        <GetAddressesResponse_Address as ::protobuf::Message>::default_instance()
    }
}

impl GetAddressesResponse_Address {
    pub fn new() -> GetAddressesResponse_Address {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string identity_id = 2;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string address = 4;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // bool verified = 5;


    pub fn get_verified(&self) -> bool {
        self.verified
    }
    pub fn clear_verified(&mut self) {
        self.verified = false;
    }

    // Param is passed by value, moved
    pub fn set_verified(&mut self, v: bool) {
        self.verified = v;
    }

    // string id_schema_key = 6;


    pub fn get_id_schema_key(&self) -> &str {
        &self.id_schema_key
    }
    pub fn clear_id_schema_key(&mut self) {
        self.id_schema_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_id_schema_key(&mut self, v: ::std::string::String) {
        self.id_schema_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id_schema_key(&mut self) -> &mut ::std::string::String {
        &mut self.id_schema_key
    }

    // Take field
    pub fn take_id_schema_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id_schema_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAddressesResponse_Address {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.verified = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id_schema_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identity_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.address);
        }
        if self.verified != false {
            my_size += 2;
        }
        if !self.id_schema_key.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.id_schema_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.identity_id.is_empty() {
            os.write_string(2, &self.identity_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.address.is_empty() {
            os.write_string(4, &self.address)?;
        }
        if self.verified != false {
            os.write_bool(5, self.verified)?;
        }
        if !self.id_schema_key.is_empty() {
            os.write_string(6, &self.id_schema_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAddressesResponse_Address {
        GetAddressesResponse_Address::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetAddressesResponse_Address| { &m.id },
                |m: &mut GetAddressesResponse_Address| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetAddressesResponse_Address| { &m.identity_id },
                |m: &mut GetAddressesResponse_Address| { &mut m.identity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetAddressesResponse_Address| { &m.name },
                |m: &mut GetAddressesResponse_Address| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &GetAddressesResponse_Address| { &m.address },
                |m: &mut GetAddressesResponse_Address| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "verified",
                |m: &GetAddressesResponse_Address| { &m.verified },
                |m: &mut GetAddressesResponse_Address| { &mut m.verified },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id_schema_key",
                |m: &GetAddressesResponse_Address| { &m.id_schema_key },
                |m: &mut GetAddressesResponse_Address| { &mut m.id_schema_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAddressesResponse_Address>(
                "GetAddressesResponse.Address",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAddressesResponse_Address {
        static instance: ::protobuf::rt::LazyV2<GetAddressesResponse_Address> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAddressesResponse_Address::new)
    }
}

impl ::protobuf::Clear for GetAddressesResponse_Address {
    fn clear(&mut self) {
        self.id.clear();
        self.identity_id.clear();
        self.name.clear();
        self.address.clear();
        self.verified = false;
        self.id_schema_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAddressesResponse_Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressesResponse_Address {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAddressRequest {
    // message oneof groups
    pub field_match: ::std::option::Option<GetAddressRequest_oneof_match>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAddressRequest {
    fn default() -> &'a GetAddressRequest {
        <GetAddressRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum GetAddressRequest_oneof_match {
    id(::std::string::String),
    verification(::std::string::String),
}

impl GetAddressRequest {
    pub fn new() -> GetAddressRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        match self.field_match {
            ::std::option::Option::Some(GetAddressRequest_oneof_match::id(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_id(&mut self) {
        self.field_match = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        match self.field_match {
            ::std::option::Option::Some(GetAddressRequest_oneof_match::id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.field_match = ::std::option::Option::Some(GetAddressRequest_oneof_match::id(v))
    }

    // Mutable pointer to the field.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(GetAddressRequest_oneof_match::id(_)) = self.field_match {
        } else {
            self.field_match = ::std::option::Option::Some(GetAddressRequest_oneof_match::id(::std::string::String::new()));
        }
        match self.field_match {
            ::std::option::Option::Some(GetAddressRequest_oneof_match::id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        if self.has_id() {
            match self.field_match.take() {
                ::std::option::Option::Some(GetAddressRequest_oneof_match::id(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string verification = 2;


    pub fn get_verification(&self) -> &str {
        match self.field_match {
            ::std::option::Option::Some(GetAddressRequest_oneof_match::verification(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_verification(&mut self) {
        self.field_match = ::std::option::Option::None;
    }

    pub fn has_verification(&self) -> bool {
        match self.field_match {
            ::std::option::Option::Some(GetAddressRequest_oneof_match::verification(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_verification(&mut self, v: ::std::string::String) {
        self.field_match = ::std::option::Option::Some(GetAddressRequest_oneof_match::verification(v))
    }

    // Mutable pointer to the field.
    pub fn mut_verification(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(GetAddressRequest_oneof_match::verification(_)) = self.field_match {
        } else {
            self.field_match = ::std::option::Option::Some(GetAddressRequest_oneof_match::verification(::std::string::String::new()));
        }
        match self.field_match {
            ::std::option::Option::Some(GetAddressRequest_oneof_match::verification(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_verification(&mut self) -> ::std::string::String {
        if self.has_verification() {
            match self.field_match.take() {
                ::std::option::Option::Some(GetAddressRequest_oneof_match::verification(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for GetAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_match = ::std::option::Option::Some(GetAddressRequest_oneof_match::id(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_match = ::std::option::Option::Some(GetAddressRequest_oneof_match::verification(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_match {
            match v {
                &GetAddressRequest_oneof_match::id(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &GetAddressRequest_oneof_match::verification(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_match {
            match v {
                &GetAddressRequest_oneof_match::id(ref v) => {
                    os.write_string(1, v)?;
                },
                &GetAddressRequest_oneof_match::verification(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAddressRequest {
        GetAddressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "id",
                GetAddressRequest::has_id,
                GetAddressRequest::get_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "verification",
                GetAddressRequest::has_verification,
                GetAddressRequest::get_verification,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAddressRequest>(
                "GetAddressRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAddressRequest {
        static instance: ::protobuf::rt::LazyV2<GetAddressRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAddressRequest::new)
    }
}

impl ::protobuf::Clear for GetAddressRequest {
    fn clear(&mut self) {
        self.field_match = ::std::option::Option::None;
        self.field_match = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAddressResponse {
    // message fields
    pub id: ::std::string::String,
    pub identity_id: ::std::string::String,
    pub name: ::std::string::String,
    pub address: ::std::string::String,
    pub verified: bool,
    pub id_schema_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAddressResponse {
    fn default() -> &'a GetAddressResponse {
        <GetAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAddressResponse {
    pub fn new() -> GetAddressResponse {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string identity_id = 2;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }

    // string name = 3;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string address = 4;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // bool verified = 5;


    pub fn get_verified(&self) -> bool {
        self.verified
    }
    pub fn clear_verified(&mut self) {
        self.verified = false;
    }

    // Param is passed by value, moved
    pub fn set_verified(&mut self, v: bool) {
        self.verified = v;
    }

    // string id_schema_key = 6;


    pub fn get_id_schema_key(&self) -> &str {
        &self.id_schema_key
    }
    pub fn clear_id_schema_key(&mut self) {
        self.id_schema_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_id_schema_key(&mut self, v: ::std::string::String) {
        self.id_schema_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id_schema_key(&mut self) -> &mut ::std::string::String {
        &mut self.id_schema_key
    }

    // Take field
    pub fn take_id_schema_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id_schema_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAddressResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.verified = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id_schema_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identity_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.address);
        }
        if self.verified != false {
            my_size += 2;
        }
        if !self.id_schema_key.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.id_schema_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.identity_id.is_empty() {
            os.write_string(2, &self.identity_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.address.is_empty() {
            os.write_string(4, &self.address)?;
        }
        if self.verified != false {
            os.write_bool(5, self.verified)?;
        }
        if !self.id_schema_key.is_empty() {
            os.write_string(6, &self.id_schema_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAddressResponse {
        GetAddressResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetAddressResponse| { &m.id },
                |m: &mut GetAddressResponse| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetAddressResponse| { &m.identity_id },
                |m: &mut GetAddressResponse| { &mut m.identity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetAddressResponse| { &m.name },
                |m: &mut GetAddressResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &GetAddressResponse| { &m.address },
                |m: &mut GetAddressResponse| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "verified",
                |m: &GetAddressResponse| { &m.verified },
                |m: &mut GetAddressResponse| { &mut m.verified },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id_schema_key",
                |m: &GetAddressResponse| { &m.id_schema_key },
                |m: &mut GetAddressResponse| { &mut m.id_schema_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAddressResponse>(
                "GetAddressResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetAddressResponse {
        static instance: ::protobuf::rt::LazyV2<GetAddressResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetAddressResponse::new)
    }
}

impl ::protobuf::Clear for GetAddressResponse {
    fn clear(&mut self) {
        self.id.clear();
        self.identity_id.clear();
        self.name.clear();
        self.address.clear();
        self.verified = false;
        self.id_schema_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAddressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateAddressRequest {
    // message fields
    pub id: ::std::string::String,
    // message oneof groups
    pub attribute: ::std::option::Option<UpdateAddressRequest_oneof_attribute>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateAddressRequest {
    fn default() -> &'a UpdateAddressRequest {
        <UpdateAddressRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum UpdateAddressRequest_oneof_attribute {
    verified(bool),
    address(::std::string::String),
}

impl UpdateAddressRequest {
    pub fn new() -> UpdateAddressRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // bool verified = 2;


    pub fn get_verified(&self) -> bool {
        match self.attribute {
            ::std::option::Option::Some(UpdateAddressRequest_oneof_attribute::verified(v)) => v,
            _ => false,
        }
    }
    pub fn clear_verified(&mut self) {
        self.attribute = ::std::option::Option::None;
    }

    pub fn has_verified(&self) -> bool {
        match self.attribute {
            ::std::option::Option::Some(UpdateAddressRequest_oneof_attribute::verified(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_verified(&mut self, v: bool) {
        self.attribute = ::std::option::Option::Some(UpdateAddressRequest_oneof_attribute::verified(v))
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        match self.attribute {
            ::std::option::Option::Some(UpdateAddressRequest_oneof_attribute::address(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_address(&mut self) {
        self.attribute = ::std::option::Option::None;
    }

    pub fn has_address(&self) -> bool {
        match self.attribute {
            ::std::option::Option::Some(UpdateAddressRequest_oneof_attribute::address(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.attribute = ::std::option::Option::Some(UpdateAddressRequest_oneof_attribute::address(v))
    }

    // Mutable pointer to the field.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(UpdateAddressRequest_oneof_attribute::address(_)) = self.attribute {
        } else {
            self.attribute = ::std::option::Option::Some(UpdateAddressRequest_oneof_attribute::address(::std::string::String::new()));
        }
        match self.attribute {
            ::std::option::Option::Some(UpdateAddressRequest_oneof_attribute::address(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        if self.has_address() {
            match self.attribute.take() {
                ::std::option::Option::Some(UpdateAddressRequest_oneof_attribute::address(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for UpdateAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.attribute = ::std::option::Option::Some(UpdateAddressRequest_oneof_attribute::verified(is.read_bool()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.attribute = ::std::option::Option::Some(UpdateAddressRequest_oneof_attribute::address(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if let ::std::option::Option::Some(ref v) = self.attribute {
            match v {
                &UpdateAddressRequest_oneof_attribute::verified(v) => {
                    my_size += 2;
                },
                &UpdateAddressRequest_oneof_attribute::address(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if let ::std::option::Option::Some(ref v) = self.attribute {
            match v {
                &UpdateAddressRequest_oneof_attribute::verified(v) => {
                    os.write_bool(2, v)?;
                },
                &UpdateAddressRequest_oneof_attribute::address(ref v) => {
                    os.write_string(3, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateAddressRequest {
        UpdateAddressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &UpdateAddressRequest| { &m.id },
                |m: &mut UpdateAddressRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "verified",
                UpdateAddressRequest::has_verified,
                UpdateAddressRequest::get_verified,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "address",
                UpdateAddressRequest::has_address,
                UpdateAddressRequest::get_address,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateAddressRequest>(
                "UpdateAddressRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateAddressRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateAddressRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateAddressRequest::new)
    }
}

impl ::protobuf::Clear for UpdateAddressRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.attribute = ::std::option::Option::None;
        self.attribute = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateAddressResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateAddressResponse {
    fn default() -> &'a UpdateAddressResponse {
        <UpdateAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateAddressResponse {
    pub fn new() -> UpdateAddressResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateAddressResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateAddressResponse {
        UpdateAddressResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateAddressResponse>(
                "UpdateAddressResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateAddressResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateAddressResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateAddressResponse::new)
    }
}

impl ::protobuf::Clear for UpdateAddressResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateAddressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateAddressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTraitsRequest {
    // message fields
    pub identity_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTraitsRequest {
    fn default() -> &'a GetTraitsRequest {
        <GetTraitsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTraitsRequest {
    pub fn new() -> GetTraitsRequest {
        ::std::default::Default::default()
    }

    // string identity_id = 1;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetTraitsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(1, &self.identity_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTraitsRequest {
        GetTraitsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetTraitsRequest| { &m.identity_id },
                |m: &mut GetTraitsRequest| { &mut m.identity_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTraitsRequest>(
                "GetTraitsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTraitsRequest {
        static instance: ::protobuf::rt::LazyV2<GetTraitsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTraitsRequest::new)
    }
}

impl ::protobuf::Clear for GetTraitsRequest {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTraitsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTraitsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetTraitsResponse {
    // message fields
    pub traits: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetTraitsResponse {
    fn default() -> &'a GetTraitsResponse {
        <GetTraitsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTraitsResponse {
    pub fn new() -> GetTraitsResponse {
        ::std::default::Default::default()
    }

    // string traits = 1;


    pub fn get_traits(&self) -> &str {
        &self.traits
    }
    pub fn clear_traits(&mut self) {
        self.traits.clear();
    }

    // Param is passed by value, moved
    pub fn set_traits(&mut self, v: ::std::string::String) {
        self.traits = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traits(&mut self) -> &mut ::std::string::String {
        &mut self.traits
    }

    // Take field
    pub fn take_traits(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.traits, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetTraitsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.traits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.traits.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.traits);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.traits.is_empty() {
            os.write_string(1, &self.traits)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetTraitsResponse {
        GetTraitsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "traits",
                |m: &GetTraitsResponse| { &m.traits },
                |m: &mut GetTraitsResponse| { &mut m.traits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetTraitsResponse>(
                "GetTraitsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetTraitsResponse {
        static instance: ::protobuf::rt::LazyV2<GetTraitsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetTraitsResponse::new)
    }
}

impl ::protobuf::Clear for GetTraitsResponse {
    fn clear(&mut self) {
        self.traits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetTraitsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTraitsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateTraitsRequest {
    // message fields
    pub identity_id: ::std::string::String,
    pub traits: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateTraitsRequest {
    fn default() -> &'a UpdateTraitsRequest {
        <UpdateTraitsRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTraitsRequest {
    pub fn new() -> UpdateTraitsRequest {
        ::std::default::Default::default()
    }

    // string identity_id = 1;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }

    // string traits = 2;


    pub fn get_traits(&self) -> &str {
        &self.traits
    }
    pub fn clear_traits(&mut self) {
        self.traits.clear();
    }

    // Param is passed by value, moved
    pub fn set_traits(&mut self, v: ::std::string::String) {
        self.traits = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_traits(&mut self) -> &mut ::std::string::String {
        &mut self.traits
    }

    // Take field
    pub fn take_traits(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.traits, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateTraitsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.traits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_id);
        }
        if !self.traits.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.traits);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(1, &self.identity_id)?;
        }
        if !self.traits.is_empty() {
            os.write_string(2, &self.traits)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateTraitsRequest {
        UpdateTraitsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &UpdateTraitsRequest| { &m.identity_id },
                |m: &mut UpdateTraitsRequest| { &mut m.identity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "traits",
                |m: &UpdateTraitsRequest| { &m.traits },
                |m: &mut UpdateTraitsRequest| { &mut m.traits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateTraitsRequest>(
                "UpdateTraitsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateTraitsRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateTraitsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateTraitsRequest::new)
    }
}

impl ::protobuf::Clear for UpdateTraitsRequest {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.traits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateTraitsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateTraitsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateTraitsResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateTraitsResponse {
    fn default() -> &'a UpdateTraitsResponse {
        <UpdateTraitsResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateTraitsResponse {
    pub fn new() -> UpdateTraitsResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateTraitsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateTraitsResponse {
        UpdateTraitsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateTraitsResponse>(
                "UpdateTraitsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateTraitsResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateTraitsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateTraitsResponse::new)
    }
}

impl ::protobuf::Clear for UpdateTraitsResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateTraitsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateTraitsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentityLoginAttemptsRequest {
    // message fields
    pub identity_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentityLoginAttemptsRequest {
    fn default() -> &'a GetIdentityLoginAttemptsRequest {
        <GetIdentityLoginAttemptsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentityLoginAttemptsRequest {
    pub fn new() -> GetIdentityLoginAttemptsRequest {
        ::std::default::Default::default()
    }

    // string identity_id = 1;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetIdentityLoginAttemptsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.identity_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.identity_id.is_empty() {
            os.write_string(1, &self.identity_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentityLoginAttemptsRequest {
        GetIdentityLoginAttemptsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetIdentityLoginAttemptsRequest| { &m.identity_id },
                |m: &mut GetIdentityLoginAttemptsRequest| { &mut m.identity_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentityLoginAttemptsRequest>(
                "GetIdentityLoginAttemptsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentityLoginAttemptsRequest {
        static instance: ::protobuf::rt::LazyV2<GetIdentityLoginAttemptsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentityLoginAttemptsRequest::new)
    }
}

impl ::protobuf::Clear for GetIdentityLoginAttemptsRequest {
    fn clear(&mut self) {
        self.identity_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentityLoginAttemptsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentityLoginAttemptsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentityLoginAttemptsResponse {
    // message fields
    pub attempts: ::protobuf::RepeatedField<GetIdentityLoginAttemptsResponse_Attempt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentityLoginAttemptsResponse {
    fn default() -> &'a GetIdentityLoginAttemptsResponse {
        <GetIdentityLoginAttemptsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentityLoginAttemptsResponse {
    pub fn new() -> GetIdentityLoginAttemptsResponse {
        ::std::default::Default::default()
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetIdentityLoginAttemptsResponse.Attempt attempts = 1;


    pub fn get_attempts(&self) -> &[GetIdentityLoginAttemptsResponse_Attempt] {
        &self.attempts
    }
    pub fn clear_attempts(&mut self) {
        self.attempts.clear();
    }

    // Param is passed by value, moved
    pub fn set_attempts(&mut self, v: ::protobuf::RepeatedField<GetIdentityLoginAttemptsResponse_Attempt>) {
        self.attempts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attempts(&mut self) -> &mut ::protobuf::RepeatedField<GetIdentityLoginAttemptsResponse_Attempt> {
        &mut self.attempts
    }

    // Take field
    pub fn take_attempts(&mut self) -> ::protobuf::RepeatedField<GetIdentityLoginAttemptsResponse_Attempt> {
        ::std::mem::replace(&mut self.attempts, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetIdentityLoginAttemptsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.attempts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.attempts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.attempts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.attempts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentityLoginAttemptsResponse {
        GetIdentityLoginAttemptsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetIdentityLoginAttemptsResponse_Attempt>>(
                "attempts",
                |m: &GetIdentityLoginAttemptsResponse| { &m.attempts },
                |m: &mut GetIdentityLoginAttemptsResponse| { &mut m.attempts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentityLoginAttemptsResponse>(
                "GetIdentityLoginAttemptsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentityLoginAttemptsResponse {
        static instance: ::protobuf::rt::LazyV2<GetIdentityLoginAttemptsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentityLoginAttemptsResponse::new)
    }
}

impl ::protobuf::Clear for GetIdentityLoginAttemptsResponse {
    fn clear(&mut self) {
        self.attempts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentityLoginAttemptsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentityLoginAttemptsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdentityLoginAttemptsResponse_Attempt {
    // message fields
    pub id: ::std::string::String,
    pub identity_id: ::std::string::String,
    pub status: ::std::string::String,
    pub authentication_methods: ::protobuf::RepeatedField<::std::string::String>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub expires_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdentityLoginAttemptsResponse_Attempt {
    fn default() -> &'a GetIdentityLoginAttemptsResponse_Attempt {
        <GetIdentityLoginAttemptsResponse_Attempt as ::protobuf::Message>::default_instance()
    }
}

impl GetIdentityLoginAttemptsResponse_Attempt {
    pub fn new() -> GetIdentityLoginAttemptsResponse_Attempt {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string identity_id = 2;


    pub fn get_identity_id(&self) -> &str {
        &self.identity_id
    }
    pub fn clear_identity_id(&mut self) {
        self.identity_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_identity_id(&mut self, v: ::std::string::String) {
        self.identity_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identity_id(&mut self) -> &mut ::std::string::String {
        &mut self.identity_id
    }

    // Take field
    pub fn take_identity_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.identity_id, ::std::string::String::new())
    }

    // string status = 3;


    pub fn get_status(&self) -> &str {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status, ::std::string::String::new())
    }

    // repeated string authentication_methods = 4;


    pub fn get_authentication_methods(&self) -> &[::std::string::String] {
        &self.authentication_methods
    }
    pub fn clear_authentication_methods(&mut self) {
        self.authentication_methods.clear();
    }

    // Param is passed by value, moved
    pub fn set_authentication_methods(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.authentication_methods = v;
    }

    // Mutable pointer to the field.
    pub fn mut_authentication_methods(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.authentication_methods
    }

    // Take field
    pub fn take_authentication_methods(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.authentication_methods, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp created_at = 5;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp expires_at = 6;


    pub fn get_expires_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.expires_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expires_at(&mut self) {
        self.expires_at.clear();
    }

    pub fn has_expires_at(&self) -> bool {
        self.expires_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expires_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.expires_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expires_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.expires_at.is_none() {
            self.expires_at.set_default();
        }
        self.expires_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_expires_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.expires_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for GetIdentityLoginAttemptsResponse_Attempt {
    fn is_initialized(&self) -> bool {
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expires_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.identity_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.authentication_methods)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expires_at)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.identity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.identity_id);
        }
        if !self.status.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.status);
        }
        for value in &self.authentication_methods {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expires_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.identity_id.is_empty() {
            os.write_string(2, &self.identity_id)?;
        }
        if !self.status.is_empty() {
            os.write_string(3, &self.status)?;
        }
        for v in &self.authentication_methods {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expires_at.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdentityLoginAttemptsResponse_Attempt {
        GetIdentityLoginAttemptsResponse_Attempt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetIdentityLoginAttemptsResponse_Attempt| { &m.id },
                |m: &mut GetIdentityLoginAttemptsResponse_Attempt| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identity_id",
                |m: &GetIdentityLoginAttemptsResponse_Attempt| { &m.identity_id },
                |m: &mut GetIdentityLoginAttemptsResponse_Attempt| { &mut m.identity_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &GetIdentityLoginAttemptsResponse_Attempt| { &m.status },
                |m: &mut GetIdentityLoginAttemptsResponse_Attempt| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authentication_methods",
                |m: &GetIdentityLoginAttemptsResponse_Attempt| { &m.authentication_methods },
                |m: &mut GetIdentityLoginAttemptsResponse_Attempt| { &mut m.authentication_methods },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &GetIdentityLoginAttemptsResponse_Attempt| { &m.created_at },
                |m: &mut GetIdentityLoginAttemptsResponse_Attempt| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "expires_at",
                |m: &GetIdentityLoginAttemptsResponse_Attempt| { &m.expires_at },
                |m: &mut GetIdentityLoginAttemptsResponse_Attempt| { &mut m.expires_at },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdentityLoginAttemptsResponse_Attempt>(
                "GetIdentityLoginAttemptsResponse.Attempt",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdentityLoginAttemptsResponse_Attempt {
        static instance: ::protobuf::rt::LazyV2<GetIdentityLoginAttemptsResponse_Attempt> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdentityLoginAttemptsResponse_Attempt::new)
    }
}

impl ::protobuf::Clear for GetIdentityLoginAttemptsResponse_Attempt {
    fn clear(&mut self) {
        self.id.clear();
        self.identity_id.clear();
        self.status.clear();
        self.authentication_methods.clear();
        self.created_at.clear();
        self.expires_at.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdentityLoginAttemptsResponse_Attempt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdentityLoginAttemptsResponse_Attempt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateIdSchemaRequest {
    // message fields
    pub name: ::std::string::String,
    pub content: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateIdSchemaRequest {
    fn default() -> &'a CreateIdSchemaRequest {
        <CreateIdSchemaRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateIdSchemaRequest {
    pub fn new() -> CreateIdSchemaRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Struct content = 2;


    pub fn get_content(&self) -> &::protobuf::well_known_types::Struct {
        self.content.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.content = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> ::protobuf::well_known_types::Struct {
        self.content.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for CreateIdSchemaRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.content {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.content.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateIdSchemaRequest {
        CreateIdSchemaRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CreateIdSchemaRequest| { &m.name },
                |m: &mut CreateIdSchemaRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "content",
                |m: &CreateIdSchemaRequest| { &m.content },
                |m: &mut CreateIdSchemaRequest| { &mut m.content },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateIdSchemaRequest>(
                "CreateIdSchemaRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateIdSchemaRequest {
        static instance: ::protobuf::rt::LazyV2<CreateIdSchemaRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateIdSchemaRequest::new)
    }
}

impl ::protobuf::Clear for CreateIdSchemaRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateIdSchemaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateIdSchemaRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateIdSchemaResponse {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateIdSchemaResponse {
    fn default() -> &'a CreateIdSchemaResponse {
        <CreateIdSchemaResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateIdSchemaResponse {
    pub fn new() -> CreateIdSchemaResponse {
        ::std::default::Default::default()
    }

    // string id = 2;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateIdSchemaResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(2, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateIdSchemaResponse {
        CreateIdSchemaResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &CreateIdSchemaResponse| { &m.id },
                |m: &mut CreateIdSchemaResponse| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateIdSchemaResponse>(
                "CreateIdSchemaResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateIdSchemaResponse {
        static instance: ::protobuf::rt::LazyV2<CreateIdSchemaResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateIdSchemaResponse::new)
    }
}

impl ::protobuf::Clear for CreateIdSchemaResponse {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateIdSchemaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateIdSchemaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdSchemasRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdSchemasRequest {
    fn default() -> &'a GetIdSchemasRequest {
        <GetIdSchemasRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetIdSchemasRequest {
    pub fn new() -> GetIdSchemasRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetIdSchemasRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdSchemasRequest {
        GetIdSchemasRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdSchemasRequest>(
                "GetIdSchemasRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdSchemasRequest {
        static instance: ::protobuf::rt::LazyV2<GetIdSchemasRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdSchemasRequest::new)
    }
}

impl ::protobuf::Clear for GetIdSchemasRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdSchemasRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdSchemasRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdSchemasResponse {
    // message fields
    pub jsonschemas: ::protobuf::RepeatedField<GetIdSchemasResponse_JsonSchema>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdSchemasResponse {
    fn default() -> &'a GetIdSchemasResponse {
        <GetIdSchemasResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetIdSchemasResponse {
    pub fn new() -> GetIdSchemasResponse {
        ::std::default::Default::default()
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetIdSchemasResponse.JsonSchema jsonschemas = 1;


    pub fn get_jsonschemas(&self) -> &[GetIdSchemasResponse_JsonSchema] {
        &self.jsonschemas
    }
    pub fn clear_jsonschemas(&mut self) {
        self.jsonschemas.clear();
    }

    // Param is passed by value, moved
    pub fn set_jsonschemas(&mut self, v: ::protobuf::RepeatedField<GetIdSchemasResponse_JsonSchema>) {
        self.jsonschemas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_jsonschemas(&mut self) -> &mut ::protobuf::RepeatedField<GetIdSchemasResponse_JsonSchema> {
        &mut self.jsonschemas
    }

    // Take field
    pub fn take_jsonschemas(&mut self) -> ::protobuf::RepeatedField<GetIdSchemasResponse_JsonSchema> {
        ::std::mem::replace(&mut self.jsonschemas, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetIdSchemasResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.jsonschemas {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.jsonschemas)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.jsonschemas {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.jsonschemas {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdSchemasResponse {
        GetIdSchemasResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetIdSchemasResponse_JsonSchema>>(
                "jsonschemas",
                |m: &GetIdSchemasResponse| { &m.jsonschemas },
                |m: &mut GetIdSchemasResponse| { &mut m.jsonschemas },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdSchemasResponse>(
                "GetIdSchemasResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdSchemasResponse {
        static instance: ::protobuf::rt::LazyV2<GetIdSchemasResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdSchemasResponse::new)
    }
}

impl ::protobuf::Clear for GetIdSchemasResponse {
    fn clear(&mut self) {
        self.jsonschemas.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdSchemasResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdSchemasResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdSchemasResponse_JsonSchema {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub content: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub is_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdSchemasResponse_JsonSchema {
    fn default() -> &'a GetIdSchemasResponse_JsonSchema {
        <GetIdSchemasResponse_JsonSchema as ::protobuf::Message>::default_instance()
    }
}

impl GetIdSchemasResponse_JsonSchema {
    pub fn new() -> GetIdSchemasResponse_JsonSchema {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Struct content = 3;


    pub fn get_content(&self) -> &::protobuf::well_known_types::Struct {
        self.content.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.content = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> ::protobuf::well_known_types::Struct {
        self.content.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // .google.protobuf.Timestamp created_at = 4;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated_at = 5;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // bool is_default = 6;


    pub fn get_is_default(&self) -> bool {
        self.is_default
    }
    pub fn clear_is_default(&mut self) {
        self.is_default = false;
    }

    // Param is passed by value, moved
    pub fn set_is_default(&mut self, v: bool) {
        self.is_default = v;
    }
}

impl ::protobuf::Message for GetIdSchemasResponse_JsonSchema {
    fn is_initialized(&self) -> bool {
        for v in &self.content {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.content)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.content.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_default != false {
            os.write_bool(6, self.is_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdSchemasResponse_JsonSchema {
        GetIdSchemasResponse_JsonSchema::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetIdSchemasResponse_JsonSchema| { &m.id },
                |m: &mut GetIdSchemasResponse_JsonSchema| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetIdSchemasResponse_JsonSchema| { &m.name },
                |m: &mut GetIdSchemasResponse_JsonSchema| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "content",
                |m: &GetIdSchemasResponse_JsonSchema| { &m.content },
                |m: &mut GetIdSchemasResponse_JsonSchema| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &GetIdSchemasResponse_JsonSchema| { &m.created_at },
                |m: &mut GetIdSchemasResponse_JsonSchema| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "updated_at",
                |m: &GetIdSchemasResponse_JsonSchema| { &m.updated_at },
                |m: &mut GetIdSchemasResponse_JsonSchema| { &mut m.updated_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_default",
                |m: &GetIdSchemasResponse_JsonSchema| { &m.is_default },
                |m: &mut GetIdSchemasResponse_JsonSchema| { &mut m.is_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdSchemasResponse_JsonSchema>(
                "GetIdSchemasResponse.JsonSchema",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdSchemasResponse_JsonSchema {
        static instance: ::protobuf::rt::LazyV2<GetIdSchemasResponse_JsonSchema> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdSchemasResponse_JsonSchema::new)
    }
}

impl ::protobuf::Clear for GetIdSchemasResponse_JsonSchema {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.content.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.is_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdSchemasResponse_JsonSchema {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdSchemasResponse_JsonSchema {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdSchemaRequest {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdSchemaRequest {
    fn default() -> &'a GetIdSchemaRequest {
        <GetIdSchemaRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetIdSchemaRequest {
    pub fn new() -> GetIdSchemaRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetIdSchemaRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdSchemaRequest {
        GetIdSchemaRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetIdSchemaRequest| { &m.id },
                |m: &mut GetIdSchemaRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdSchemaRequest>(
                "GetIdSchemaRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdSchemaRequest {
        static instance: ::protobuf::rt::LazyV2<GetIdSchemaRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdSchemaRequest::new)
    }
}

impl ::protobuf::Clear for GetIdSchemaRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdSchemaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdSchemaRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetIdSchemaResponse {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub content: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub is_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetIdSchemaResponse {
    fn default() -> &'a GetIdSchemaResponse {
        <GetIdSchemaResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetIdSchemaResponse {
    pub fn new() -> GetIdSchemaResponse {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Struct content = 3;


    pub fn get_content(&self) -> &::protobuf::well_known_types::Struct {
        self.content.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.content = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> ::protobuf::well_known_types::Struct {
        self.content.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // .google.protobuf.Timestamp created_at = 4;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated_at = 5;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // bool is_default = 6;


    pub fn get_is_default(&self) -> bool {
        self.is_default
    }
    pub fn clear_is_default(&mut self) {
        self.is_default = false;
    }

    // Param is passed by value, moved
    pub fn set_is_default(&mut self, v: bool) {
        self.is_default = v;
    }
}

impl ::protobuf::Message for GetIdSchemaResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.content {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.content)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.content.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_default != false {
            os.write_bool(6, self.is_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetIdSchemaResponse {
        GetIdSchemaResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetIdSchemaResponse| { &m.id },
                |m: &mut GetIdSchemaResponse| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetIdSchemaResponse| { &m.name },
                |m: &mut GetIdSchemaResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "content",
                |m: &GetIdSchemaResponse| { &m.content },
                |m: &mut GetIdSchemaResponse| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &GetIdSchemaResponse| { &m.created_at },
                |m: &mut GetIdSchemaResponse| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "updated_at",
                |m: &GetIdSchemaResponse| { &m.updated_at },
                |m: &mut GetIdSchemaResponse| { &mut m.updated_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_default",
                |m: &GetIdSchemaResponse| { &m.is_default },
                |m: &mut GetIdSchemaResponse| { &mut m.is_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetIdSchemaResponse>(
                "GetIdSchemaResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetIdSchemaResponse {
        static instance: ::protobuf::rt::LazyV2<GetIdSchemaResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetIdSchemaResponse::new)
    }
}

impl ::protobuf::Clear for GetIdSchemaResponse {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.content.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.is_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetIdSchemaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetIdSchemaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefaultIdSchemaRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefaultIdSchemaRequest {
    fn default() -> &'a GetDefaultIdSchemaRequest {
        <GetDefaultIdSchemaRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDefaultIdSchemaRequest {
    pub fn new() -> GetDefaultIdSchemaRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetDefaultIdSchemaRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefaultIdSchemaRequest {
        GetDefaultIdSchemaRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefaultIdSchemaRequest>(
                "GetDefaultIdSchemaRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDefaultIdSchemaRequest {
        static instance: ::protobuf::rt::LazyV2<GetDefaultIdSchemaRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDefaultIdSchemaRequest::new)
    }
}

impl ::protobuf::Clear for GetDefaultIdSchemaRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefaultIdSchemaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefaultIdSchemaRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDefaultIdSchemaResponse {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub content: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub created_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub updated_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub is_default: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDefaultIdSchemaResponse {
    fn default() -> &'a GetDefaultIdSchemaResponse {
        <GetDefaultIdSchemaResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDefaultIdSchemaResponse {
    pub fn new() -> GetDefaultIdSchemaResponse {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Struct content = 3;


    pub fn get_content(&self) -> &::protobuf::well_known_types::Struct {
        self.content.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.content = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> ::protobuf::well_known_types::Struct {
        self.content.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // .google.protobuf.Timestamp created_at = 4;


    pub fn get_created_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.created_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_created_at(&mut self) {
        self.created_at.clear();
    }

    pub fn has_created_at(&self) -> bool {
        self.created_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.created_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_created_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.created_at.is_none() {
            self.created_at.set_default();
        }
        self.created_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_created_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.created_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp updated_at = 5;


    pub fn get_updated_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.updated_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_updated_at(&mut self) {
        self.updated_at.clear();
    }

    pub fn has_updated_at(&self) -> bool {
        self.updated_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.updated_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_updated_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.updated_at.is_none() {
            self.updated_at.set_default();
        }
        self.updated_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_updated_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.updated_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // bool is_default = 6;


    pub fn get_is_default(&self) -> bool {
        self.is_default
    }
    pub fn clear_is_default(&mut self) {
        self.is_default = false;
    }

    // Param is passed by value, moved
    pub fn set_is_default(&mut self, v: bool) {
        self.is_default = v;
    }
}

impl ::protobuf::Message for GetDefaultIdSchemaResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.content {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.created_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.updated_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.content)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.created_at)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.updated_at)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_default = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_default != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.content.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.created_at.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.updated_at.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_default != false {
            os.write_bool(6, self.is_default)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDefaultIdSchemaResponse {
        GetDefaultIdSchemaResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &GetDefaultIdSchemaResponse| { &m.id },
                |m: &mut GetDefaultIdSchemaResponse| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetDefaultIdSchemaResponse| { &m.name },
                |m: &mut GetDefaultIdSchemaResponse| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "content",
                |m: &GetDefaultIdSchemaResponse| { &m.content },
                |m: &mut GetDefaultIdSchemaResponse| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "created_at",
                |m: &GetDefaultIdSchemaResponse| { &m.created_at },
                |m: &mut GetDefaultIdSchemaResponse| { &mut m.created_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "updated_at",
                |m: &GetDefaultIdSchemaResponse| { &m.updated_at },
                |m: &mut GetDefaultIdSchemaResponse| { &mut m.updated_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_default",
                |m: &GetDefaultIdSchemaResponse| { &m.is_default },
                |m: &mut GetDefaultIdSchemaResponse| { &mut m.is_default },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDefaultIdSchemaResponse>(
                "GetDefaultIdSchemaResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDefaultIdSchemaResponse {
        static instance: ::protobuf::rt::LazyV2<GetDefaultIdSchemaResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDefaultIdSchemaResponse::new)
    }
}

impl ::protobuf::Clear for GetDefaultIdSchemaResponse {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.content.clear();
        self.created_at.clear();
        self.updated_at.clear();
        self.is_default = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDefaultIdSchemaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDefaultIdSchemaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateIdSchemaRequest {
    // message fields
    pub id: ::std::string::String,
    pub name: ::std::string::String,
    pub content: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateIdSchemaRequest {
    fn default() -> &'a UpdateIdSchemaRequest {
        <UpdateIdSchemaRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateIdSchemaRequest {
    pub fn new() -> UpdateIdSchemaRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Struct content = 3;


    pub fn get_content(&self) -> &::protobuf::well_known_types::Struct {
        self.content.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.content = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> ::protobuf::well_known_types::Struct {
        self.content.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for UpdateIdSchemaRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.content {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(ref v) = self.content.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(ref v) = self.content.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateIdSchemaRequest {
        UpdateIdSchemaRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &UpdateIdSchemaRequest| { &m.id },
                |m: &mut UpdateIdSchemaRequest| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UpdateIdSchemaRequest| { &m.name },
                |m: &mut UpdateIdSchemaRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "content",
                |m: &UpdateIdSchemaRequest| { &m.content },
                |m: &mut UpdateIdSchemaRequest| { &mut m.content },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateIdSchemaRequest>(
                "UpdateIdSchemaRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateIdSchemaRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateIdSchemaRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateIdSchemaRequest::new)
    }
}

impl ::protobuf::Clear for UpdateIdSchemaRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.name.clear();
        self.content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateIdSchemaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateIdSchemaRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateIdSchemaResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateIdSchemaResponse {
    fn default() -> &'a UpdateIdSchemaResponse {
        <UpdateIdSchemaResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateIdSchemaResponse {
    pub fn new() -> UpdateIdSchemaResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateIdSchemaResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateIdSchemaResponse {
        UpdateIdSchemaResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateIdSchemaResponse>(
                "UpdateIdSchemaResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateIdSchemaResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateIdSchemaResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateIdSchemaResponse::new)
    }
}

impl ::protobuf::Clear for UpdateIdSchemaResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateIdSchemaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateIdSchemaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MarkDefaultIdSchemaRequest {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarkDefaultIdSchemaRequest {
    fn default() -> &'a MarkDefaultIdSchemaRequest {
        <MarkDefaultIdSchemaRequest as ::protobuf::Message>::default_instance()
    }
}

impl MarkDefaultIdSchemaRequest {
    pub fn new() -> MarkDefaultIdSchemaRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MarkDefaultIdSchemaRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarkDefaultIdSchemaRequest {
        MarkDefaultIdSchemaRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &MarkDefaultIdSchemaRequest| { &m.id },
                |m: &mut MarkDefaultIdSchemaRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MarkDefaultIdSchemaRequest>(
                "MarkDefaultIdSchemaRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MarkDefaultIdSchemaRequest {
        static instance: ::protobuf::rt::LazyV2<MarkDefaultIdSchemaRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarkDefaultIdSchemaRequest::new)
    }
}

impl ::protobuf::Clear for MarkDefaultIdSchemaRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MarkDefaultIdSchemaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarkDefaultIdSchemaRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MarkDefaultIdSchemaResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarkDefaultIdSchemaResponse {
    fn default() -> &'a MarkDefaultIdSchemaResponse {
        <MarkDefaultIdSchemaResponse as ::protobuf::Message>::default_instance()
    }
}

impl MarkDefaultIdSchemaResponse {
    pub fn new() -> MarkDefaultIdSchemaResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MarkDefaultIdSchemaResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarkDefaultIdSchemaResponse {
        MarkDefaultIdSchemaResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MarkDefaultIdSchemaResponse>(
                "MarkDefaultIdSchemaResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MarkDefaultIdSchemaResponse {
        static instance: ::protobuf::rt::LazyV2<MarkDefaultIdSchemaResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarkDefaultIdSchemaResponse::new)
    }
}

impl ::protobuf::Clear for MarkDefaultIdSchemaResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MarkDefaultIdSchemaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarkDefaultIdSchemaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteIdSchemaRequest {
    // message fields
    pub id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteIdSchemaRequest {
    fn default() -> &'a DeleteIdSchemaRequest {
        <DeleteIdSchemaRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteIdSchemaRequest {
    pub fn new() -> DeleteIdSchemaRequest {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteIdSchemaRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteIdSchemaRequest {
        DeleteIdSchemaRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &DeleteIdSchemaRequest| { &m.id },
                |m: &mut DeleteIdSchemaRequest| { &mut m.id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteIdSchemaRequest>(
                "DeleteIdSchemaRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteIdSchemaRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteIdSchemaRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteIdSchemaRequest::new)
    }
}

impl ::protobuf::Clear for DeleteIdSchemaRequest {
    fn clear(&mut self) {
        self.id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteIdSchemaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteIdSchemaRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteIdSchemaResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteIdSchemaResponse {
    fn default() -> &'a DeleteIdSchemaResponse {
        <DeleteIdSchemaResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteIdSchemaResponse {
    pub fn new() -> DeleteIdSchemaResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteIdSchemaResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteIdSchemaResponse {
        DeleteIdSchemaResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteIdSchemaResponse>(
                "DeleteIdSchemaResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteIdSchemaResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteIdSchemaResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteIdSchemaResponse::new)
    }
}

impl ::protobuf::Clear for DeleteIdSchemaResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteIdSchemaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteIdSchemaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEmailsSetupRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEmailsSetupRequest {
    fn default() -> &'a GetEmailsSetupRequest {
        <GetEmailsSetupRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetEmailsSetupRequest {
    pub fn new() -> GetEmailsSetupRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetEmailsSetupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEmailsSetupRequest {
        GetEmailsSetupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEmailsSetupRequest>(
                "GetEmailsSetupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEmailsSetupRequest {
        static instance: ::protobuf::rt::LazyV2<GetEmailsSetupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEmailsSetupRequest::new)
    }
}

impl ::protobuf::Clear for GetEmailsSetupRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEmailsSetupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEmailsSetupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEmailsSetupResponse {
    // message fields
    pub welcome: ::protobuf::SingularPtrField<GetEmailsSetupResponse_EmailTemplate>,
    pub account_verification: ::protobuf::SingularPtrField<GetEmailsSetupResponse_EmailTemplate>,
    pub account_recovery: ::protobuf::SingularPtrField<GetEmailsSetupResponse_EmailTemplate>,
    pub account_recovered: ::protobuf::SingularPtrField<GetEmailsSetupResponse_EmailTemplate>,
    pub otp: ::protobuf::SingularPtrField<GetEmailsSetupResponse_EmailTemplate>,
    pub smtp: ::protobuf::SingularPtrField<GetEmailsSetupResponse_EmailSender>,
    pub project_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEmailsSetupResponse {
    fn default() -> &'a GetEmailsSetupResponse {
        <GetEmailsSetupResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetEmailsSetupResponse {
    pub fn new() -> GetEmailsSetupResponse {
        ::std::default::Default::default()
    }

    // .depot.devtools.auth.v0.identity.admin.GetEmailsSetupResponse.EmailTemplate welcome = 1;


    pub fn get_welcome(&self) -> &GetEmailsSetupResponse_EmailTemplate {
        self.welcome.as_ref().unwrap_or_else(|| <GetEmailsSetupResponse_EmailTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_welcome(&mut self) {
        self.welcome.clear();
    }

    pub fn has_welcome(&self) -> bool {
        self.welcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_welcome(&mut self, v: GetEmailsSetupResponse_EmailTemplate) {
        self.welcome = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_welcome(&mut self) -> &mut GetEmailsSetupResponse_EmailTemplate {
        if self.welcome.is_none() {
            self.welcome.set_default();
        }
        self.welcome.as_mut().unwrap()
    }

    // Take field
    pub fn take_welcome(&mut self) -> GetEmailsSetupResponse_EmailTemplate {
        self.welcome.take().unwrap_or_else(|| GetEmailsSetupResponse_EmailTemplate::new())
    }

    // .depot.devtools.auth.v0.identity.admin.GetEmailsSetupResponse.EmailTemplate account_verification = 2;


    pub fn get_account_verification(&self) -> &GetEmailsSetupResponse_EmailTemplate {
        self.account_verification.as_ref().unwrap_or_else(|| <GetEmailsSetupResponse_EmailTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_verification(&mut self) {
        self.account_verification.clear();
    }

    pub fn has_account_verification(&self) -> bool {
        self.account_verification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_verification(&mut self, v: GetEmailsSetupResponse_EmailTemplate) {
        self.account_verification = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_verification(&mut self) -> &mut GetEmailsSetupResponse_EmailTemplate {
        if self.account_verification.is_none() {
            self.account_verification.set_default();
        }
        self.account_verification.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_verification(&mut self) -> GetEmailsSetupResponse_EmailTemplate {
        self.account_verification.take().unwrap_or_else(|| GetEmailsSetupResponse_EmailTemplate::new())
    }

    // .depot.devtools.auth.v0.identity.admin.GetEmailsSetupResponse.EmailTemplate account_recovery = 3;


    pub fn get_account_recovery(&self) -> &GetEmailsSetupResponse_EmailTemplate {
        self.account_recovery.as_ref().unwrap_or_else(|| <GetEmailsSetupResponse_EmailTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_recovery(&mut self) {
        self.account_recovery.clear();
    }

    pub fn has_account_recovery(&self) -> bool {
        self.account_recovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_recovery(&mut self, v: GetEmailsSetupResponse_EmailTemplate) {
        self.account_recovery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_recovery(&mut self) -> &mut GetEmailsSetupResponse_EmailTemplate {
        if self.account_recovery.is_none() {
            self.account_recovery.set_default();
        }
        self.account_recovery.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_recovery(&mut self) -> GetEmailsSetupResponse_EmailTemplate {
        self.account_recovery.take().unwrap_or_else(|| GetEmailsSetupResponse_EmailTemplate::new())
    }

    // .depot.devtools.auth.v0.identity.admin.GetEmailsSetupResponse.EmailTemplate account_recovered = 4;


    pub fn get_account_recovered(&self) -> &GetEmailsSetupResponse_EmailTemplate {
        self.account_recovered.as_ref().unwrap_or_else(|| <GetEmailsSetupResponse_EmailTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_recovered(&mut self) {
        self.account_recovered.clear();
    }

    pub fn has_account_recovered(&self) -> bool {
        self.account_recovered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_recovered(&mut self, v: GetEmailsSetupResponse_EmailTemplate) {
        self.account_recovered = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_recovered(&mut self) -> &mut GetEmailsSetupResponse_EmailTemplate {
        if self.account_recovered.is_none() {
            self.account_recovered.set_default();
        }
        self.account_recovered.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_recovered(&mut self) -> GetEmailsSetupResponse_EmailTemplate {
        self.account_recovered.take().unwrap_or_else(|| GetEmailsSetupResponse_EmailTemplate::new())
    }

    // .depot.devtools.auth.v0.identity.admin.GetEmailsSetupResponse.EmailTemplate otp = 5;


    pub fn get_otp(&self) -> &GetEmailsSetupResponse_EmailTemplate {
        self.otp.as_ref().unwrap_or_else(|| <GetEmailsSetupResponse_EmailTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_otp(&mut self) {
        self.otp.clear();
    }

    pub fn has_otp(&self) -> bool {
        self.otp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp(&mut self, v: GetEmailsSetupResponse_EmailTemplate) {
        self.otp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp(&mut self) -> &mut GetEmailsSetupResponse_EmailTemplate {
        if self.otp.is_none() {
            self.otp.set_default();
        }
        self.otp.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp(&mut self) -> GetEmailsSetupResponse_EmailTemplate {
        self.otp.take().unwrap_or_else(|| GetEmailsSetupResponse_EmailTemplate::new())
    }

    // .depot.devtools.auth.v0.identity.admin.GetEmailsSetupResponse.EmailSender smtp = 6;


    pub fn get_smtp(&self) -> &GetEmailsSetupResponse_EmailSender {
        self.smtp.as_ref().unwrap_or_else(|| <GetEmailsSetupResponse_EmailSender as ::protobuf::Message>::default_instance())
    }
    pub fn clear_smtp(&mut self) {
        self.smtp.clear();
    }

    pub fn has_smtp(&self) -> bool {
        self.smtp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_smtp(&mut self, v: GetEmailsSetupResponse_EmailSender) {
        self.smtp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_smtp(&mut self) -> &mut GetEmailsSetupResponse_EmailSender {
        if self.smtp.is_none() {
            self.smtp.set_default();
        }
        self.smtp.as_mut().unwrap()
    }

    // Take field
    pub fn take_smtp(&mut self) -> GetEmailsSetupResponse_EmailSender {
        self.smtp.take().unwrap_or_else(|| GetEmailsSetupResponse_EmailSender::new())
    }

    // string project_id = 7;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetEmailsSetupResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.welcome {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.account_verification {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.account_recovery {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.account_recovered {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.otp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.smtp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.welcome)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_verification)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_recovery)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_recovered)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.otp)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.smtp)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.welcome.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.account_verification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.account_recovery.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.account_recovered.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.otp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.smtp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.project_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.welcome.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.account_verification.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.account_recovery.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.account_recovered.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.otp.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.smtp.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.project_id.is_empty() {
            os.write_string(7, &self.project_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEmailsSetupResponse {
        GetEmailsSetupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetEmailsSetupResponse_EmailTemplate>>(
                "welcome",
                |m: &GetEmailsSetupResponse| { &m.welcome },
                |m: &mut GetEmailsSetupResponse| { &mut m.welcome },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetEmailsSetupResponse_EmailTemplate>>(
                "account_verification",
                |m: &GetEmailsSetupResponse| { &m.account_verification },
                |m: &mut GetEmailsSetupResponse| { &mut m.account_verification },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetEmailsSetupResponse_EmailTemplate>>(
                "account_recovery",
                |m: &GetEmailsSetupResponse| { &m.account_recovery },
                |m: &mut GetEmailsSetupResponse| { &mut m.account_recovery },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetEmailsSetupResponse_EmailTemplate>>(
                "account_recovered",
                |m: &GetEmailsSetupResponse| { &m.account_recovered },
                |m: &mut GetEmailsSetupResponse| { &mut m.account_recovered },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetEmailsSetupResponse_EmailTemplate>>(
                "otp",
                |m: &GetEmailsSetupResponse| { &m.otp },
                |m: &mut GetEmailsSetupResponse| { &mut m.otp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GetEmailsSetupResponse_EmailSender>>(
                "smtp",
                |m: &GetEmailsSetupResponse| { &m.smtp },
                |m: &mut GetEmailsSetupResponse| { &mut m.smtp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &GetEmailsSetupResponse| { &m.project_id },
                |m: &mut GetEmailsSetupResponse| { &mut m.project_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEmailsSetupResponse>(
                "GetEmailsSetupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEmailsSetupResponse {
        static instance: ::protobuf::rt::LazyV2<GetEmailsSetupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEmailsSetupResponse::new)
    }
}

impl ::protobuf::Clear for GetEmailsSetupResponse {
    fn clear(&mut self) {
        self.welcome.clear();
        self.account_verification.clear();
        self.account_recovery.clear();
        self.account_recovered.clear();
        self.otp.clear();
        self.smtp.clear();
        self.project_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEmailsSetupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEmailsSetupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEmailsSetupResponse_EmailTemplate {
    // message fields
    pub content: ::std::string::String,
    pub subject: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEmailsSetupResponse_EmailTemplate {
    fn default() -> &'a GetEmailsSetupResponse_EmailTemplate {
        <GetEmailsSetupResponse_EmailTemplate as ::protobuf::Message>::default_instance()
    }
}

impl GetEmailsSetupResponse_EmailTemplate {
    pub fn new() -> GetEmailsSetupResponse_EmailTemplate {
        ::std::default::Default::default()
    }

    // string content = 3;


    pub fn get_content(&self) -> &str {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content, ::std::string::String::new())
    }

    // string subject = 4;


    pub fn get_subject(&self) -> &str {
        &self.subject
    }
    pub fn clear_subject(&mut self) {
        self.subject.clear();
    }

    // Param is passed by value, moved
    pub fn set_subject(&mut self, v: ::std::string::String) {
        self.subject = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subject(&mut self) -> &mut ::std::string::String {
        &mut self.subject
    }

    // Take field
    pub fn take_subject(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subject, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetEmailsSetupResponse_EmailTemplate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subject)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.content);
        }
        if !self.subject.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.subject);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.content.is_empty() {
            os.write_string(3, &self.content)?;
        }
        if !self.subject.is_empty() {
            os.write_string(4, &self.subject)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEmailsSetupResponse_EmailTemplate {
        GetEmailsSetupResponse_EmailTemplate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "content",
                |m: &GetEmailsSetupResponse_EmailTemplate| { &m.content },
                |m: &mut GetEmailsSetupResponse_EmailTemplate| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subject",
                |m: &GetEmailsSetupResponse_EmailTemplate| { &m.subject },
                |m: &mut GetEmailsSetupResponse_EmailTemplate| { &mut m.subject },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEmailsSetupResponse_EmailTemplate>(
                "GetEmailsSetupResponse.EmailTemplate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEmailsSetupResponse_EmailTemplate {
        static instance: ::protobuf::rt::LazyV2<GetEmailsSetupResponse_EmailTemplate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEmailsSetupResponse_EmailTemplate::new)
    }
}

impl ::protobuf::Clear for GetEmailsSetupResponse_EmailTemplate {
    fn clear(&mut self) {
        self.content.clear();
        self.subject.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEmailsSetupResponse_EmailTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEmailsSetupResponse_EmailTemplate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetEmailsSetupResponse_EmailSender {
    // message fields
    pub email_address: ::std::string::String,
    pub smtp_host: ::std::string::String,
    pub smtp_port: u32,
    pub smtp_username: ::std::string::String,
    pub smtp_password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetEmailsSetupResponse_EmailSender {
    fn default() -> &'a GetEmailsSetupResponse_EmailSender {
        <GetEmailsSetupResponse_EmailSender as ::protobuf::Message>::default_instance()
    }
}

impl GetEmailsSetupResponse_EmailSender {
    pub fn new() -> GetEmailsSetupResponse_EmailSender {
        ::std::default::Default::default()
    }

    // string email_address = 1;


    pub fn get_email_address(&self) -> &str {
        &self.email_address
    }
    pub fn clear_email_address(&mut self) {
        self.email_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_email_address(&mut self, v: ::std::string::String) {
        self.email_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
        &mut self.email_address
    }

    // Take field
    pub fn take_email_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email_address, ::std::string::String::new())
    }

    // string smtp_host = 2;


    pub fn get_smtp_host(&self) -> &str {
        &self.smtp_host
    }
    pub fn clear_smtp_host(&mut self) {
        self.smtp_host.clear();
    }

    // Param is passed by value, moved
    pub fn set_smtp_host(&mut self, v: ::std::string::String) {
        self.smtp_host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_smtp_host(&mut self) -> &mut ::std::string::String {
        &mut self.smtp_host
    }

    // Take field
    pub fn take_smtp_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.smtp_host, ::std::string::String::new())
    }

    // uint32 smtp_port = 3;


    pub fn get_smtp_port(&self) -> u32 {
        self.smtp_port
    }
    pub fn clear_smtp_port(&mut self) {
        self.smtp_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_smtp_port(&mut self, v: u32) {
        self.smtp_port = v;
    }

    // string smtp_username = 4;


    pub fn get_smtp_username(&self) -> &str {
        &self.smtp_username
    }
    pub fn clear_smtp_username(&mut self) {
        self.smtp_username.clear();
    }

    // Param is passed by value, moved
    pub fn set_smtp_username(&mut self, v: ::std::string::String) {
        self.smtp_username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_smtp_username(&mut self) -> &mut ::std::string::String {
        &mut self.smtp_username
    }

    // Take field
    pub fn take_smtp_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.smtp_username, ::std::string::String::new())
    }

    // string smtp_password = 5;


    pub fn get_smtp_password(&self) -> &str {
        &self.smtp_password
    }
    pub fn clear_smtp_password(&mut self) {
        self.smtp_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_smtp_password(&mut self, v: ::std::string::String) {
        self.smtp_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_smtp_password(&mut self) -> &mut ::std::string::String {
        &mut self.smtp_password
    }

    // Take field
    pub fn take_smtp_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.smtp_password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetEmailsSetupResponse_EmailSender {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.email_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.smtp_host)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.smtp_port = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.smtp_username)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.smtp_password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.email_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.email_address);
        }
        if !self.smtp_host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.smtp_host);
        }
        if self.smtp_port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.smtp_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.smtp_username.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.smtp_username);
        }
        if !self.smtp_password.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.smtp_password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.email_address.is_empty() {
            os.write_string(1, &self.email_address)?;
        }
        if !self.smtp_host.is_empty() {
            os.write_string(2, &self.smtp_host)?;
        }
        if self.smtp_port != 0 {
            os.write_uint32(3, self.smtp_port)?;
        }
        if !self.smtp_username.is_empty() {
            os.write_string(4, &self.smtp_username)?;
        }
        if !self.smtp_password.is_empty() {
            os.write_string(5, &self.smtp_password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetEmailsSetupResponse_EmailSender {
        GetEmailsSetupResponse_EmailSender::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email_address",
                |m: &GetEmailsSetupResponse_EmailSender| { &m.email_address },
                |m: &mut GetEmailsSetupResponse_EmailSender| { &mut m.email_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "smtp_host",
                |m: &GetEmailsSetupResponse_EmailSender| { &m.smtp_host },
                |m: &mut GetEmailsSetupResponse_EmailSender| { &mut m.smtp_host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "smtp_port",
                |m: &GetEmailsSetupResponse_EmailSender| { &m.smtp_port },
                |m: &mut GetEmailsSetupResponse_EmailSender| { &mut m.smtp_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "smtp_username",
                |m: &GetEmailsSetupResponse_EmailSender| { &m.smtp_username },
                |m: &mut GetEmailsSetupResponse_EmailSender| { &mut m.smtp_username },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "smtp_password",
                |m: &GetEmailsSetupResponse_EmailSender| { &m.smtp_password },
                |m: &mut GetEmailsSetupResponse_EmailSender| { &mut m.smtp_password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetEmailsSetupResponse_EmailSender>(
                "GetEmailsSetupResponse.EmailSender",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetEmailsSetupResponse_EmailSender {
        static instance: ::protobuf::rt::LazyV2<GetEmailsSetupResponse_EmailSender> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetEmailsSetupResponse_EmailSender::new)
    }
}

impl ::protobuf::Clear for GetEmailsSetupResponse_EmailSender {
    fn clear(&mut self) {
        self.email_address.clear();
        self.smtp_host.clear();
        self.smtp_port = 0;
        self.smtp_username.clear();
        self.smtp_password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetEmailsSetupResponse_EmailSender {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetEmailsSetupResponse_EmailSender {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateEmailsSetupRequest {
    // message fields
    pub welcome: ::protobuf::SingularPtrField<UpdateEmailsSetupRequest_EmailTemplate>,
    pub account_verification: ::protobuf::SingularPtrField<UpdateEmailsSetupRequest_EmailTemplate>,
    pub account_recovery: ::protobuf::SingularPtrField<UpdateEmailsSetupRequest_EmailTemplate>,
    pub account_recovered: ::protobuf::SingularPtrField<UpdateEmailsSetupRequest_EmailTemplate>,
    pub otp: ::protobuf::SingularPtrField<UpdateEmailsSetupRequest_EmailTemplate>,
    pub smtp: ::protobuf::SingularPtrField<UpdateEmailsSetupRequest_EmailSender>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateEmailsSetupRequest {
    fn default() -> &'a UpdateEmailsSetupRequest {
        <UpdateEmailsSetupRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEmailsSetupRequest {
    pub fn new() -> UpdateEmailsSetupRequest {
        ::std::default::Default::default()
    }

    // .depot.devtools.auth.v0.identity.admin.UpdateEmailsSetupRequest.EmailTemplate welcome = 1;


    pub fn get_welcome(&self) -> &UpdateEmailsSetupRequest_EmailTemplate {
        self.welcome.as_ref().unwrap_or_else(|| <UpdateEmailsSetupRequest_EmailTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_welcome(&mut self) {
        self.welcome.clear();
    }

    pub fn has_welcome(&self) -> bool {
        self.welcome.is_some()
    }

    // Param is passed by value, moved
    pub fn set_welcome(&mut self, v: UpdateEmailsSetupRequest_EmailTemplate) {
        self.welcome = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_welcome(&mut self) -> &mut UpdateEmailsSetupRequest_EmailTemplate {
        if self.welcome.is_none() {
            self.welcome.set_default();
        }
        self.welcome.as_mut().unwrap()
    }

    // Take field
    pub fn take_welcome(&mut self) -> UpdateEmailsSetupRequest_EmailTemplate {
        self.welcome.take().unwrap_or_else(|| UpdateEmailsSetupRequest_EmailTemplate::new())
    }

    // .depot.devtools.auth.v0.identity.admin.UpdateEmailsSetupRequest.EmailTemplate account_verification = 2;


    pub fn get_account_verification(&self) -> &UpdateEmailsSetupRequest_EmailTemplate {
        self.account_verification.as_ref().unwrap_or_else(|| <UpdateEmailsSetupRequest_EmailTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_verification(&mut self) {
        self.account_verification.clear();
    }

    pub fn has_account_verification(&self) -> bool {
        self.account_verification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_verification(&mut self, v: UpdateEmailsSetupRequest_EmailTemplate) {
        self.account_verification = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_verification(&mut self) -> &mut UpdateEmailsSetupRequest_EmailTemplate {
        if self.account_verification.is_none() {
            self.account_verification.set_default();
        }
        self.account_verification.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_verification(&mut self) -> UpdateEmailsSetupRequest_EmailTemplate {
        self.account_verification.take().unwrap_or_else(|| UpdateEmailsSetupRequest_EmailTemplate::new())
    }

    // .depot.devtools.auth.v0.identity.admin.UpdateEmailsSetupRequest.EmailTemplate account_recovery = 3;


    pub fn get_account_recovery(&self) -> &UpdateEmailsSetupRequest_EmailTemplate {
        self.account_recovery.as_ref().unwrap_or_else(|| <UpdateEmailsSetupRequest_EmailTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_recovery(&mut self) {
        self.account_recovery.clear();
    }

    pub fn has_account_recovery(&self) -> bool {
        self.account_recovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_recovery(&mut self, v: UpdateEmailsSetupRequest_EmailTemplate) {
        self.account_recovery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_recovery(&mut self) -> &mut UpdateEmailsSetupRequest_EmailTemplate {
        if self.account_recovery.is_none() {
            self.account_recovery.set_default();
        }
        self.account_recovery.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_recovery(&mut self) -> UpdateEmailsSetupRequest_EmailTemplate {
        self.account_recovery.take().unwrap_or_else(|| UpdateEmailsSetupRequest_EmailTemplate::new())
    }

    // .depot.devtools.auth.v0.identity.admin.UpdateEmailsSetupRequest.EmailTemplate account_recovered = 4;


    pub fn get_account_recovered(&self) -> &UpdateEmailsSetupRequest_EmailTemplate {
        self.account_recovered.as_ref().unwrap_or_else(|| <UpdateEmailsSetupRequest_EmailTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_account_recovered(&mut self) {
        self.account_recovered.clear();
    }

    pub fn has_account_recovered(&self) -> bool {
        self.account_recovered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_recovered(&mut self, v: UpdateEmailsSetupRequest_EmailTemplate) {
        self.account_recovered = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_recovered(&mut self) -> &mut UpdateEmailsSetupRequest_EmailTemplate {
        if self.account_recovered.is_none() {
            self.account_recovered.set_default();
        }
        self.account_recovered.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_recovered(&mut self) -> UpdateEmailsSetupRequest_EmailTemplate {
        self.account_recovered.take().unwrap_or_else(|| UpdateEmailsSetupRequest_EmailTemplate::new())
    }

    // .depot.devtools.auth.v0.identity.admin.UpdateEmailsSetupRequest.EmailTemplate otp = 5;


    pub fn get_otp(&self) -> &UpdateEmailsSetupRequest_EmailTemplate {
        self.otp.as_ref().unwrap_or_else(|| <UpdateEmailsSetupRequest_EmailTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_otp(&mut self) {
        self.otp.clear();
    }

    pub fn has_otp(&self) -> bool {
        self.otp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp(&mut self, v: UpdateEmailsSetupRequest_EmailTemplate) {
        self.otp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp(&mut self) -> &mut UpdateEmailsSetupRequest_EmailTemplate {
        if self.otp.is_none() {
            self.otp.set_default();
        }
        self.otp.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp(&mut self) -> UpdateEmailsSetupRequest_EmailTemplate {
        self.otp.take().unwrap_or_else(|| UpdateEmailsSetupRequest_EmailTemplate::new())
    }

    // .depot.devtools.auth.v0.identity.admin.UpdateEmailsSetupRequest.EmailSender smtp = 6;


    pub fn get_smtp(&self) -> &UpdateEmailsSetupRequest_EmailSender {
        self.smtp.as_ref().unwrap_or_else(|| <UpdateEmailsSetupRequest_EmailSender as ::protobuf::Message>::default_instance())
    }
    pub fn clear_smtp(&mut self) {
        self.smtp.clear();
    }

    pub fn has_smtp(&self) -> bool {
        self.smtp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_smtp(&mut self, v: UpdateEmailsSetupRequest_EmailSender) {
        self.smtp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_smtp(&mut self) -> &mut UpdateEmailsSetupRequest_EmailSender {
        if self.smtp.is_none() {
            self.smtp.set_default();
        }
        self.smtp.as_mut().unwrap()
    }

    // Take field
    pub fn take_smtp(&mut self) -> UpdateEmailsSetupRequest_EmailSender {
        self.smtp.take().unwrap_or_else(|| UpdateEmailsSetupRequest_EmailSender::new())
    }
}

impl ::protobuf::Message for UpdateEmailsSetupRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.welcome {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.account_verification {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.account_recovery {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.account_recovered {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.otp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.smtp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.welcome)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_verification)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_recovery)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.account_recovered)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.otp)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.smtp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.welcome.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.account_verification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.account_recovery.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.account_recovered.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.otp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.smtp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.welcome.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.account_verification.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.account_recovery.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.account_recovered.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.otp.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.smtp.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateEmailsSetupRequest {
        UpdateEmailsSetupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateEmailsSetupRequest_EmailTemplate>>(
                "welcome",
                |m: &UpdateEmailsSetupRequest| { &m.welcome },
                |m: &mut UpdateEmailsSetupRequest| { &mut m.welcome },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateEmailsSetupRequest_EmailTemplate>>(
                "account_verification",
                |m: &UpdateEmailsSetupRequest| { &m.account_verification },
                |m: &mut UpdateEmailsSetupRequest| { &mut m.account_verification },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateEmailsSetupRequest_EmailTemplate>>(
                "account_recovery",
                |m: &UpdateEmailsSetupRequest| { &m.account_recovery },
                |m: &mut UpdateEmailsSetupRequest| { &mut m.account_recovery },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateEmailsSetupRequest_EmailTemplate>>(
                "account_recovered",
                |m: &UpdateEmailsSetupRequest| { &m.account_recovered },
                |m: &mut UpdateEmailsSetupRequest| { &mut m.account_recovered },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateEmailsSetupRequest_EmailTemplate>>(
                "otp",
                |m: &UpdateEmailsSetupRequest| { &m.otp },
                |m: &mut UpdateEmailsSetupRequest| { &mut m.otp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateEmailsSetupRequest_EmailSender>>(
                "smtp",
                |m: &UpdateEmailsSetupRequest| { &m.smtp },
                |m: &mut UpdateEmailsSetupRequest| { &mut m.smtp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateEmailsSetupRequest>(
                "UpdateEmailsSetupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateEmailsSetupRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateEmailsSetupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateEmailsSetupRequest::new)
    }
}

impl ::protobuf::Clear for UpdateEmailsSetupRequest {
    fn clear(&mut self) {
        self.welcome.clear();
        self.account_verification.clear();
        self.account_recovery.clear();
        self.account_recovered.clear();
        self.otp.clear();
        self.smtp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateEmailsSetupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEmailsSetupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateEmailsSetupRequest_EmailTemplate {
    // message fields
    pub content: ::std::string::String,
    pub subject: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateEmailsSetupRequest_EmailTemplate {
    fn default() -> &'a UpdateEmailsSetupRequest_EmailTemplate {
        <UpdateEmailsSetupRequest_EmailTemplate as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEmailsSetupRequest_EmailTemplate {
    pub fn new() -> UpdateEmailsSetupRequest_EmailTemplate {
        ::std::default::Default::default()
    }

    // string content = 1;


    pub fn get_content(&self) -> &str {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content, ::std::string::String::new())
    }

    // string subject = 2;


    pub fn get_subject(&self) -> &str {
        &self.subject
    }
    pub fn clear_subject(&mut self) {
        self.subject.clear();
    }

    // Param is passed by value, moved
    pub fn set_subject(&mut self, v: ::std::string::String) {
        self.subject = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subject(&mut self) -> &mut ::std::string::String {
        &mut self.subject
    }

    // Take field
    pub fn take_subject(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subject, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateEmailsSetupRequest_EmailTemplate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subject)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.content);
        }
        if !self.subject.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subject);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.content.is_empty() {
            os.write_string(1, &self.content)?;
        }
        if !self.subject.is_empty() {
            os.write_string(2, &self.subject)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateEmailsSetupRequest_EmailTemplate {
        UpdateEmailsSetupRequest_EmailTemplate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "content",
                |m: &UpdateEmailsSetupRequest_EmailTemplate| { &m.content },
                |m: &mut UpdateEmailsSetupRequest_EmailTemplate| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subject",
                |m: &UpdateEmailsSetupRequest_EmailTemplate| { &m.subject },
                |m: &mut UpdateEmailsSetupRequest_EmailTemplate| { &mut m.subject },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateEmailsSetupRequest_EmailTemplate>(
                "UpdateEmailsSetupRequest.EmailTemplate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateEmailsSetupRequest_EmailTemplate {
        static instance: ::protobuf::rt::LazyV2<UpdateEmailsSetupRequest_EmailTemplate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateEmailsSetupRequest_EmailTemplate::new)
    }
}

impl ::protobuf::Clear for UpdateEmailsSetupRequest_EmailTemplate {
    fn clear(&mut self) {
        self.content.clear();
        self.subject.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateEmailsSetupRequest_EmailTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEmailsSetupRequest_EmailTemplate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateEmailsSetupRequest_EmailSender {
    // message fields
    pub email_address: ::std::string::String,
    pub smtp_host: ::std::string::String,
    pub smtp_port: u32,
    pub smtp_username: ::std::string::String,
    pub smtp_password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateEmailsSetupRequest_EmailSender {
    fn default() -> &'a UpdateEmailsSetupRequest_EmailSender {
        <UpdateEmailsSetupRequest_EmailSender as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEmailsSetupRequest_EmailSender {
    pub fn new() -> UpdateEmailsSetupRequest_EmailSender {
        ::std::default::Default::default()
    }

    // string email_address = 1;


    pub fn get_email_address(&self) -> &str {
        &self.email_address
    }
    pub fn clear_email_address(&mut self) {
        self.email_address.clear();
    }

    // Param is passed by value, moved
    pub fn set_email_address(&mut self, v: ::std::string::String) {
        self.email_address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_address(&mut self) -> &mut ::std::string::String {
        &mut self.email_address
    }

    // Take field
    pub fn take_email_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.email_address, ::std::string::String::new())
    }

    // string smtp_host = 2;


    pub fn get_smtp_host(&self) -> &str {
        &self.smtp_host
    }
    pub fn clear_smtp_host(&mut self) {
        self.smtp_host.clear();
    }

    // Param is passed by value, moved
    pub fn set_smtp_host(&mut self, v: ::std::string::String) {
        self.smtp_host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_smtp_host(&mut self) -> &mut ::std::string::String {
        &mut self.smtp_host
    }

    // Take field
    pub fn take_smtp_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.smtp_host, ::std::string::String::new())
    }

    // uint32 smtp_port = 3;


    pub fn get_smtp_port(&self) -> u32 {
        self.smtp_port
    }
    pub fn clear_smtp_port(&mut self) {
        self.smtp_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_smtp_port(&mut self, v: u32) {
        self.smtp_port = v;
    }

    // string smtp_username = 4;


    pub fn get_smtp_username(&self) -> &str {
        &self.smtp_username
    }
    pub fn clear_smtp_username(&mut self) {
        self.smtp_username.clear();
    }

    // Param is passed by value, moved
    pub fn set_smtp_username(&mut self, v: ::std::string::String) {
        self.smtp_username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_smtp_username(&mut self) -> &mut ::std::string::String {
        &mut self.smtp_username
    }

    // Take field
    pub fn take_smtp_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.smtp_username, ::std::string::String::new())
    }

    // string smtp_password = 5;


    pub fn get_smtp_password(&self) -> &str {
        &self.smtp_password
    }
    pub fn clear_smtp_password(&mut self) {
        self.smtp_password.clear();
    }

    // Param is passed by value, moved
    pub fn set_smtp_password(&mut self, v: ::std::string::String) {
        self.smtp_password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_smtp_password(&mut self) -> &mut ::std::string::String {
        &mut self.smtp_password
    }

    // Take field
    pub fn take_smtp_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.smtp_password, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateEmailsSetupRequest_EmailSender {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.email_address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.smtp_host)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.smtp_port = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.smtp_username)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.smtp_password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.email_address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.email_address);
        }
        if !self.smtp_host.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.smtp_host);
        }
        if self.smtp_port != 0 {
            my_size += ::protobuf::rt::value_size(3, self.smtp_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.smtp_username.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.smtp_username);
        }
        if !self.smtp_password.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.smtp_password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.email_address.is_empty() {
            os.write_string(1, &self.email_address)?;
        }
        if !self.smtp_host.is_empty() {
            os.write_string(2, &self.smtp_host)?;
        }
        if self.smtp_port != 0 {
            os.write_uint32(3, self.smtp_port)?;
        }
        if !self.smtp_username.is_empty() {
            os.write_string(4, &self.smtp_username)?;
        }
        if !self.smtp_password.is_empty() {
            os.write_string(5, &self.smtp_password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateEmailsSetupRequest_EmailSender {
        UpdateEmailsSetupRequest_EmailSender::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "email_address",
                |m: &UpdateEmailsSetupRequest_EmailSender| { &m.email_address },
                |m: &mut UpdateEmailsSetupRequest_EmailSender| { &mut m.email_address },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "smtp_host",
                |m: &UpdateEmailsSetupRequest_EmailSender| { &m.smtp_host },
                |m: &mut UpdateEmailsSetupRequest_EmailSender| { &mut m.smtp_host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "smtp_port",
                |m: &UpdateEmailsSetupRequest_EmailSender| { &m.smtp_port },
                |m: &mut UpdateEmailsSetupRequest_EmailSender| { &mut m.smtp_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "smtp_username",
                |m: &UpdateEmailsSetupRequest_EmailSender| { &m.smtp_username },
                |m: &mut UpdateEmailsSetupRequest_EmailSender| { &mut m.smtp_username },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "smtp_password",
                |m: &UpdateEmailsSetupRequest_EmailSender| { &m.smtp_password },
                |m: &mut UpdateEmailsSetupRequest_EmailSender| { &mut m.smtp_password },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateEmailsSetupRequest_EmailSender>(
                "UpdateEmailsSetupRequest.EmailSender",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateEmailsSetupRequest_EmailSender {
        static instance: ::protobuf::rt::LazyV2<UpdateEmailsSetupRequest_EmailSender> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateEmailsSetupRequest_EmailSender::new)
    }
}

impl ::protobuf::Clear for UpdateEmailsSetupRequest_EmailSender {
    fn clear(&mut self) {
        self.email_address.clear();
        self.smtp_host.clear();
        self.smtp_port = 0;
        self.smtp_username.clear();
        self.smtp_password.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateEmailsSetupRequest_EmailSender {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEmailsSetupRequest_EmailSender {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateEmailsSetupResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateEmailsSetupResponse {
    fn default() -> &'a UpdateEmailsSetupResponse {
        <UpdateEmailsSetupResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEmailsSetupResponse {
    pub fn new() -> UpdateEmailsSetupResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UpdateEmailsSetupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateEmailsSetupResponse {
        UpdateEmailsSetupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateEmailsSetupResponse>(
                "UpdateEmailsSetupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateEmailsSetupResponse {
        static instance: ::protobuf::rt::LazyV2<UpdateEmailsSetupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateEmailsSetupResponse::new)
    }
}

impl ::protobuf::Clear for UpdateEmailsSetupResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateEmailsSetupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEmailsSetupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetUserBaseStatisticsRequest {
    // message fields
    pub days_before: u32,
    pub lifetime_start_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub lifetime_end_at: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetUserBaseStatisticsRequest {
    fn default() -> &'a GetUserBaseStatisticsRequest {
        <GetUserBaseStatisticsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetUserBaseStatisticsRequest {
    pub fn new() -> GetUserBaseStatisticsRequest {
        ::std::default::Default::default()
    }

    // uint32 days_before = 1;


    pub fn get_days_before(&self) -> u32 {
        self.days_before
    }
    pub fn clear_days_before(&mut self) {
        self.days_before = 0;
    }

    // Param is passed by value, moved
    pub fn set_days_before(&mut self, v: u32) {
        self.days_before = v;
    }

    // .google.protobuf.Timestamp lifetime_start_at = 2;


    pub fn get_lifetime_start_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.lifetime_start_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lifetime_start_at(&mut self) {
        self.lifetime_start_at.clear();
    }

    pub fn has_lifetime_start_at(&self) -> bool {
        self.lifetime_start_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_start_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.lifetime_start_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lifetime_start_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.lifetime_start_at.is_none() {
            self.lifetime_start_at.set_default();
        }
        self.lifetime_start_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_lifetime_start_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.lifetime_start_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp lifetime_end_at = 3;


    pub fn get_lifetime_end_at(&self) -> &::protobuf::well_known_types::Timestamp {
        self.lifetime_end_at.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lifetime_end_at(&mut self) {
        self.lifetime_end_at.clear();
    }

    pub fn has_lifetime_end_at(&self) -> bool {
        self.lifetime_end_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifetime_end_at(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.lifetime_end_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lifetime_end_at(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.lifetime_end_at.is_none() {
            self.lifetime_end_at.set_default();
        }
        self.lifetime_end_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_lifetime_end_at(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.lifetime_end_at.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for GetUserBaseStatisticsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.lifetime_start_at {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lifetime_end_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.days_before = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lifetime_start_at)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lifetime_end_at)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.days_before != 0 {
            my_size += ::protobuf::rt::value_size(1, self.days_before, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.lifetime_start_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lifetime_end_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.days_before != 0 {
            os.write_uint32(1, self.days_before)?;
        }
        if let Some(ref v) = self.lifetime_start_at.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lifetime_end_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetUserBaseStatisticsRequest {
        GetUserBaseStatisticsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "days_before",
                |m: &GetUserBaseStatisticsRequest| { &m.days_before },
                |m: &mut GetUserBaseStatisticsRequest| { &mut m.days_before },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "lifetime_start_at",
                |m: &GetUserBaseStatisticsRequest| { &m.lifetime_start_at },
                |m: &mut GetUserBaseStatisticsRequest| { &mut m.lifetime_start_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "lifetime_end_at",
                |m: &GetUserBaseStatisticsRequest| { &m.lifetime_end_at },
                |m: &mut GetUserBaseStatisticsRequest| { &mut m.lifetime_end_at },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetUserBaseStatisticsRequest>(
                "GetUserBaseStatisticsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetUserBaseStatisticsRequest {
        static instance: ::protobuf::rt::LazyV2<GetUserBaseStatisticsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetUserBaseStatisticsRequest::new)
    }
}

impl ::protobuf::Clear for GetUserBaseStatisticsRequest {
    fn clear(&mut self) {
        self.days_before = 0;
        self.lifetime_start_at.clear();
        self.lifetime_end_at.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetUserBaseStatisticsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserBaseStatisticsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetUserBaseStatisticsResponse {
    // message fields
    pub total_users: i32,
    pub users_per_day: ::std::collections::HashMap<::std::string::String, i32>,
    pub sessions_per_day: ::std::collections::HashMap<::std::string::String, i32>,
    pub total_active_users: i32,
    pub total_lifetime_used: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetUserBaseStatisticsResponse {
    fn default() -> &'a GetUserBaseStatisticsResponse {
        <GetUserBaseStatisticsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetUserBaseStatisticsResponse {
    pub fn new() -> GetUserBaseStatisticsResponse {
        ::std::default::Default::default()
    }

    // int32 total_users = 1;


    pub fn get_total_users(&self) -> i32 {
        self.total_users
    }
    pub fn clear_total_users(&mut self) {
        self.total_users = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_users(&mut self, v: i32) {
        self.total_users = v;
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetUserBaseStatisticsResponse.UsersPerDayEntry users_per_day = 2;


    pub fn get_users_per_day(&self) -> &::std::collections::HashMap<::std::string::String, i32> {
        &self.users_per_day
    }
    pub fn clear_users_per_day(&mut self) {
        self.users_per_day.clear();
    }

    // Param is passed by value, moved
    pub fn set_users_per_day(&mut self, v: ::std::collections::HashMap<::std::string::String, i32>) {
        self.users_per_day = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users_per_day(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i32> {
        &mut self.users_per_day
    }

    // Take field
    pub fn take_users_per_day(&mut self) -> ::std::collections::HashMap<::std::string::String, i32> {
        ::std::mem::replace(&mut self.users_per_day, ::std::collections::HashMap::new())
    }

    // repeated .depot.devtools.auth.v0.identity.admin.GetUserBaseStatisticsResponse.SessionsPerDayEntry sessions_per_day = 3;


    pub fn get_sessions_per_day(&self) -> &::std::collections::HashMap<::std::string::String, i32> {
        &self.sessions_per_day
    }
    pub fn clear_sessions_per_day(&mut self) {
        self.sessions_per_day.clear();
    }

    // Param is passed by value, moved
    pub fn set_sessions_per_day(&mut self, v: ::std::collections::HashMap<::std::string::String, i32>) {
        self.sessions_per_day = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sessions_per_day(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, i32> {
        &mut self.sessions_per_day
    }

    // Take field
    pub fn take_sessions_per_day(&mut self) -> ::std::collections::HashMap<::std::string::String, i32> {
        ::std::mem::replace(&mut self.sessions_per_day, ::std::collections::HashMap::new())
    }

    // int32 total_active_users = 4;


    pub fn get_total_active_users(&self) -> i32 {
        self.total_active_users
    }
    pub fn clear_total_active_users(&mut self) {
        self.total_active_users = 0;
    }

    // Param is passed by value, moved
    pub fn set_total_active_users(&mut self, v: i32) {
        self.total_active_users = v;
    }

    // double total_lifetime_used = 5;


    pub fn get_total_lifetime_used(&self) -> f64 {
        self.total_lifetime_used
    }
    pub fn clear_total_lifetime_used(&mut self) {
        self.total_lifetime_used = 0.;
    }

    // Param is passed by value, moved
    pub fn set_total_lifetime_used(&mut self, v: f64) {
        self.total_lifetime_used = v;
    }
}

impl ::protobuf::Message for GetUserBaseStatisticsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_users = tmp;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.users_per_day)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.sessions_per_day)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_active_users = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.total_lifetime_used = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.total_users != 0 {
            my_size += ::protobuf::rt::value_size(1, self.total_users, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(2, &self.users_per_day);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(3, &self.sessions_per_day);
        if self.total_active_users != 0 {
            my_size += ::protobuf::rt::value_size(4, self.total_active_users, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_lifetime_used != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.total_users != 0 {
            os.write_int32(1, self.total_users)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(2, &self.users_per_day, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(3, &self.sessions_per_day, os)?;
        if self.total_active_users != 0 {
            os.write_int32(4, self.total_active_users)?;
        }
        if self.total_lifetime_used != 0. {
            os.write_double(5, self.total_lifetime_used)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetUserBaseStatisticsResponse {
        GetUserBaseStatisticsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total_users",
                |m: &GetUserBaseStatisticsResponse| { &m.total_users },
                |m: &mut GetUserBaseStatisticsResponse| { &mut m.total_users },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(
                "users_per_day",
                |m: &GetUserBaseStatisticsResponse| { &m.users_per_day },
                |m: &mut GetUserBaseStatisticsResponse| { &mut m.users_per_day },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeInt32>(
                "sessions_per_day",
                |m: &GetUserBaseStatisticsResponse| { &m.sessions_per_day },
                |m: &mut GetUserBaseStatisticsResponse| { &mut m.sessions_per_day },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "total_active_users",
                |m: &GetUserBaseStatisticsResponse| { &m.total_active_users },
                |m: &mut GetUserBaseStatisticsResponse| { &mut m.total_active_users },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "total_lifetime_used",
                |m: &GetUserBaseStatisticsResponse| { &m.total_lifetime_used },
                |m: &mut GetUserBaseStatisticsResponse| { &mut m.total_lifetime_used },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetUserBaseStatisticsResponse>(
                "GetUserBaseStatisticsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetUserBaseStatisticsResponse {
        static instance: ::protobuf::rt::LazyV2<GetUserBaseStatisticsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetUserBaseStatisticsResponse::new)
    }
}

impl ::protobuf::Clear for GetUserBaseStatisticsResponse {
    fn clear(&mut self) {
        self.total_users = 0;
        self.users_per_day.clear();
        self.sessions_per_day.clear();
        self.total_active_users = 0;
        self.total_lifetime_used = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetUserBaseStatisticsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserBaseStatisticsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ClientType {
    CLIENT_TYPE_UNSET = 0,
    CLIENT_FIRST_PARTY = 1,
    CLIENT_THIRD_PARTY = 2,
    CLIENT_SYSTEM_PARTY = 3,
}

impl ::protobuf::ProtobufEnum for ClientType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClientType> {
        match value {
            0 => ::std::option::Option::Some(ClientType::CLIENT_TYPE_UNSET),
            1 => ::std::option::Option::Some(ClientType::CLIENT_FIRST_PARTY),
            2 => ::std::option::Option::Some(ClientType::CLIENT_THIRD_PARTY),
            3 => ::std::option::Option::Some(ClientType::CLIENT_SYSTEM_PARTY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ClientType] = &[
            ClientType::CLIENT_TYPE_UNSET,
            ClientType::CLIENT_FIRST_PARTY,
            ClientType::CLIENT_THIRD_PARTY,
            ClientType::CLIENT_SYSTEM_PARTY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ClientType>("ClientType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ClientType {
}

impl ::std::default::Default for ClientType {
    fn default() -> Self {
        ClientType::CLIENT_TYPE_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SubjectType {
    SUBJECT_TYPE_PUBLIC = 0,
    SUBJECT_TYPE_PAIRWISE = 1,
}

impl ::protobuf::ProtobufEnum for SubjectType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SubjectType> {
        match value {
            0 => ::std::option::Option::Some(SubjectType::SUBJECT_TYPE_PUBLIC),
            1 => ::std::option::Option::Some(SubjectType::SUBJECT_TYPE_PAIRWISE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SubjectType] = &[
            SubjectType::SUBJECT_TYPE_PUBLIC,
            SubjectType::SUBJECT_TYPE_PAIRWISE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SubjectType>("SubjectType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SubjectType {
}

impl ::std::default::Default for SubjectType {
    fn default() -> Self {
        SubjectType::SUBJECT_TYPE_PUBLIC
    }
}

impl ::protobuf::reflect::ProtobufValue for SubjectType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TokenEndpointAuthMethod {
    TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC = 0,
    TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_POST = 1,
    TOKEN_ENDPOINT_AUTH_METHOD_PRIVATE_KEY_JWT = 2,
    TOKEN_ENDPOINT_AUTH_METHOD_NONE = 3,
}

impl ::protobuf::ProtobufEnum for TokenEndpointAuthMethod {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TokenEndpointAuthMethod> {
        match value {
            0 => ::std::option::Option::Some(TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC),
            1 => ::std::option::Option::Some(TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_POST),
            2 => ::std::option::Option::Some(TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_PRIVATE_KEY_JWT),
            3 => ::std::option::Option::Some(TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_NONE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TokenEndpointAuthMethod] = &[
            TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC,
            TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_POST,
            TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_PRIVATE_KEY_JWT,
            TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_NONE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TokenEndpointAuthMethod>("TokenEndpointAuthMethod", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TokenEndpointAuthMethod {
}

impl ::std::default::Default for TokenEndpointAuthMethod {
    fn default() -> Self {
        TokenEndpointAuthMethod::TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenEndpointAuthMethod {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TokenEndpointAuthSigningAlg {
    TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET = 0,
    TOKEN_ENDPOINT_AUTH_SIGNING_ALG_RS256 = 1,
    TOKEN_ENDPOINT_AUTH_SIGNING_ALG_RS384 = 2,
    TOKEN_ENDPOINT_AUTH_SIGNING_ALG_RS512 = 3,
    TOKEN_ENDPOINT_AUTH_SIGNING_ALG_PS256 = 4,
    TOKEN_ENDPOINT_AUTH_SIGNING_ALG_PS384 = 5,
    TOKEN_ENDPOINT_AUTH_SIGNING_ALG_PS512 = 6,
    TOKEN_ENDPOINT_AUTH_SIGNING_ALG_ES256 = 7,
    TOKEN_ENDPOINT_AUTH_SIGNING_ALG_ES384 = 8,
    TOKEN_ENDPOINT_AUTH_SIGNING_ALG_ES512 = 9,
}

impl ::protobuf::ProtobufEnum for TokenEndpointAuthSigningAlg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TokenEndpointAuthSigningAlg> {
        match value {
            0 => ::std::option::Option::Some(TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET),
            1 => ::std::option::Option::Some(TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_RS256),
            2 => ::std::option::Option::Some(TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_RS384),
            3 => ::std::option::Option::Some(TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_RS512),
            4 => ::std::option::Option::Some(TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_PS256),
            5 => ::std::option::Option::Some(TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_PS384),
            6 => ::std::option::Option::Some(TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_PS512),
            7 => ::std::option::Option::Some(TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_ES256),
            8 => ::std::option::Option::Some(TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_ES384),
            9 => ::std::option::Option::Some(TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_ES512),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TokenEndpointAuthSigningAlg] = &[
            TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET,
            TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_RS256,
            TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_RS384,
            TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_RS512,
            TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_PS256,
            TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_PS384,
            TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_PS512,
            TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_ES256,
            TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_ES384,
            TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_ES512,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TokenEndpointAuthSigningAlg>("TokenEndpointAuthSigningAlg", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TokenEndpointAuthSigningAlg {
}

impl ::std::default::Default for TokenEndpointAuthSigningAlg {
    fn default() -> Self {
        TokenEndpointAuthSigningAlg::TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenEndpointAuthSigningAlg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GrantType {
    GRANT_TYPE_UNSET = 0,
    GRANT_TYPE_CLIENT_CREDENTIALS = 1,
    GRANT_TYPE_AUTHORIZATION_CODE = 2,
    GRANT_TYPE_IMPLICIT = 3,
    GRANT_TYPE_REFRESH_TOKEN = 4,
    GRANT_TYPE_DEVICE_CODE = 5,
}

impl ::protobuf::ProtobufEnum for GrantType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GrantType> {
        match value {
            0 => ::std::option::Option::Some(GrantType::GRANT_TYPE_UNSET),
            1 => ::std::option::Option::Some(GrantType::GRANT_TYPE_CLIENT_CREDENTIALS),
            2 => ::std::option::Option::Some(GrantType::GRANT_TYPE_AUTHORIZATION_CODE),
            3 => ::std::option::Option::Some(GrantType::GRANT_TYPE_IMPLICIT),
            4 => ::std::option::Option::Some(GrantType::GRANT_TYPE_REFRESH_TOKEN),
            5 => ::std::option::Option::Some(GrantType::GRANT_TYPE_DEVICE_CODE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GrantType] = &[
            GrantType::GRANT_TYPE_UNSET,
            GrantType::GRANT_TYPE_CLIENT_CREDENTIALS,
            GrantType::GRANT_TYPE_AUTHORIZATION_CODE,
            GrantType::GRANT_TYPE_IMPLICIT,
            GrantType::GRANT_TYPE_REFRESH_TOKEN,
            GrantType::GRANT_TYPE_DEVICE_CODE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GrantType>("GrantType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GrantType {
}

impl ::std::default::Default for GrantType {
    fn default() -> Self {
        GrantType::GRANT_TYPE_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for GrantType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResponseType {
    RESPONSE_TYPE_UNSET = 0,
    RESPONSE_TYPE_NONE = 1,
    RESPONSE_TYPE_ID_TOKEN = 2,
    RESPONSE_TYPE_TOKEN = 3,
    RESPONSE_TYPE_CODE = 4,
    RESPONSE_TYPE_ID_TOKEN_TOKEN = 5,
    RESPONSE_TYPE_CODE_ID_TOKEN = 6,
    RESPONSE_TYPE_CODE_TOKEN = 7,
    RESPONSE_TYPE_CODE_ID_TOKEN_TOKEN = 8,
}

impl ::protobuf::ProtobufEnum for ResponseType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseType> {
        match value {
            0 => ::std::option::Option::Some(ResponseType::RESPONSE_TYPE_UNSET),
            1 => ::std::option::Option::Some(ResponseType::RESPONSE_TYPE_NONE),
            2 => ::std::option::Option::Some(ResponseType::RESPONSE_TYPE_ID_TOKEN),
            3 => ::std::option::Option::Some(ResponseType::RESPONSE_TYPE_TOKEN),
            4 => ::std::option::Option::Some(ResponseType::RESPONSE_TYPE_CODE),
            5 => ::std::option::Option::Some(ResponseType::RESPONSE_TYPE_ID_TOKEN_TOKEN),
            6 => ::std::option::Option::Some(ResponseType::RESPONSE_TYPE_CODE_ID_TOKEN),
            7 => ::std::option::Option::Some(ResponseType::RESPONSE_TYPE_CODE_TOKEN),
            8 => ::std::option::Option::Some(ResponseType::RESPONSE_TYPE_CODE_ID_TOKEN_TOKEN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResponseType] = &[
            ResponseType::RESPONSE_TYPE_UNSET,
            ResponseType::RESPONSE_TYPE_NONE,
            ResponseType::RESPONSE_TYPE_ID_TOKEN,
            ResponseType::RESPONSE_TYPE_TOKEN,
            ResponseType::RESPONSE_TYPE_CODE,
            ResponseType::RESPONSE_TYPE_ID_TOKEN_TOKEN,
            ResponseType::RESPONSE_TYPE_CODE_ID_TOKEN,
            ResponseType::RESPONSE_TYPE_CODE_TOKEN,
            ResponseType::RESPONSE_TYPE_CODE_ID_TOKEN_TOKEN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResponseType>("ResponseType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResponseType {
}

impl ::std::default::Default for ResponseType {
    fn default() -> Self {
        ResponseType::RESPONSE_TYPE_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RequestObjectSigningAlg {
    REQUEST_OBJECT_SIGNING_ALG_UNSET = 0,
    REQUEST_OBJECT_SIGNING_ALG_NONE = 1,
    REQUEST_OBJECT_SIGNING_ALG_RS256 = 2,
}

impl ::protobuf::ProtobufEnum for RequestObjectSigningAlg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RequestObjectSigningAlg> {
        match value {
            0 => ::std::option::Option::Some(RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET),
            1 => ::std::option::Option::Some(RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_NONE),
            2 => ::std::option::Option::Some(RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_RS256),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RequestObjectSigningAlg] = &[
            RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET,
            RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_NONE,
            RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_RS256,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RequestObjectSigningAlg>("RequestObjectSigningAlg", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RequestObjectSigningAlg {
}

impl ::std::default::Default for RequestObjectSigningAlg {
    fn default() -> Self {
        RequestObjectSigningAlg::REQUEST_OBJECT_SIGNING_ALG_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for RequestObjectSigningAlg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UserinfoSignedResponseAlg {
    USERINFO_SIGNED_RESPONSE_ALG_UNSET = 0,
    USERINFO_SIGNED_RESPONSE_ALG_NONE = 1,
    USERINFO_SIGNED_RESPONSE_ALG_RS256 = 2,
}

impl ::protobuf::ProtobufEnum for UserinfoSignedResponseAlg {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UserinfoSignedResponseAlg> {
        match value {
            0 => ::std::option::Option::Some(UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET),
            1 => ::std::option::Option::Some(UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_NONE),
            2 => ::std::option::Option::Some(UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_RS256),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UserinfoSignedResponseAlg] = &[
            UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET,
            UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_NONE,
            UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_RS256,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UserinfoSignedResponseAlg>("UserinfoSignedResponseAlg", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UserinfoSignedResponseAlg {
}

impl ::std::default::Default for UserinfoSignedResponseAlg {
    fn default() -> Self {
        UserinfoSignedResponseAlg::USERINFO_SIGNED_RESPONSE_ALG_UNSET
    }
}

impl ::protobuf::reflect::ProtobufValue for UserinfoSignedResponseAlg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n1identity/admin/admin.proto\x12%depot.devtools.\
    auth.v0.identity.admin\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1cgoo\
    gle/protobuf/struct.proto\"\x86\x01\n\x15CreateIdentityRequest\x12+\n\
    \x04data\x18\x01\x20\x01(\x0b2\x17.google.protobuf.StructR\x04data\x12#\
    \n\rconnection_id\x18\x02\x20\x01(\tR\x0cconnectionId\x12\x1b\n\tschema_\
    id\x18\x03\x20\x01(\tR\x08schemaId\"9\n\x16CreateIdentityResponse\x12\
    \x1f\n\x0bidentity_id\x18\x01\x20\x01(\tR\nidentityId\"R\n\x14GetIdentit\
    iesRequest\x12\x1b\n\tpage_size\x18\x01\x20\x01(\x05R\x08pageSize\x12\
    \x1d\n\npage_token\x18\x02\x20\x01(\tR\tpageToken\"\xae\x04\n\x15GetIden\
    titiesResponse\x12e\n\nidentities\x18\x01\x20\x03(\x0b2E.depot.devtools.\
    auth.v0.identity.admin.GetIdentitiesResponse.IdentityR\nidentities\x12&\
    \n\x0fnext_page_token\x18\x02\x20\x01(\tR\rnextPageToken\x12\x1d\n\ntota\
    l_size\x18\x03\x20\x01(\x05R\ttotalSize\x1a\xbe\x02\n\x08Identity\x12\
    \x1f\n\x0bidentity_id\x18\x01\x20\x01(\tR\nidentityId\x129\n\ncreated_at\
    \x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n\
    \nupdated_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tupdat\
    edAt\x12'\n\x0fmain_identifier\x18\x04\x20\x01(\tR\x0emainIdentifier\x12\
    \x1b\n\tschema_id\x18\x05\x20\x01(\tR\x08schemaId\x12U\n\x04lock\x18\x06\
    \x20\x01(\x0e2A.depot.devtools.auth.v0.identity.admin.GetIdentitiesRespo\
    nse.LockR\x04lock\"&\n\x04Lock\x12\x0c\n\x08UNLOCKED\x10\0\x12\x10\n\x0c\
    ADMIN_LOCKED\x10\x01\"5\n\x12GetIdentityRequest\x12\x1f\n\x0bidentity_id\
    \x18\x02\x20\x01(\tR\nidentityId\"\xed\x04\n\x13GetIdentityResponse\x12\
    \x1f\n\x0bidentity_id\x18\x01\x20\x01(\tR\nidentityId\x129\n\ncreated_at\
    \x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n\
    \nupdated_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tupdat\
    edAt\x12'\n\x0fmain_identifier\x18\x04\x20\x01(\tR\x0emainIdentifier\x12\
    \x1b\n\ttraits_id\x18\x05\x20\x01(\tR\x08traitsId\x12#\n\raddresses_ids\
    \x18\x06\x20\x03(\tR\x0caddressesIds\x12w\n\x0fcredentials_ids\x18\x07\
    \x20\x03(\x0b2N.depot.devtools.auth.v0.identity.admin.GetIdentityRespons\
    e.CredentialsIdsEntryR\x0ecredentialsIds\x12\x1b\n\tschema_id\x18\x08\
    \x20\x01(\tR\x08schemaId\x12S\n\x04lock\x18\t\x20\x01(\x0e2?.depot.devto\
    ols.auth.v0.identity.admin.GetIdentityResponse.LockR\x04lock\x1aA\n\x13C\
    redentialsIdsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"&\n\x04Lock\x12\x0c\n\
    \x08UNLOCKED\x10\0\x12\x10\n\x0cADMIN_LOCKED\x10\x01\"y\n\x1eGetIdentity\
    ByIdentifierRequest\x12\x1c\n\tattribute\x18\x01\x20\x01(\tR\tattribute\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x12#\n\rconnection_id\
    \x18\x03\x20\x01(\tR\x0cconnectionId\"\x9e\x06\n\x1fGetIdentityByIdentif\
    ierResponse\x12k\n\x08identity\x18\x01\x20\x01(\x0b2O.depot.devtools.aut\
    h.v0.identity.admin.GetIdentityByIdentifierResponse.IdentityR\x08identit\
    y\x1a\x8d\x05\n\x08Identity\x12\x1f\n\x0bidentity_id\x18\x01\x20\x01(\tR\
    \nidentityId\x129\n\ncreated_at\x18\x02\x20\x01(\x0b2\x1a.google.protobu\
    f.TimestampR\tcreatedAt\x129\n\nupdated_at\x18\x03\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.TimestampR\tupdatedAt\x12'\n\x0fmain_identifier\x18\x04\x20\
    \x01(\tR\x0emainIdentifier\x12\x1b\n\ttraits_id\x18\x05\x20\x01(\tR\x08t\
    raitsId\x12#\n\raddresses_ids\x18\x06\x20\x03(\tR\x0caddressesIds\x12\
    \x8c\x01\n\x0fcredentials_ids\x18\x07\x20\x03(\x0b2c.depot.devtools.auth\
    .v0.identity.admin.GetIdentityByIdentifierResponse.Identity.CredentialsI\
    dsEntryR\x0ecredentialsIds\x12\x1b\n\tschema_id\x18\x08\x20\x01(\tR\x08s\
    chemaId\x12h\n\x04lock\x18\t\x20\x01(\x0e2T.depot.devtools.auth.v0.ident\
    ity.admin.GetIdentityByIdentifierResponse.Identity.LockR\x04lock\x1aA\n\
    \x13CredentialsIdsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"&\n\x04Lock\x12\
    \x0c\n\x08UNLOCKED\x10\0\x12\x10\n\x0cADMIN_LOCKED\x10\x01\"U\n\x1fGetId\
    entitiesByAttributeRequest\x12\x1c\n\tattribute\x18\x01\x20\x01(\tR\tatt\
    ribute\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\xa6\x06\n\x20Ge\
    tIdentitiesByAttributeResponse\x12p\n\nidentities\x18\x01\x20\x03(\x0b2P\
    .depot.devtools.auth.v0.identity.admin.GetIdentitiesByAttributeResponse.\
    IdentityR\nidentities\x1a\x8f\x05\n\x08Identity\x12\x1f\n\x0bidentity_id\
    \x18\x01\x20\x01(\tR\nidentityId\x129\n\ncreated_at\x18\x02\x20\x01(\x0b\
    2\x1a.google.protobuf.TimestampR\tcreatedAt\x129\n\nupdated_at\x18\x03\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tupdatedAt\x12'\n\x0fmain_\
    identifier\x18\x04\x20\x01(\tR\x0emainIdentifier\x12\x1b\n\ttraits_id\
    \x18\x05\x20\x01(\tR\x08traitsId\x12#\n\raddresses_ids\x18\x06\x20\x03(\
    \tR\x0caddressesIds\x12\x8d\x01\n\x0fcredentials_ids\x18\x07\x20\x03(\
    \x0b2d.depot.devtools.auth.v0.identity.admin.GetIdentitiesByAttributeRes\
    ponse.Identity.CredentialsIdsEntryR\x0ecredentialsIds\x12\x1b\n\tschema_\
    id\x18\x08\x20\x01(\tR\x08schemaId\x12i\n\x04lock\x18\t\x20\x01(\x0e2U.d\
    epot.devtools.auth.v0.identity.admin.GetIdentitiesByAttributeResponse.Id\
    entity.LockR\x04lock\x1aA\n\x13CredentialsIdsEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\
    \x028\x01\"&\n\x04Lock\x12\x0c\n\x08UNLOCKED\x10\0\x12\x10\n\x0cADMIN_LO\
    CKED\x10\x01\"\xb7\x01\n\x15UpdateIdentityRequest\x12\x1f\n\x0bidentity_\
    id\x18\x01\x20\x01(\tR\nidentityId\x12U\n\x04lock\x18\x02\x20\x01(\x0e2A\
    .depot.devtools.auth.v0.identity.admin.UpdateIdentityRequest.LockR\x04lo\
    ck\"&\n\x04Lock\x12\x0c\n\x08UNLOCKED\x10\0\x12\x10\n\x0cADMIN_LOCKED\
    \x10\x01\"\x18\n\x16UpdateIdentityResponse\"8\n\x15DeleteIdentityRequest\
    \x12\x1f\n\x0bidentity_id\x18\x01\x20\x01(\tR\nidentityId\"\x18\n\x16Del\
    eteIdentityResponse\"8\n\x15GetCredentialsRequest\x12\x1f\n\x0bidentity_\
    id\x18\x01\x20\x01(\tR\nidentityId\"\xa8\x04\n\x16GetCredentialsResponse\
    \x12p\n\x0bcredentials\x18\x01\x20\x03(\x0b2N.depot.devtools.auth.v0.ide\
    ntity.admin.GetCredentialsResponse.CredentialsEntryR\x0bcredentials\x1a\
    \x90\x02\n\nCredential\x12#\n\rcredential_id\x18\x01\x20\x01(\tR\x0ccred\
    entialId\x129\n\ncreated_at\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.Ti\
    mestampR\tcreatedAt\x129\n\nupdated_at\x18\x03\x20\x01(\x0b2\x1a.google.\
    protobuf.TimestampR\tupdatedAt\x12\x1f\n\x0bidentity_id\x18\x04\x20\x01(\
    \tR\nidentityId\x12\x12\n\x04type\x18\x05\x20\x01(\x05R\x04type\x12\x12\
    \n\x04name\x18\x06\x20\x01(\tR\x04name\x12\x1e\n\nconfigured\x18\x07\x20\
    \x01(\x08R\nconfigured\x1a\x88\x01\n\x10CredentialsEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12^\n\x05value\x18\x02\x20\x01(\x0b2H.depo\
    t.devtools.auth.v0.identity.admin.GetCredentialsResponse.CredentialR\x05\
    value:\x028\x01\"\x8c\x01\n\x17UpdateCredentialRequest\x12+\n\x04data\
    \x18\x01\x20\x01(\x0b2\x17.google.protobuf.StructR\x04data\x12#\n\rconne\
    ction_id\x18\x02\x20\x01(\tR\x0cconnectionId\x12\x1f\n\x0bidentity_id\
    \x18\x03\x20\x01(\tR\nidentityId\"\x1a\n\x18UpdateCredentialResponse\"\
    \x86\t\n\x17CreateConnectionRequest\x12\x12\n\x04name\x18\x01\x20\x01(\t\
    R\x04name\x12\x1b\n\tclient_id\x18\x02\x20\x01(\tR\x08clientId\x12#\n\rc\
    lient_secret\x18\x03\x20\x01(\tR\x0cclientSecret\x12(\n\x10button_image_\
    url\x18\x04\x20\x01(\tR\x0ebuttonImageUrl\x12d\n\x08provider\x18\x06\x20\
    \x01(\x0e2H.depot.devtools.auth.v0.identity.admin.CreateConnectionReques\
    t.ProvidersR\x08provider\x12,\n\x12oidc_discovery_url\x18\x07\x20\x01(\t\
    R\x10oidcDiscoveryUrl\x12\x10\n\x03mfa\x18\x08\x20\x03(\tR\x03mfa\x12X\n\
    \x04type\x18\t\x20\x01(\x0e2D.depot.devtools.auth.v0.identity.admin.Crea\
    teConnectionRequest.TypesR\x04type\x12\x16\n\x06scopes\x18\n\x20\x01(\tR\
    \x06scopes\"\x93\x05\n\tProviders\x12\x08\n\x04NONE\x10\0\x12\n\n\x06OPE\
    NID\x10\x01\x12\n\n\x06AMAZON\x10\x02\x12\r\n\tBITBUCKET\x10\x03\x12\x07\
    \n\x03BOX\x10\x04\x12\x0f\n\x0bDAILYMOTION\x10\x05\x12\n\n\x06DEEZER\x10\
    \x06\x12\x10\n\x0cDIGITALOCEAN\x10\x07\x12\x0b\n\x07DISCORD\x10\x08\x12\
    \x0b\n\x07DROPBOX\x10\t\x12\r\n\tEVEONLINE\x10\n\x12\x0c\n\x08FACEBOOK\
    \x10\x0b\x12\n\n\x06FITBIT\x10\x0c\x12\t\n\x05GITEA\x10\r\x12\n\n\x06GIT\
    HUB\x10\x0e\x12\n\n\x06GITLAB\x10\x0f\x12\n\n\x06GOOGLE\x10\x10\x12\x0b\
    \n\x07SHOPIFY\x10\x12\x12\x0e\n\nSOUNDCLOUD\x10\x13\x12\x0b\n\x07SPOTIFY\
    \x10\x14\x12\t\n\x05STEAM\x10\x15\x12\n\n\x06STRIPE\x10\x16\x12\n\n\x06T\
    WITCH\x10\x17\x12\x08\n\x04UBER\x10\x18\x12\t\n\x05WEPAY\x10\x19\x12\t\n\
    \x05YAHOO\x10\x1a\x12\n\n\x06YAMMER\x10\x1b\x12\n\n\x06HEROKU\x10\x1c\
    \x12\r\n\tINSTAGRAM\x10\x1d\x12\x0c\n\x08INTERCOM\x10\x1e\x12\t\n\x05KAK\
    AO\x10\x1f\x12\n\n\x06LASTFM\x10\x20\x12\x0c\n\x08LINKEDIN\x10!\x12\x08\
    \n\x04LINE\x10\"\x12\x0c\n\x08ONEDRIVE\x10#\x12\x0b\n\x07AZUREAD\x10$\
    \x12\x13\n\x0fMICROSOFTONLINE\x10%\x12\r\n\tBATTLENET\x10&\x12\n\n\x06PA\
    YPAL\x10'\x12\x0b\n\x07TWITTER\x10(\x12\x0e\n\nSALESFORCE\x10)\x12\x0c\n\
    \x08TYPETALK\x10*\x12\t\n\x05SLACK\x10+\x12\n\n\x06MEETUP\x10,\x12\x08\n\
    \x04XERO\x10.\x12\x06\n\x02VK\x10/\x12\t\n\x05NAVER\x100\x12\n\n\x06YAND\
    EX\x101\x12\r\n\tNEXTCLOUD\x102\x12\t\n\x05APPLE\x104\x12\n\n\x06STRAVA\
    \x105\"=\n\x05Types\x12\t\n\x05UNSET\x10\0\x12\x0c\n\x08PASSWORD\x10\x01\
    \x12\x07\n\x03OTP\x10\x02\x12\x08\n\x04TOTP\x10\x03\x12\x08\n\x04OIDC\
    \x10\x04\".\n\x18CreateConnectionResponse\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\"\x17\n\x15GetConnectionsRequest\"\xc5\x0b\n\x16GetConn\
    ectionsResponse\x12j\n\x0bconnections\x18\x01\x20\x03(\x0b2H.depot.devto\
    ols.auth.v0.identity.admin.GetConnectionsResponse.ConnectionR\x0bconnect\
    ions\x1a\x94\x04\n\nConnection\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04\
    name\x12\x1b\n\tclient_id\x18\x02\x20\x01(\tR\x08clientId\x12#\n\rclient\
    _secret\x18\x03\x20\x01(\tR\x0cclientSecret\x12(\n\x10button_image_url\
    \x18\x04\x20\x01(\tR\x0ebuttonImageUrl\x12c\n\x08provider\x18\x06\x20\
    \x01(\x0e2G.depot.devtools.auth.v0.identity.admin.GetConnectionsResponse\
    .ProvidersR\x08provider\x12,\n\x12oidc_discovery_url\x18\x07\x20\x01(\tR\
    \x10oidcDiscoveryUrl\x12\x10\n\x03mfa\x18\x08\x20\x03(\tR\x03mfa\x12W\n\
    \x04type\x18\t\x20\x01(\x0e2C.depot.devtools.auth.v0.identity.admin.GetC\
    onnectionsResponse.TypesR\x04type\x12\x0e\n\x02id\x18\n\x20\x01(\tR\x02i\
    d\x12\x16\n\x06scopes\x18\x0b\x20\x01(\tR\x06scopes\x12`\n\x07purpose\
    \x18\x0c\x20\x01(\x0e2F.depot.devtools.auth.v0.identity.admin.GetConnect\
    ionsResponse.PurposesR\x07purpose\"\x93\x05\n\tProviders\x12\x08\n\x04NO\
    NE\x10\0\x12\n\n\x06OPENID\x10\x01\x12\n\n\x06AMAZON\x10\x02\x12\r\n\tBI\
    TBUCKET\x10\x03\x12\x07\n\x03BOX\x10\x04\x12\x0f\n\x0bDAILYMOTION\x10\
    \x05\x12\n\n\x06DEEZER\x10\x06\x12\x10\n\x0cDIGITALOCEAN\x10\x07\x12\x0b\
    \n\x07DISCORD\x10\x08\x12\x0b\n\x07DROPBOX\x10\t\x12\r\n\tEVEONLINE\x10\
    \n\x12\x0c\n\x08FACEBOOK\x10\x0b\x12\n\n\x06FITBIT\x10\x0c\x12\t\n\x05GI\
    TEA\x10\r\x12\n\n\x06GITHUB\x10\x0e\x12\n\n\x06GITLAB\x10\x0f\x12\n\n\
    \x06GOOGLE\x10\x10\x12\x0b\n\x07SHOPIFY\x10\x12\x12\x0e\n\nSOUNDCLOUD\
    \x10\x13\x12\x0b\n\x07SPOTIFY\x10\x14\x12\t\n\x05STEAM\x10\x15\x12\n\n\
    \x06STRIPE\x10\x16\x12\n\n\x06TWITCH\x10\x17\x12\x08\n\x04UBER\x10\x18\
    \x12\t\n\x05WEPAY\x10\x19\x12\t\n\x05YAHOO\x10\x1a\x12\n\n\x06YAMMER\x10\
    \x1b\x12\n\n\x06HEROKU\x10\x1c\x12\r\n\tINSTAGRAM\x10\x1d\x12\x0c\n\x08I\
    NTERCOM\x10\x1e\x12\t\n\x05KAKAO\x10\x1f\x12\n\n\x06LASTFM\x10\x20\x12\
    \x0c\n\x08LINKEDIN\x10!\x12\x08\n\x04LINE\x10\"\x12\x0c\n\x08ONEDRIVE\
    \x10#\x12\x0b\n\x07AZUREAD\x10$\x12\x13\n\x0fMICROSOFTONLINE\x10%\x12\r\
    \n\tBATTLENET\x10&\x12\n\n\x06PAYPAL\x10'\x12\x0b\n\x07TWITTER\x10(\x12\
    \x0e\n\nSALESFORCE\x10)\x12\x0c\n\x08TYPETALK\x10*\x12\t\n\x05SLACK\x10+\
    \x12\n\n\x06MEETUP\x10,\x12\x08\n\x04XERO\x10.\x12\x06\n\x02VK\x10/\x12\
    \t\n\x05NAVER\x100\x12\n\n\x06YANDEX\x101\x12\r\n\tNEXTCLOUD\x102\x12\t\
    \n\x05APPLE\x104\x12\n\n\x06STRAVA\x105\"=\n\x05Types\x12\t\n\x05UNSET\
    \x10\0\x12\x0c\n\x08PASSWORD\x10\x01\x12\x07\n\x03OTP\x10\x02\x12\x08\n\
    \x04TOTP\x10\x03\x12\x08\n\x04OIDC\x10\x04\"S\n\x08Purposes\x12\x13\n\
    \x0fPURPOSE_UNKNOWN\x10\0\x12\x17\n\x13PURPOSE_MAIN_FACTOR\x10\x01\x12\
    \x19\n\x15PURPOSE_SECOND_FACTOR\x10\x02\"\x88\t\n\x17UpdateConnectionReq\
    uest\x12\x1b\n\tclient_id\x18\x02\x20\x01(\tR\x08clientId\x12#\n\rclient\
    _secret\x18\x03\x20\x01(\tR\x0cclientSecret\x12(\n\x10button_image_url\
    \x18\x04\x20\x01(\tR\x0ebuttonImageUrl\x12d\n\x08provider\x18\x06\x20\
    \x01(\x0e2H.depot.devtools.auth.v0.identity.admin.UpdateConnectionReques\
    t.ProvidersR\x08provider\x12,\n\x12oidc_discovery_url\x18\x07\x20\x01(\t\
    R\x10oidcDiscoveryUrl\x12\x10\n\x03mfa\x18\x08\x20\x03(\tR\x03mfa\x12X\n\
    \x04type\x18\t\x20\x01(\x0e2D.depot.devtools.auth.v0.identity.admin.Upda\
    teConnectionRequest.TypesR\x04type\x12\x0e\n\x02id\x18\n\x20\x01(\tR\x02\
    id\x12\x16\n\x06scopes\x18\x0b\x20\x01(\tR\x06scopes\"\x93\x05\n\tProvid\
    ers\x12\x08\n\x04NONE\x10\0\x12\n\n\x06OPENID\x10\x01\x12\n\n\x06AMAZON\
    \x10\x02\x12\r\n\tBITBUCKET\x10\x03\x12\x07\n\x03BOX\x10\x04\x12\x0f\n\
    \x0bDAILYMOTION\x10\x05\x12\n\n\x06DEEZER\x10\x06\x12\x10\n\x0cDIGITALOC\
    EAN\x10\x07\x12\x0b\n\x07DISCORD\x10\x08\x12\x0b\n\x07DROPBOX\x10\t\x12\
    \r\n\tEVEONLINE\x10\n\x12\x0c\n\x08FACEBOOK\x10\x0b\x12\n\n\x06FITBIT\
    \x10\x0c\x12\t\n\x05GITEA\x10\r\x12\n\n\x06GITHUB\x10\x0e\x12\n\n\x06GIT\
    LAB\x10\x0f\x12\n\n\x06GOOGLE\x10\x10\x12\x0b\n\x07SHOPIFY\x10\x12\x12\
    \x0e\n\nSOUNDCLOUD\x10\x13\x12\x0b\n\x07SPOTIFY\x10\x14\x12\t\n\x05STEAM\
    \x10\x15\x12\n\n\x06STRIPE\x10\x16\x12\n\n\x06TWITCH\x10\x17\x12\x08\n\
    \x04UBER\x10\x18\x12\t\n\x05WEPAY\x10\x19\x12\t\n\x05YAHOO\x10\x1a\x12\n\
    \n\x06YAMMER\x10\x1b\x12\n\n\x06HEROKU\x10\x1c\x12\r\n\tINSTAGRAM\x10\
    \x1d\x12\x0c\n\x08INTERCOM\x10\x1e\x12\t\n\x05KAKAO\x10\x1f\x12\n\n\x06L\
    ASTFM\x10\x20\x12\x0c\n\x08LINKEDIN\x10!\x12\x08\n\x04LINE\x10\"\x12\x0c\
    \n\x08ONEDRIVE\x10#\x12\x0b\n\x07AZUREAD\x10$\x12\x13\n\x0fMICROSOFTONLI\
    NE\x10%\x12\r\n\tBATTLENET\x10&\x12\n\n\x06PAYPAL\x10'\x12\x0b\n\x07TWIT\
    TER\x10(\x12\x0e\n\nSALESFORCE\x10)\x12\x0c\n\x08TYPETALK\x10*\x12\t\n\
    \x05SLACK\x10+\x12\n\n\x06MEETUP\x10,\x12\x08\n\x04XERO\x10.\x12\x06\n\
    \x02VK\x10/\x12\t\n\x05NAVER\x100\x12\n\n\x06YANDEX\x101\x12\r\n\tNEXTCL\
    OUD\x102\x12\t\n\x05APPLE\x104\x12\n\n\x06STRAVA\x105\"=\n\x05Types\x12\
    \t\n\x05UNSET\x10\0\x12\x0c\n\x08PASSWORD\x10\x01\x12\x07\n\x03OTP\x10\
    \x02\x12\x08\n\x04TOTP\x10\x03\x12\x08\n\x04OIDC\x10\x04J\x04\x08\x01\
    \x10\x02\"\x1a\n\x18UpdateConnectionResponse\")\n\x17DeleteConnectionReq\
    uest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"\x1a\n\x18DeleteConnecti\
    onResponse\"\x19\n\x17GetOAuth2ClientsRequest\"\xa1\x10\n\x18GetOAuth2Cl\
    ientsResponse\x12`\n\x07clients\x18\x01\x20\x03(\x0b2F.depot.devtools.au\
    th.v0.identity.admin.GetOAuth2ClientsResponse.ClientR\x07clients\x1a\xa2\
    \x0f\n\x06Client\x120\n\x14allowed_cors_origins\x18\x01\x20\x03(\tR\x12a\
    llowedCorsOrigins\x12\x1a\n\x08audience\x18\x02\x20\x03(\tR\x08audience\
    \x12M\n#backchannel_logout_session_required\x18\x03\x20\x01(\x08R\x20bac\
    kchannelLogoutSessionRequired\x124\n\x16backchannel_logout_uri\x18\x04\
    \x20\x01(\tR\x14backchannelLogoutUri\x12\x1b\n\tclient_id\x18\x05\x20\
    \x01(\tR\x08clientId\x12\x1f\n\x0bclient_name\x18\x06\x20\x01(\tR\nclien\
    tName\x127\n\x18client_secret_expires_at\x18\x07\x20\x01(\x03R\x15client\
    SecretExpiresAt\x12\x1d\n\nclient_uri\x18\x08\x20\x01(\tR\tclientUri\x12\
    \x1a\n\x08contacts\x18\t\x20\x03(\tR\x08contacts\x129\n\ncreated_at\x18\
    \n\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12O\n$frontc\
    hannel_logout_session_required\x18\x0b\x20\x01(\x08R!frontchannelLogoutS\
    essionRequired\x126\n\x17frontchannel_logout_uri\x18\x0c\x20\x01(\tR\x15\
    frontchannelLogoutUri\x12Q\n\x0bgrant_types\x18\r\x20\x03(\x0e20.depot.d\
    evtools.auth.v0.identity.admin.GrantTypeR\ngrantTypes\x12+\n\x04jwks\x18\
    \x0e\x20\x01(\x0b2\x17.google.protobuf.StructR\x04jwks\x12\x19\n\x08jwks\
    _uri\x18\x0f\x20\x01(\tR\x07jwksUri\x12\x19\n\x08logo_uri\x18\x10\x20\
    \x01(\tR\x07logoUri\x123\n\x08metadata\x18\x11\x20\x01(\x0b2\x17.google.\
    protobuf.StructR\x08metadata\x12\x14\n\x05owner\x18\x12\x20\x01(\tR\x05o\
    wner\x12\x1d\n\npolicy_uri\x18\x13\x20\x01(\tR\tpolicyUri\x129\n\x19post\
    _logout_redirect_uris\x18\x14\x20\x03(\tR\x16postLogoutRedirectUris\x12#\
    \n\rredirect_uris\x18\x15\x20\x03(\tR\x0credirectUris\x12{\n\x1arequest_\
    object_signing_alg\x18\x16\x20\x01(\x0e2>.depot.devtools.auth.v0.identit\
    y.admin.RequestObjectSigningAlgR\x17requestObjectSigningAlg\x12!\n\x0cre\
    quest_uris\x18\x17\x20\x03(\tR\x0brequestUris\x12Z\n\x0eresponse_types\
    \x18\x18\x20\x03(\x0e23.depot.devtools.auth.v0.identity.admin.ResponseTy\
    peR\rresponseTypes\x12\x14\n\x05scope\x18\x19\x20\x01(\tR\x05scope\x122\
    \n\x15sector_identifier_uri\x18\x1a\x20\x01(\tR\x13sectorIdentifierUri\
    \x12U\n\x0csubject_type\x18\x1b\x20\x01(\x0e22.depot.devtools.auth.v0.id\
    entity.admin.SubjectTypeR\x0bsubjectType\x12{\n\x1atoken_endpoint_auth_m\
    ethod\x18\x1c\x20\x01(\x0e2>.depot.devtools.auth.v0.identity.admin.Token\
    EndpointAuthMethodR\x17tokenEndpointAuthMethod\x12\x88\x01\n\x1ftoken_en\
    dpoint_auth_signing_alg\x18\x1d\x20\x01(\x0e2B.depot.devtools.auth.v0.id\
    entity.admin.TokenEndpointAuthSigningAlgR\x1btokenEndpointAuthSigningAlg\
    \x12\x17\n\x07tos_uri\x18\x1e\x20\x01(\tR\x06tosUri\x129\n\nupdated_at\
    \x18\x1f\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tupdatedAt\x12\x81\
    \x01\n\x1cuserinfo_signed_response_alg\x18\x20\x20\x01(\x0e2@.depot.devt\
    ools.auth.v0.identity.admin.UserinfoSignedResponseAlgR\x19userinfoSigned\
    ResponseAlg\x12R\n\x0bclient_type\x18!\x20\x01(\x0e21.depot.devtools.aut\
    h.v0.identity.admin.ClientTypeR\nclientType\"\x8e\x0e\n\x19CreateOAuth2C\
    lientRequest\x120\n\x14allowed_cors_origins\x18\x01\x20\x03(\tR\x12allow\
    edCorsOrigins\x12\x1a\n\x08audience\x18\x02\x20\x03(\tR\x08audience\x12M\
    \n#backchannel_logout_session_required\x18\x03\x20\x01(\x08R\x20backchan\
    nelLogoutSessionRequired\x124\n\x16backchannel_logout_uri\x18\x04\x20\
    \x01(\tR\x14backchannelLogoutUri\x12\x1f\n\x0bclient_name\x18\x06\x20\
    \x01(\tR\nclientName\x12\x1d\n\nclient_uri\x18\x08\x20\x01(\tR\tclientUr\
    i\x12\x1a\n\x08contacts\x18\t\x20\x03(\tR\x08contacts\x12O\n$frontchanne\
    l_logout_session_required\x18\x0b\x20\x01(\x08R!frontchannelLogoutSessio\
    nRequired\x126\n\x17frontchannel_logout_uri\x18\x0c\x20\x01(\tR\x15front\
    channelLogoutUri\x12Q\n\x0bgrant_types\x18\r\x20\x03(\x0e20.depot.devtoo\
    ls.auth.v0.identity.admin.GrantTypeR\ngrantTypes\x12+\n\x04jwks\x18\x0e\
    \x20\x01(\x0b2\x17.google.protobuf.StructR\x04jwks\x12\x19\n\x08jwks_uri\
    \x18\x0f\x20\x01(\tR\x07jwksUri\x12\x19\n\x08logo_uri\x18\x10\x20\x01(\t\
    R\x07logoUri\x123\n\x08metadata\x18\x11\x20\x01(\x0b2\x17.google.protobu\
    f.StructR\x08metadata\x12\x14\n\x05owner\x18\x12\x20\x01(\tR\x05owner\
    \x12\x1d\n\npolicy_uri\x18\x13\x20\x01(\tR\tpolicyUri\x129\n\x19post_log\
    out_redirect_uris\x18\x14\x20\x03(\tR\x16postLogoutRedirectUris\x12#\n\r\
    redirect_uris\x18\x15\x20\x03(\tR\x0credirectUris\x12{\n\x1arequest_obje\
    ct_signing_alg\x18\x16\x20\x01(\x0e2>.depot.devtools.auth.v0.identity.ad\
    min.RequestObjectSigningAlgR\x17requestObjectSigningAlg\x12!\n\x0creques\
    t_uris\x18\x17\x20\x03(\tR\x0brequestUris\x12Z\n\x0eresponse_types\x18\
    \x18\x20\x03(\x0e23.depot.devtools.auth.v0.identity.admin.ResponseTypeR\
    \rresponseTypes\x12\x14\n\x05scope\x18\x19\x20\x01(\tR\x05scope\x122\n\
    \x15sector_identifier_uri\x18\x1a\x20\x01(\tR\x13sectorIdentifierUri\x12\
    U\n\x0csubject_type\x18\x1b\x20\x01(\x0e22.depot.devtools.auth.v0.identi\
    ty.admin.SubjectTypeR\x0bsubjectType\x12{\n\x1atoken_endpoint_auth_metho\
    d\x18\x1c\x20\x01(\x0e2>.depot.devtools.auth.v0.identity.admin.TokenEndp\
    ointAuthMethodR\x17tokenEndpointAuthMethod\x12\x88\x01\n\x1ftoken_endpoi\
    nt_auth_signing_alg\x18\x1d\x20\x01(\x0e2B.depot.devtools.auth.v0.identi\
    ty.admin.TokenEndpointAuthSigningAlgR\x1btokenEndpointAuthSigningAlg\x12\
    \x17\n\x07tos_uri\x18\x1e\x20\x01(\tR\x06tosUri\x12\x81\x01\n\x1cuserinf\
    o_signed_response_alg\x18\x1f\x20\x01(\x0e2@.depot.devtools.auth.v0.iden\
    tity.admin.UserinfoSignedResponseAlgR\x19userinfoSignedResponseAlg\x12#\
    \n\rclient_secret\x18\x20\x20\x01(\tR\x0cclientSecret\x12R\n\x0bclient_t\
    ype\x18!\x20\x01(\x0e21.depot.devtools.auth.v0.identity.admin.ClientType\
    R\nclientType\"^\n\x1aCreateOAuth2ClientResponse\x12\x1b\n\tclient_id\
    \x18\x01\x20\x01(\tR\x08clientId\x12#\n\rclient_secret\x18\x02\x20\x01(\
    \tR\x0cclientSecret\"\xd7\r\n\x19UpdateOAuth2ClientRequest\x120\n\x14all\
    owed_cors_origins\x18\x01\x20\x03(\tR\x12allowedCorsOrigins\x12\x1a\n\
    \x08audience\x18\x02\x20\x03(\tR\x08audience\x12M\n#backchannel_logout_s\
    ession_required\x18\x03\x20\x01(\x08R\x20backchannelLogoutSessionRequire\
    d\x124\n\x16backchannel_logout_uri\x18\x04\x20\x01(\tR\x14backchannelLog\
    outUri\x12\x1f\n\x0bclient_name\x18\x06\x20\x01(\tR\nclientName\x12\x1d\
    \n\nclient_uri\x18\x08\x20\x01(\tR\tclientUri\x12\x1a\n\x08contacts\x18\
    \t\x20\x03(\tR\x08contacts\x12O\n$frontchannel_logout_session_required\
    \x18\x0b\x20\x01(\x08R!frontchannelLogoutSessionRequired\x126\n\x17front\
    channel_logout_uri\x18\x0c\x20\x01(\tR\x15frontchannelLogoutUri\x12Q\n\
    \x0bgrant_types\x18\r\x20\x03(\x0e20.depot.devtools.auth.v0.identity.adm\
    in.GrantTypeR\ngrantTypes\x12+\n\x04jwks\x18\x0e\x20\x01(\x0b2\x17.googl\
    e.protobuf.StructR\x04jwks\x12\x19\n\x08jwks_uri\x18\x0f\x20\x01(\tR\x07\
    jwksUri\x12\x19\n\x08logo_uri\x18\x10\x20\x01(\tR\x07logoUri\x123\n\x08m\
    etadata\x18\x11\x20\x01(\x0b2\x17.google.protobuf.StructR\x08metadata\
    \x12\x14\n\x05owner\x18\x12\x20\x01(\tR\x05owner\x12\x1d\n\npolicy_uri\
    \x18\x13\x20\x01(\tR\tpolicyUri\x129\n\x19post_logout_redirect_uris\x18\
    \x14\x20\x03(\tR\x16postLogoutRedirectUris\x12#\n\rredirect_uris\x18\x15\
    \x20\x03(\tR\x0credirectUris\x12{\n\x1arequest_object_signing_alg\x18\
    \x16\x20\x01(\x0e2>.depot.devtools.auth.v0.identity.admin.RequestObjectS\
    igningAlgR\x17requestObjectSigningAlg\x12!\n\x0crequest_uris\x18\x17\x20\
    \x03(\tR\x0brequestUris\x12Z\n\x0eresponse_types\x18\x18\x20\x03(\x0e23.\
    depot.devtools.auth.v0.identity.admin.ResponseTypeR\rresponseTypes\x12\
    \x14\n\x05scope\x18\x19\x20\x01(\tR\x05scope\x122\n\x15sector_identifier\
    _uri\x18\x1a\x20\x01(\tR\x13sectorIdentifierUri\x12U\n\x0csubject_type\
    \x18\x1b\x20\x01(\x0e22.depot.devtools.auth.v0.identity.admin.SubjectTyp\
    eR\x0bsubjectType\x12{\n\x1atoken_endpoint_auth_method\x18\x1c\x20\x01(\
    \x0e2>.depot.devtools.auth.v0.identity.admin.TokenEndpointAuthMethodR\
    \x17tokenEndpointAuthMethod\x12\x88\x01\n\x1ftoken_endpoint_auth_signing\
    _alg\x18\x1d\x20\x01(\x0e2B.depot.devtools.auth.v0.identity.admin.TokenE\
    ndpointAuthSigningAlgR\x1btokenEndpointAuthSigningAlg\x12\x17\n\x07tos_u\
    ri\x18\x1e\x20\x01(\tR\x06tosUri\x12\x81\x01\n\x1cuserinfo_signed_respon\
    se_alg\x18\x1f\x20\x01(\x0e2@.depot.devtools.auth.v0.identity.admin.User\
    infoSignedResponseAlgR\x19userinfoSignedResponseAlg\x12#\n\rclient_secre\
    t\x18\x20\x20\x01(\tR\x0cclientSecret\x12\x1b\n\tclient_id\x18!\x20\x01(\
    \tR\x08clientId\"^\n\x1aUpdateOAuth2ClientResponse\x12\x1b\n\tclient_id\
    \x18\x01\x20\x01(\tR\x08clientId\x12#\n\rclient_secret\x18\x02\x20\x01(\
    \tR\x0cclientSecret\"8\n\x19DeleteOAuth2ClientRequest\x12\x1b\n\tclient_\
    id\x18\x01\x20\x01(\tR\x08clientId\"\x1c\n\x1aDeleteOAuth2ClientResponse\
    \"6\n\x13GetAddressesRequest\x12\x1f\n\x0bidentity_id\x18\x01\x20\x01(\t\
    R\nidentityId\"\xa4\x02\n\x14GetAddressesResponse\x12a\n\taddresses\x18\
    \x01\x20\x03(\x0b2C.depot.devtools.auth.v0.identity.admin.GetAddressesRe\
    sponse.AddressR\taddresses\x1a\xa8\x01\n\x07Address\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\tR\x02id\x12\x1f\n\x0bidentity_id\x18\x02\x20\x01(\tR\nide\
    ntityId\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x18\n\x07addre\
    ss\x18\x04\x20\x01(\tR\x07address\x12\x1a\n\x08verified\x18\x05\x20\x01(\
    \x08R\x08verified\x12\"\n\rid_schema_key\x18\x06\x20\x01(\tR\x0bidSchema\
    Key\"T\n\x11GetAddressRequest\x12\x10\n\x02id\x18\x01\x20\x01(\tH\0R\x02\
    id\x12$\n\x0cverification\x18\x02\x20\x01(\tH\0R\x0cverificationB\x07\n\
    \x05match\"\xb3\x01\n\x12GetAddressResponse\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\x12\x1f\n\x0bidentity_id\x18\x02\x20\x01(\tR\nidentityId\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x18\n\x07address\x18\
    \x04\x20\x01(\tR\x07address\x12\x1a\n\x08verified\x18\x05\x20\x01(\x08R\
    \x08verified\x12\"\n\rid_schema_key\x18\x06\x20\x01(\tR\x0bidSchemaKey\"\
    m\n\x14UpdateAddressRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\
    \x12\x1c\n\x08verified\x18\x02\x20\x01(\x08H\0R\x08verified\x12\x1a\n\
    \x07address\x18\x03\x20\x01(\tH\0R\x07addressB\x0b\n\tattribute\"\x17\n\
    \x15UpdateAddressResponse\"3\n\x10GetTraitsRequest\x12\x1f\n\x0bidentity\
    _id\x18\x01\x20\x01(\tR\nidentityId\"+\n\x11GetTraitsResponse\x12\x16\n\
    \x06traits\x18\x01\x20\x01(\tR\x06traits\"N\n\x13UpdateTraitsRequest\x12\
    \x1f\n\x0bidentity_id\x18\x01\x20\x01(\tR\nidentityId\x12\x16\n\x06trait\
    s\x18\x02\x20\x01(\tR\x06traits\"\x16\n\x14UpdateTraitsResponse\"B\n\x1f\
    GetIdentityLoginAttemptsRequest\x12\x1f\n\x0bidentity_id\x18\x01\x20\x01\
    (\tR\nidentityId\"\x91\x03\n\x20GetIdentityLoginAttemptsResponse\x12k\n\
    \x08attempts\x18\x01\x20\x03(\x0b2O.depot.devtools.auth.v0.identity.admi\
    n.GetIdentityLoginAttemptsResponse.AttemptR\x08attempts\x1a\xff\x01\n\
    \x07Attempt\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x1f\n\x0bident\
    ity_id\x18\x02\x20\x01(\tR\nidentityId\x12\x16\n\x06status\x18\x03\x20\
    \x01(\tR\x06status\x125\n\x16authentication_methods\x18\x04\x20\x03(\tR\
    \x15authenticationMethods\x129\n\ncreated_at\x18\x05\x20\x01(\x0b2\x1a.g\
    oogle.protobuf.TimestampR\tcreatedAt\x129\n\nexpires_at\x18\x06\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\texpiresAt\"^\n\x15CreateIdSchemaRe\
    quest\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x121\n\x07content\
    \x18\x02\x20\x01(\x0b2\x17.google.protobuf.StructR\x07content\"(\n\x16Cr\
    eateIdSchemaResponse\x12\x0e\n\x02id\x18\x02\x20\x01(\tR\x02id\"\x15\n\
    \x13GetIdSchemasRequest\"\xfb\x02\n\x14GetIdSchemasResponse\x12h\n\x0bjs\
    onschemas\x18\x01\x20\x03(\x0b2F.depot.devtools.auth.v0.identity.admin.G\
    etIdSchemasResponse.JsonSchemaR\x0bjsonschemas\x1a\xf8\x01\n\nJsonSchema\
    \x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x121\n\x07content\x18\x03\x20\x01(\x0b2\x17.google.prot\
    obuf.StructR\x07content\x129\n\ncreated_at\x18\x04\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.TimestampR\tcreatedAt\x129\n\nupdated_at\x18\x05\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\tupdatedAt\x12\x1d\n\nis_default\
    \x18\x06\x20\x01(\x08R\tisDefault\"$\n\x12GetIdSchemaRequest\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\tR\x02id\"\x81\x02\n\x13GetIdSchemaResponse\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\x04name\x18\x02\x20\x01\
    (\tR\x04name\x121\n\x07content\x18\x03\x20\x01(\x0b2\x17.google.protobuf\
    .StructR\x07content\x129\n\ncreated_at\x18\x04\x20\x01(\x0b2\x1a.google.\
    protobuf.TimestampR\tcreatedAt\x129\n\nupdated_at\x18\x05\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\tupdatedAt\x12\x1d\n\nis_default\x18\x06\
    \x20\x01(\x08R\tisDefault\"\x1b\n\x19GetDefaultIdSchemaRequest\"\x88\x02\
    \n\x1aGetDefaultIdSchemaResponse\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02\
    id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x121\n\x07content\x18\
    \x03\x20\x01(\x0b2\x17.google.protobuf.StructR\x07content\x129\n\ncreate\
    d_at\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tcreatedAt\x12\
    9\n\nupdated_at\x18\x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\tup\
    datedAt\x12\x1d\n\nis_default\x18\x06\x20\x01(\x08R\tisDefault\"n\n\x15U\
    pdateIdSchemaRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x121\n\x07content\x18\x03\x20\x01(\
    \x0b2\x17.google.protobuf.StructR\x07content\"\x18\n\x16UpdateIdSchemaRe\
    sponse\",\n\x1aMarkDefaultIdSchemaRequest\x12\x0e\n\x02id\x18\x01\x20\
    \x01(\tR\x02id\"\x1d\n\x1bMarkDefaultIdSchemaResponse\"'\n\x15DeleteIdSc\
    hemaRequest\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"\x18\n\x16DeleteI\
    dSchemaResponse\"\x17\n\x15GetEmailsSetupRequest\"\xcc\x07\n\x16GetEmail\
    sSetupResponse\x12e\n\x07welcome\x18\x01\x20\x01(\x0b2K.depot.devtools.a\
    uth.v0.identity.admin.GetEmailsSetupResponse.EmailTemplateR\x07welcome\
    \x12~\n\x14account_verification\x18\x02\x20\x01(\x0b2K.depot.devtools.au\
    th.v0.identity.admin.GetEmailsSetupResponse.EmailTemplateR\x13accountVer\
    ification\x12v\n\x10account_recovery\x18\x03\x20\x01(\x0b2K.depot.devtoo\
    ls.auth.v0.identity.admin.GetEmailsSetupResponse.EmailTemplateR\x0faccou\
    ntRecovery\x12x\n\x11account_recovered\x18\x04\x20\x01(\x0b2K.depot.devt\
    ools.auth.v0.identity.admin.GetEmailsSetupResponse.EmailTemplateR\x10acc\
    ountRecovered\x12]\n\x03otp\x18\x05\x20\x01(\x0b2K.depot.devtools.auth.v\
    0.identity.admin.GetEmailsSetupResponse.EmailTemplateR\x03otp\x12]\n\x04\
    smtp\x18\x06\x20\x01(\x0b2I.depot.devtools.auth.v0.identity.admin.GetEma\
    ilsSetupResponse.EmailSenderR\x04smtp\x12\x1d\n\nproject_id\x18\x07\x20\
    \x01(\tR\tprojectId\x1aC\n\rEmailTemplate\x12\x18\n\x07content\x18\x03\
    \x20\x01(\tR\x07content\x12\x18\n\x07subject\x18\x04\x20\x01(\tR\x07subj\
    ect\x1a\xb6\x01\n\x0bEmailSender\x12#\n\remail_address\x18\x01\x20\x01(\
    \tR\x0cemailAddress\x12\x1b\n\tsmtp_host\x18\x02\x20\x01(\tR\x08smtpHost\
    \x12\x1b\n\tsmtp_port\x18\x03\x20\x01(\rR\x08smtpPort\x12#\n\rsmtp_usern\
    ame\x18\x04\x20\x01(\tR\x0csmtpUsername\x12#\n\rsmtp_password\x18\x05\
    \x20\x01(\tR\x0csmtpPassword\"\xbc\x07\n\x18UpdateEmailsSetupRequest\x12\
    g\n\x07welcome\x18\x01\x20\x01(\x0b2M.depot.devtools.auth.v0.identity.ad\
    min.UpdateEmailsSetupRequest.EmailTemplateR\x07welcome\x12\x80\x01\n\x14\
    account_verification\x18\x02\x20\x01(\x0b2M.depot.devtools.auth.v0.ident\
    ity.admin.UpdateEmailsSetupRequest.EmailTemplateR\x13accountVerification\
    \x12x\n\x10account_recovery\x18\x03\x20\x01(\x0b2M.depot.devtools.auth.v\
    0.identity.admin.UpdateEmailsSetupRequest.EmailTemplateR\x0faccountRecov\
    ery\x12z\n\x11account_recovered\x18\x04\x20\x01(\x0b2M.depot.devtools.au\
    th.v0.identity.admin.UpdateEmailsSetupRequest.EmailTemplateR\x10accountR\
    ecovered\x12_\n\x03otp\x18\x05\x20\x01(\x0b2M.depot.devtools.auth.v0.ide\
    ntity.admin.UpdateEmailsSetupRequest.EmailTemplateR\x03otp\x12_\n\x04smt\
    p\x18\x06\x20\x01(\x0b2K.depot.devtools.auth.v0.identity.admin.UpdateEma\
    ilsSetupRequest.EmailSenderR\x04smtp\x1aC\n\rEmailTemplate\x12\x18\n\x07\
    content\x18\x01\x20\x01(\tR\x07content\x12\x18\n\x07subject\x18\x02\x20\
    \x01(\tR\x07subject\x1a\xb6\x01\n\x0bEmailSender\x12#\n\remail_address\
    \x18\x01\x20\x01(\tR\x0cemailAddress\x12\x1b\n\tsmtp_host\x18\x02\x20\
    \x01(\tR\x08smtpHost\x12\x1b\n\tsmtp_port\x18\x03\x20\x01(\rR\x08smtpPor\
    t\x12#\n\rsmtp_username\x18\x04\x20\x01(\tR\x0csmtpUsername\x12#\n\rsmtp\
    _password\x18\x05\x20\x01(\tR\x0csmtpPassword\"\x1b\n\x19UpdateEmailsSet\
    upResponse\"\xcb\x01\n\x1cGetUserBaseStatisticsRequest\x12\x1f\n\x0bdays\
    _before\x18\x01\x20\x01(\rR\ndaysBefore\x12F\n\x11lifetime_start_at\x18\
    \x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0flifetimeStartAt\x12\
    B\n\x0flifetime_end_at\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.Timesta\
    mpR\rlifetimeEndAt\"\xa1\x04\n\x1dGetUserBaseStatisticsResponse\x12\x1f\
    \n\x0btotal_users\x18\x01\x20\x01(\x05R\ntotalUsers\x12y\n\rusers_per_da\
    y\x18\x02\x20\x03(\x0b2U.depot.devtools.auth.v0.identity.admin.GetUserBa\
    seStatisticsResponse.UsersPerDayEntryR\x0busersPerDay\x12\x82\x01\n\x10s\
    essions_per_day\x18\x03\x20\x03(\x0b2X.depot.devtools.auth.v0.identity.a\
    dmin.GetUserBaseStatisticsResponse.SessionsPerDayEntryR\x0esessionsPerDa\
    y\x12,\n\x12total_active_users\x18\x04\x20\x01(\x05R\x10totalActiveUsers\
    \x12.\n\x13total_lifetime_used\x18\x05\x20\x01(\x01R\x11totalLifetimeUse\
    d\x1a>\n\x10UsersPerDayEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05value:\x028\x01\x1aA\n\x13S\
    essionsPerDayEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\x05R\x05value:\x028\x01*l\n\nClientType\x12\
    \x15\n\x11CLIENT_TYPE_UNSET\x10\0\x12\x16\n\x12CLIENT_FIRST_PARTY\x10\
    \x01\x12\x16\n\x12CLIENT_THIRD_PARTY\x10\x02\x12\x17\n\x13CLIENT_SYSTEM_\
    PARTY\x10\x03*A\n\x0bSubjectType\x12\x17\n\x13SUBJECT_TYPE_PUBLIC\x10\0\
    \x12\x19\n\x15SUBJECT_TYPE_PAIRWISE\x10\x01*\xd5\x01\n\x17TokenEndpointA\
    uthMethod\x122\n.TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_BASIC\x10\0\
    \x121\n-TOKEN_ENDPOINT_AUTH_METHOD_CLIENT_SECRET_POST\x10\x01\x12.\n*TOK\
    EN_ENDPOINT_AUTH_METHOD_PRIVATE_KEY_JWT\x10\x02\x12#\n\x1fTOKEN_ENDPOINT\
    _AUTH_METHOD_NONE\x10\x03*\xcb\x03\n\x1bTokenEndpointAuthSigningAlg\x12)\
    \n%TOKEN_ENDPOINT_AUTH_SIGNING_ALG_UNSET\x10\0\x12)\n%TOKEN_ENDPOINT_AUT\
    H_SIGNING_ALG_RS256\x10\x01\x12)\n%TOKEN_ENDPOINT_AUTH_SIGNING_ALG_RS384\
    \x10\x02\x12)\n%TOKEN_ENDPOINT_AUTH_SIGNING_ALG_RS512\x10\x03\x12)\n%TOK\
    EN_ENDPOINT_AUTH_SIGNING_ALG_PS256\x10\x04\x12)\n%TOKEN_ENDPOINT_AUTH_SI\
    GNING_ALG_PS384\x10\x05\x12)\n%TOKEN_ENDPOINT_AUTH_SIGNING_ALG_PS512\x10\
    \x06\x12)\n%TOKEN_ENDPOINT_AUTH_SIGNING_ALG_ES256\x10\x07\x12)\n%TOKEN_E\
    NDPOINT_AUTH_SIGNING_ALG_ES384\x10\x08\x12)\n%TOKEN_ENDPOINT_AUTH_SIGNIN\
    G_ALG_ES512\x10\t*\xba\x01\n\tGrantType\x12\x14\n\x10GRANT_TYPE_UNSET\
    \x10\0\x12!\n\x1dGRANT_TYPE_CLIENT_CREDENTIALS\x10\x01\x12!\n\x1dGRANT_T\
    YPE_AUTHORIZATION_CODE\x10\x02\x12\x17\n\x13GRANT_TYPE_IMPLICIT\x10\x03\
    \x12\x1c\n\x18GRANT_TYPE_REFRESH_TOKEN\x10\x04\x12\x1a\n\x16GRANT_TYPE_D\
    EVICE_CODE\x10\x05*\x94\x02\n\x0cResponseType\x12\x17\n\x13RESPONSE_TYPE\
    _UNSET\x10\0\x12\x16\n\x12RESPONSE_TYPE_NONE\x10\x01\x12\x1a\n\x16RESPON\
    SE_TYPE_ID_TOKEN\x10\x02\x12\x17\n\x13RESPONSE_TYPE_TOKEN\x10\x03\x12\
    \x16\n\x12RESPONSE_TYPE_CODE\x10\x04\x12\x20\n\x1cRESPONSE_TYPE_ID_TOKEN\
    _TOKEN\x10\x05\x12\x1f\n\x1bRESPONSE_TYPE_CODE_ID_TOKEN\x10\x06\x12\x1c\
    \n\x18RESPONSE_TYPE_CODE_TOKEN\x10\x07\x12%\n!RESPONSE_TYPE_CODE_ID_TOKE\
    N_TOKEN\x10\x08*\x8a\x01\n\x17RequestObjectSigningAlg\x12$\n\x20REQUEST_\
    OBJECT_SIGNING_ALG_UNSET\x10\0\x12#\n\x1fREQUEST_OBJECT_SIGNING_ALG_NONE\
    \x10\x01\x12$\n\x20REQUEST_OBJECT_SIGNING_ALG_RS256\x10\x02*\x92\x01\n\
    \x19UserinfoSignedResponseAlg\x12&\n\"USERINFO_SIGNED_RESPONSE_ALG_UNSET\
    \x10\0\x12%\n!USERINFO_SIGNED_RESPONSE_ALG_NONE\x10\x01\x12&\n\"USERINFO\
    _SIGNED_RESPONSE_ALG_RS256\x10\x022\xa3&\n\x05Admin\x12\x8d\x01\n\x0eCre\
    ateIdentity\x12<.depot.devtools.auth.v0.identity.admin.CreateIdentityReq\
    uest\x1a=.depot.devtools.auth.v0.identity.admin.CreateIdentityResponse\
    \x12\x84\x01\n\x0bGetIdentity\x129.depot.devtools.auth.v0.identity.admin\
    .GetIdentityRequest\x1a:.depot.devtools.auth.v0.identity.admin.GetIdenti\
    tyResponse\x12\xa8\x01\n\x17GetIdentityByIdentifier\x12E.depot.devtools.\
    auth.v0.identity.admin.GetIdentityByIdentifierRequest\x1aF.depot.devtool\
    s.auth.v0.identity.admin.GetIdentityByIdentifierResponse\x12\xab\x01\n\
    \x18GetIdentitiesByAttribute\x12F.depot.devtools.auth.v0.identity.admin.\
    GetIdentitiesByAttributeRequest\x1aG.depot.devtools.auth.v0.identity.adm\
    in.GetIdentitiesByAttributeResponse\x12\x8a\x01\n\rGetIdentities\x12;.de\
    pot.devtools.auth.v0.identity.admin.GetIdentitiesRequest\x1a<.depot.devt\
    ools.auth.v0.identity.admin.GetIdentitiesResponse\x12\x8d\x01\n\x0eUpdat\
    eIdentity\x12<.depot.devtools.auth.v0.identity.admin.UpdateIdentityReque\
    st\x1a=.depot.devtools.auth.v0.identity.admin.UpdateIdentityResponse\x12\
    \x8d\x01\n\x0eDeleteIdentity\x12<.depot.devtools.auth.v0.identity.admin.\
    DeleteIdentityRequest\x1a=.depot.devtools.auth.v0.identity.admin.DeleteI\
    dentityResponse\x12\x87\x01\n\x0cGetAddresses\x12:.depot.devtools.auth.v\
    0.identity.admin.GetAddressesRequest\x1a;.depot.devtools.auth.v0.identit\
    y.admin.GetAddressesResponse\x12\x81\x01\n\nGetAddress\x128.depot.devtoo\
    ls.auth.v0.identity.admin.GetAddressRequest\x1a9.depot.devtools.auth.v0.\
    identity.admin.GetAddressResponse\x12\x8a\x01\n\rUpdateAddress\x12;.depo\
    t.devtools.auth.v0.identity.admin.UpdateAddressRequest\x1a<.depot.devtoo\
    ls.auth.v0.identity.admin.UpdateAddressResponse\x12~\n\tGetTraits\x127.d\
    epot.devtools.auth.v0.identity.admin.GetTraitsRequest\x1a8.depot.devtool\
    s.auth.v0.identity.admin.GetTraitsResponse\x12\x87\x01\n\x0cUpdateTraits\
    \x12:.depot.devtools.auth.v0.identity.admin.UpdateTraitsRequest\x1a;.dep\
    ot.devtools.auth.v0.identity.admin.UpdateTraitsResponse\x12\x8d\x01\n\
    \x0eGetCredentials\x12<.depot.devtools.auth.v0.identity.admin.GetCredent\
    ialsRequest\x1a=.depot.devtools.auth.v0.identity.admin.GetCredentialsRes\
    ponse\x12\x93\x01\n\x10UpdateCredential\x12>.depot.devtools.auth.v0.iden\
    tity.admin.UpdateCredentialRequest\x1a?.depot.devtools.auth.v0.identity.\
    admin.UpdateCredentialResponse\x12\xab\x01\n\x18GetIdentityLoginAttempts\
    \x12F.depot.devtools.auth.v0.identity.admin.GetIdentityLoginAttemptsRequ\
    est\x1aG.depot.devtools.auth.v0.identity.admin.GetIdentityLoginAttemptsR\
    esponse\x12\x93\x01\n\x10CreateConnection\x12>.depot.devtools.auth.v0.id\
    entity.admin.CreateConnectionRequest\x1a?.depot.devtools.auth.v0.identit\
    y.admin.CreateConnectionResponse\x12\x8d\x01\n\x0eGetConnections\x12<.de\
    pot.devtools.auth.v0.identity.admin.GetConnectionsRequest\x1a=.depot.dev\
    tools.auth.v0.identity.admin.GetConnectionsResponse\x12\x93\x01\n\x10Upd\
    ateConnection\x12>.depot.devtools.auth.v0.identity.admin.UpdateConnectio\
    nRequest\x1a?.depot.devtools.auth.v0.identity.admin.UpdateConnectionResp\
    onse\x12\x93\x01\n\x10DeleteConnection\x12>.depot.devtools.auth.v0.ident\
    ity.admin.DeleteConnectionRequest\x1a?.depot.devtools.auth.v0.identity.a\
    dmin.DeleteConnectionResponse\x12\x8d\x01\n\x0eCreateIdSchema\x12<.depot\
    .devtools.auth.v0.identity.admin.CreateIdSchemaRequest\x1a=.depot.devtoo\
    ls.auth.v0.identity.admin.CreateIdSchemaResponse\x12\x87\x01\n\x0cGetIdS\
    chemas\x12:.depot.devtools.auth.v0.identity.admin.GetIdSchemasRequest\
    \x1a;.depot.devtools.auth.v0.identity.admin.GetIdSchemasResponse\x12\x84\
    \x01\n\x0bGetIdSchema\x129.depot.devtools.auth.v0.identity.admin.GetIdSc\
    hemaRequest\x1a:.depot.devtools.auth.v0.identity.admin.GetIdSchemaRespon\
    se\x12\x99\x01\n\x12GetDefaultIdSchema\x12@.depot.devtools.auth.v0.ident\
    ity.admin.GetDefaultIdSchemaRequest\x1aA.depot.devtools.auth.v0.identity\
    .admin.GetDefaultIdSchemaResponse\x12\x8d\x01\n\x0eUpdateIdSchema\x12<.d\
    epot.devtools.auth.v0.identity.admin.UpdateIdSchemaRequest\x1a=.depot.de\
    vtools.auth.v0.identity.admin.UpdateIdSchemaResponse\x12\x9c\x01\n\x13Ma\
    rkDefaultIdSchema\x12A.depot.devtools.auth.v0.identity.admin.MarkDefault\
    IdSchemaRequest\x1aB.depot.devtools.auth.v0.identity.admin.MarkDefaultId\
    SchemaResponse\x12\x8d\x01\n\x0eDeleteIdSchema\x12<.depot.devtools.auth.\
    v0.identity.admin.DeleteIdSchemaRequest\x1a=.depot.devtools.auth.v0.iden\
    tity.admin.DeleteIdSchemaResponse\x12\x99\x01\n\x12CreateOAuth2Client\
    \x12@.depot.devtools.auth.v0.identity.admin.CreateOAuth2ClientRequest\
    \x1aA.depot.devtools.auth.v0.identity.admin.CreateOAuth2ClientResponse\
    \x12\x93\x01\n\x10GetOAuth2Clients\x12>.depot.devtools.auth.v0.identity.\
    admin.GetOAuth2ClientsRequest\x1a?.depot.devtools.auth.v0.identity.admin\
    .GetOAuth2ClientsResponse\x12\x99\x01\n\x12UpdateOAuth2Client\x12@.depot\
    .devtools.auth.v0.identity.admin.UpdateOAuth2ClientRequest\x1aA.depot.de\
    vtools.auth.v0.identity.admin.UpdateOAuth2ClientResponse\x12\x99\x01\n\
    \x12DeleteOAuth2Client\x12@.depot.devtools.auth.v0.identity.admin.Delete\
    OAuth2ClientRequest\x1aA.depot.devtools.auth.v0.identity.admin.DeleteOAu\
    th2ClientResponse\x12\x8d\x01\n\x0eGetEmailsSetup\x12<.depot.devtools.au\
    th.v0.identity.admin.GetEmailsSetupRequest\x1a=.depot.devtools.auth.v0.i\
    dentity.admin.GetEmailsSetupResponse\x12\x96\x01\n\x11UpdateEmailsSetup\
    \x12?.depot.devtools.auth.v0.identity.admin.UpdateEmailsSetupRequest\x1a\
    @.depot.devtools.auth.v0.identity.admin.UpdateEmailsSetupResponse\x12\
    \xa2\x01\n\x15GetUserBaseStatistics\x12C.depot.devtools.auth.v0.identity\
    .admin.GetUserBaseStatisticsRequest\x1aD.depot.devtools.auth.v0.identity\
    .admin.GetUserBaseStatisticsResponseB\xa2\x01\n\x18dev.auth3.identity.ad\
    minB\nAdminProtoP\x01Z'github.com/auth3-dev/go-sdk/admin;admin\xf8\x01\
    \x01\xa2\x02\x04A3IA\xaa\x02\x14Auth3.Identity.Admin\xea\x02\x16Auth3::I\
    dentity::Admin\xca\x02\x14Auth3\\Identity\\Adminb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
